---
created time: 2024-04-17 23:06:59
updated time: 2024-04-17 23:07:00
dtype: 概念
subject: C++
tags:
  - review
dg-publish: true
banner: https://source.unsplash.com/900x1600/?tree
banner_icon: 🧠
created: 2024-04-17T23:06
updated: 2025-01-12T19:56
---

# 选择排序法

选择排序法是一种简单直观的排序算法，其核心思想是在每一轮选择中找到最小（或最大）元素，并将其与当前轮次的起始元素交换位置。

## 排序过程

1. **初始化**：从数组的开头开始。
2. **寻找最小值**：在未排序的序列中找到最小元素。
3. **交换**：将找到的最小元素与当前位置的元素交换。
4. **移动选择区域**：将选择区域移动到下一个位置。
5. **重复**：重复以上步骤，直到所有元素都被排序。

## 核心代码

```C++
void selectSort(int a[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int min = i; // 假设当前位置为最小值位置
        for (int j = i + 1; j < n; j++) {
            if (a[j] < a[min]) { // 找到更小的元素，更新最小值位置
                min = j;
            }
        }
        // 将找到的最小值与第i位交换
        swap(a[i], a[min]);
    }
}
```

## 选择排序的变种

- **升序排序**：上述代码即为升序选择排序的实现。
- **降序排序**：只需在比较时交换`<`为`>`即可。

## 选择排序的优化

- **双向选择排序**：在每一轮中同时找到最小和最大的元素，然后同时进行交换，减少不必要的交换次数。

## 选择排序的优缺点

- **优点**：
  - 算法简单，容易实现。
  - 原地排序，不需要额外的存储空间。
- **缺点**：
  - 效率不高，时间复杂度为O(n^2)。
  - 排序过程不稳定，相同的元素可能会改变原来的顺序。

## 适用场景

选择排序适合于数据量较小或者近乎有序的数组，因为它能减少不必要的数据交换。

## 示例

假设有一个数组`[49, 38, 65, 97, 76, 13, 27]`，使用选择排序后的步骤如下：

1. 找到最小值13，与第一个元素49交换。
2. 找到剩余部分最小值27，与第二个元素38交换。
3. 重复上述过程，直到数组排序完成。

最终得到排序后的数组：`[13, 27, 38, 49, 65, 76, 97]`。

选择排序是一种基础的排序算法，虽然在实际应用中不如一些高效的算法（如快速排序、归并排序等），但它的原理和实现方式对于理解更复杂的排序算法非常有帮助。

