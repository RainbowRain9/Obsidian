---
created time: 2024-04-17 23:10:35
updated time: 2024-04-18 03:19:15
dtype: 概念
subject: C++
tags:
  - review
dg-publish: true
banner: https://source.unsplash.com/900x1600/?tree
banner_icon: 🧠
created: 2024-04-17T23:10
updated: 2025-01-12T19:56
---

# 冒泡排序法

冒泡排序是一种简单的排序算法，它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

## 排序过程

1. **开始**：从数组的第一个元素开始。
2. **比较相邻元素**：比较每对相邻元素，如果第一个元素大于第二个，则交换它们。
3. **移动**：移动到下一对相邻元素，重复比较和交换的过程。
4. **重复**：持续遍历数组，直到最后一次交换发生，这时排序完成。

## 核心代码

```C++
void bubbleSort(int a[], int n)
{
    for (int i = n - 2; i >= 0; i--)
    { // 外层循环控制排序的轮数
        for (int j = 0; j <= i; j++)
        { // 内层循环负责比较和交换
            if (a[j] > a[j + 1])
            { // 相邻元素比较，如果不满足排序条件，交换它们
                swap(a[j], a[j + 1]);
            }
        }
    }
}
```

## 冒泡排序的优化

- **记录最后一次交换的位置**：由于每次内层循环都会将最大的元素移动到它的最终位置，因此可以优化外层循环的结束条件，减少不必要的比较。

## 冒泡排序的优缺点

- **优点**：
  - 算法简单，易于实现。
  - 原地排序，不需要额外的存储空间。
  - 时间复杂度为 O (n^2)，在数据量较小时效率可接受。

- **缺点**：
  - 效率相对较低，特别是在数据量较大时。
  - 排序过程不稳定，相同的元素可能会改变顺序。

## 适用场景

冒泡排序适合于数据量较小或者近乎有序的数组，因为它可以通过较小的比较次数完成排序。

## 示例

假设有一个数组 `[9, 8, 5, 7, 6]`，使用冒泡排序后的步骤如下：

1. 第一轮冒泡后：`[8, 5, 7, 6, 9]`（9 冒泡到了最后）
2. 第二轮冒泡后：`[5, 6, 7, 8, 9]`（8 冒泡到了它的位置）
3. 第三轮冒泡后：`[5, 6, 7, 8, 9]`（数组已排序完成）

最终得到排序后的数组：`[5, 6, 7, 8, 9]`。

冒泡排序虽然在效率上不如一些更高级的排序算法，但它的原理简单，是学习算法基础的重要内容。

