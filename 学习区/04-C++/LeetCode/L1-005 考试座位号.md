# L1-005. 考试座位号

## 一、前置知识

*   **`unordered_map` (哈希表):** C++ STL 容器，提供键值对（key-value）的快速存储和查找，平均时间复杂度为 O(1)。在本题中，用于存储试机座位号到考生信息（准考证号、考试座位号）的映射。
*   **`pair`:** C++ STL 工具，用于将两个值组合成一个单元。在本题中，用于存储准考证号（`string`）和考试座位号（`int`）。
*   **`string`:** C++ STL 类，用于处理字符串（准考证号）。
*   **C++ 基本输入输出 (`cin`, `cout`):** 用于从标准输入读取数据和向标准输出打印结果。

## 二、题目分析

### 1. 题目描述

*   题目链接：[L1-005 考试座位号](https://pintia.cn/problem-sets/994805046380707840/exam/problems/994805140211482624)
*   本地链接：[L1-005-考试座位号.cpp](../Algorithm/PTA/L1-005-考试座位号.cpp)
*   难度级别：简单
*   相关标签：哈希表、映射、查找

### 2. 题目要求

*   **输入:**
    *   第一行：正整数 N (≤1000)，表示考生人数。
    *   接下来 N 行：每行包含一个考生的信息：`准考证号` (16位数字字符串) `试机座位号` (整数) `考试座位号` (整数)。
    *   接下来一行：正整数 M (≤N)，表示查询次数。
    *   最后一行：M 个整数，表示待查询的试机座位号。
*   **输出:**
    *   对每个查询的试机座位号，输出一行，包含对应的 `准考证号` 和 `考试座位号`，用空格隔开。
*   **时间/空间限制:** 通常 PTA 题目有标准的时间（如 1s 或 2s）和空间限制（如 64MB 或 128MB），此题数据量不大，常规解法即可通过。

### 3. 关键概念

*   **映射关系:** 核心在于建立“试机座位号”到“准考证号和考试座位号”的映射。
*   **快速查找:** 需要根据给定的试机座位号，快速找到对应的考生信息。
*   **唯一性:** 题目保证准考证号唯一，且不会有两个考生分配到同一个座位（包括试机和考试座位），这简化了处理，不需要考虑冲突。

## 三、示例分析

### 1. 基本示例

```
输入：
4
3310120150912233 2 4
3310120150912119 4 1
3310120150912126 1 3
3310120150912002 3 2
2
3 4

输出：
3310120150912002 2
3310120150912119 1
```

*   **解释:**
    1.  读取 N=4 个考生信息，并存储。例如，对于考生 `3310120150912002 3 2`，我们建立映射：试机座位号 `3` -> {准考证号 `3310120150912002`, 考试座位号 `2`}。
    2.  读取 M=2 个查询。
    3.  查询试机座位号 `3`：通过映射找到考生 `3310120150912002`，考试座位号为 `2`，输出 `3310120150912002 2`。
    4.  查询试机座位号 `4`：通过映射找到考生 `3310120150912119`，考试座位号为 `1`，输出 `3310120150912119 1`。

### 2. 特殊情况

*   **输入:**
    ```
    1
    1234567890123456 1 1
    1
    1
    ```
*   **输出:**
    ```
    1234567890123456 1
    ```
*   **分析:** 只有一个考生，查询他自己的试机座位号，能正确输出。

### 3. 边界测试

*   **输入:** (N=1000, M=1000)
    ```
    1000
    (此处省略1000行考生信息, 假设试机座位号为 1 到 1000)
    ...
    1000
    1 2 3 ... 1000 (查询所有试机座位号)
    ```
*   **输出:** (对应1000行输出)
*   **说明:** 测试最大数据量下的性能，`unordered_map` 的效率是关键。

## 四、解题思路

### 1. 问题分析

*   **本质:** 这是一个典型的查找问题。我们需要根据一个标识（试机座位号）快速检索到相关联的信息（准考证号、考试座位号）。
*   **可能方案:**
    *   **线性搜索:** 将 N 个考生信息存储在数组或 `vector` 中。对于每个查询，遍历整个数组/`vector` 查找匹配的试机座位号。时间复杂度 O(N*M)，对于 N, M 最大为 1000，复杂度为 O(10^6)，可行。
    *   **排序+二分查找:** 将考生信息按试机座位号排序。对于每个查询，使用二分查找。预处理排序 O(N log N)，查询 O(M log N)。总复杂度 O(N log N + M log N)，优于线性搜索。
    *   **哈希表 (`unordered_map`):** 使用试机座位号作为键（key），存储考生信息（准考证号和考试座位号组成的 `pair`）作为值（value）。构建哈希表 O(N)，每次查询 O(1)（平均）。总复杂度 O(N + M)。这是最优的方案。
*   **方案比较:** 哈希表方案在时间和实现复杂度上都具有优势。

### 2. 算法设计

*   **核心算法:** 哈希查找。
*   **数据结构:** `unordered_map<int, pair<string, int>>`
    *   `key`: `int` 类型，存储试机座位号。
    *   `value`: `pair<string, int>` 类型，存储准考证号和考试座位号。
*   **优化思路:** 无需进一步优化，哈希表已经是高效方案。

### 3. 解题步骤

1.  **读取考生数量 N:** 从输入读取第一个整数 N。
2.  **创建哈希表:** 声明一个 `unordered_map<int, pair<string, int>> mp;`。
3.  **读取并存储考生信息:**
    *   循环 N 次。
    *   在每次循环中，读取 `id` (string), `testSeat` (int), `examSeat` (int)。
    *   将信息存入哈希表：`mp[testSeat] = {id, examSeat};`。 这里利用 `unordered_map` 的 `[]` 操作符，如果 `testSeat` 不存在，会自动创建；如果存在，则会覆盖（但在本题中不会出现重复的 `testSeat`）。 `{id, examSeat}` 会隐式创建一个 `pair` 对象。
4.  **读取查询数量 M:** 从输入读取整数 M。
5.  **处理查询:**
    *   循环 M 次。
    *   在每次循环中，读取待查询的试机座位号 `querySeat` (int)。
    *   在哈希表中查找：`mp[querySeat]`。这会返回与 `querySeat` 关联的 `pair<string, int>`。
    *   输出结果：`cout << mp[querySeat].first << " " << mp[querySeat].second << endl;`。 `.first` 访问 `pair` 中的准考证号，`.second` 访问考试座位号。

## 五、代码实现

### 1. 完整代码

```cpp
/*
 * @Author: RainbowRain9
 * @Date: 2025-04-01 22:50:46
 * @LastEditTime: 2025-04-01 23:04:45
 * @FilePath: \C++\Algorithm\PTA\L1-005-考试座位号.cpp
 * @Description: https://pintia.cn/problem-sets/994805046380707840/exam/problems/type/7?problemSetProblemId=994805140211482624
 */
// 包含必要的头文件
#include <iostream>
#include <unordered_map> // 使用哈希表
#include <string>       // 使用字符串
#include <vector>       // 虽然本题最终没用vector，但通常包含
#include <utility>      // 使用 pair

using namespace std; // 使用标准命名空间

/**
 * @brief 主函数，处理输入输出和核心逻辑
 * @param argc 命令行参数数量
 * @param argv 命令行参数数组
 * @return int 程序退出码，0表示成功
 */
int main()
{
    // 声明哈希表，键是试机座位号(int)，值是包含准考证号(string)和考试座位号(int)的pair
    unordered_map<int, pair<string, int>> mp;
    int n; // 考生数量
    // 读取考生数量
    cin >> n;

    // 循环读取n个考生的信息
    for (int i = 0; i < n; i++)
    {
        int testSeat, examSeat; // 试机座位号, 考试座位号
        string id;             // 准考证号
        // 读取一行考生信息
        cin >> id >> testSeat >> examSeat;
        // 将信息存入哈希表，以试机座位号为键
        mp[testSeat] = {id, examSeat}; // 使用 C++11 的列表初始化创建 pair
    }

    int m; // 查询数量
    // 读取查询数量
    cin >> m;

    // 循环处理m个查询
    while (m--)
    {
        int querySeat; // 待查询的试机座位号
        // 读取一个查询
        cin >> querySeat;
        // 使用哈希表查找并输出结果
        // mp[querySeat] 返回与 querySeat 关联的 pair
        // .first 获取 pair 的第一个元素 (准考证号)
        // .second 获取 pair 的第二个元素 (考试座位号)
        cout << mp[querySeat].first << " " << mp[querySeat].second << endl;
    }

    return 0; // 程序正常结束
}
```

### 2. 关键代码段解析

```cpp
// 声明哈希表，键是试机座位号(int)，值是包含准考证号(string)和考试座位号(int)的pair
unordered_map<int, pair<string, int>> mp;
```

*   **说明:** 定义了核心数据结构 `mp`。`unordered_map` 提供了高效的键值查找。选择 `int` 作为键是因为试机座位号是整数，选择 `pair<string, int>` 作为值是因为需要同时存储准考证号和考试座位号。

```cpp
// 将信息存入哈希表，以试机座位号为键
mp[testSeat] = {id, examSeat}; // 使用 C++11 的列表初始化创建 pair
```

*   **说明:** 这是将读取到的考生信息存入哈希表的关键步骤。`mp[testSeat]` 通过试机座位号访问或创建哈希表中的条目。`{id, examSeat}` 使用列表初始化简洁地创建了一个 `pair` 对象，该对象被赋给 `mp[testSeat]`。

```cpp
// 使用哈希表查找并输出结果
cout << mp[querySeat].first << " " << mp[querySeat].second << endl;
```

*   **说明:** 这是处理查询的关键步骤。`mp[querySeat]` 直接通过试机座位号在哈希表中查找对应的值（即 `pair` 对象）。`.first` 和 `.second` 分别访问 `pair` 中的准考证号和考试座位号，然后输出。

### 3. 代码优化

*   当前代码已经使用了最优的数据结构和算法，对于本题的数据规模，无需进一步优化。
*   **潜在优化（非必需）:** 如果内存极度受限，可以考虑将准考证号（长字符串）映射到一个整数 ID 来节省空间，但这会增加实现的复杂度。对于本题没有必要。
*   **健壮性（非必需）:** 题设保证查询的 `querySeat` 一定存在于输入的考生信息中。如果不能保证，使用 `mp.find(querySeat)` 或 `mp.count(querySeat)` 来检查键是否存在会更安全，避免访问不存在的键（`[]` 操作符会插入一个默认构造的值）。

## 六、模拟代码过程

### 1. 执行流程 (使用示例输入)

1.  **输入 N:** `cin >> n;` 读取 `n = 4`。
2.  **循环 1 (i=0):**
    *   `cin >> id >> testSeat >> examSeat;` 读取 `"3310120150912233"`, `2`, `4`。
    *   `mp[2] = {"3310120150912233", 4};` 哈希表 `mp` 状态：`{ 2: {"3310120150912233", 4} }`。
3.  **循环 2 (i=1):**
    *   `cin >> id >> testSeat >> examSeat;` 读取 `"3310120150912119"`, `4`, `1`。
    *   `mp[4] = {"3310120150912119", 1};` 哈希表 `mp` 状态：`{ 2: {"...", 4}, 4: {"3310120150912119", 1} }`。
4.  **循环 3 (i=2):**
    *   `cin >> id >> testSeat >> examSeat;` 读取 `"3310120150912126"`, `1`, `3`。
    *   `mp[1] = {"3310120150912126", 3};` 哈希表 `mp` 状态：`{ 2: {"...", 4}, 4: {"...", 1}, 1: {"3310120150912126", 3} }`。
5.  **循环 4 (i=3):**
    *   `cin >> id >> testSeat >> examSeat;` 读取 `"3310120150912002"`, `3`, `2`。
    *   `mp[3] = {"3310120150912002", 2};` 哈希表 `mp` 最终状态：`{ 2: {"...", 4}, 4: {"...", 1}, 1: {"...", 3}, 3: {"3310120150912002", 2} }`。
6.  **输入 M:** `cin >> m;` 读取 `m = 2`。
7.  **查询循环 1 (m=2 -> 1):**
    *   `cin >> querySeat;` 读取 `querySeat = 3`。
    *   `cout << mp[3].first << " " << mp[3].second << endl;` 查找 `mp[3]` 得到 `{"3310120150912002", 2}`，输出 `"3310120150912002 2"`。
8.  **查询循环 2 (m=1 -> 0):**
    *   `cin >> querySeat;` 读取 `querySeat = 4`。
    *   `cout << mp[4].first << " " << mp[4].second << endl;` 查找 `mp[4]` 得到 `{"3310120150912119", 1}`，输出 `"3310120150912119 1"`。
9.  **结束:** `return 0;`

### 2. 图示说明

```mermaid
graph TD
    A[开始] --> B{读取 N};
    B --> C{创建 unordered_map mp};
    C --> D{循环 N 次读取考生信息};
    D -- 读取 id, testSeat, examSeat --> E{ mp[testSeat] = {id, examSeat}};
    E --> D;
    D -- 循环结束 --> F{读取 M};
    F --> G{循环 M 次处理查询};
    G -- 读取 querySeat --> H{查找 mp[querySeat]};
    H --> I{输出 mp[querySeat].first 和 mp[querySeat].second};
    I --> G;
    G -- 循环结束 --> J[结束];
```

### 3. 调试技巧

*   **打印哈希表内容:** 在读取完 N 个考生信息后，可以添加循环遍历 `mp` 并打印其内容，以确认数据是否正确存储。
    ```cpp
    // for (auto const& [key, val] : mp) { // C++17 结构化绑定
    //     cout << "Test Seat: " << key << " -> ID: " << val.first << ", Exam Seat: " << val.second << endl;
    // }
    // 或者 C++11
    for (const auto& pair_entry : mp) {
        cout << "Test Seat: " << pair_entry.first << " -> ID: " << pair_entry.second.first << ", Exam Seat: " << pair_entry.second.second << endl;
    }
    ```
*   **单步调试:** 在查询部分设置断点，观察每次读取 `querySeat` 后，`mp[querySeat]` 是否能正确获取到对应的 `pair`。
*   **检查输入:** 确保 `cin` 读取没有出错，特别是在循环中。

## 七、复杂度分析

### 1. 时间复杂度

*   **读取 N 个考生信息并存入 `unordered_map`:** 平均情况下，每次插入 `unordered_map` 的时间复杂度是 O(1)。总共 N 次插入，所以是 O(N)。最坏情况下（哈希冲突严重），可能退化到 O(N^2)，但在良好设计的哈希函数下很少发生。
*   **读取 M 个查询并在 `unordered_map` 中查找:** 平均情况下，每次查找的时间复杂度是 O(1)。总共 M 次查询，所以是 O(M)。最坏情况 O(M*N)。
*   **总体平均时间复杂度:** O(N + M)。
*   **总体最坏时间复杂度:** O(N^2 + M*N) 或 O(N + M*N) 取决于实现，但通常认为是 O(N+M)。

### 2. 空间复杂度

*   **哈希表 `mp`:** 需要存储 N 个条目。每个条目的键是 `int`，值是 `pair<string, int>`。`string` 的长度是 16。所以空间复杂度与 N 和字符串长度有关，主要是 O(N)。因为每个准考证号是固定长度的字符串，可以更精确地认为是 O(N * (sizeof(int) + sizeof(string_object) + 16 * sizeof(char) + sizeof(int)))，简化为 O(N)。
*   **其他变量:** `n`, `m`, `i`, `testSeat`, `examSeat`, `id`, `querySeat` 等占用 O(1) 空间。
*   **总体空间复杂度:** O(N)。

### 3. 优化空间

*   对于本题的约束和要求，当前解法在时间和空间复杂度上已接近最优，无需进一步优化。

## 八、常见错误

### 1. 代码错误

```cpp
// 错误代码示例 1: 使用 map 而不是 unordered_map
#include <map> // 错误地包含了 map
map<int, pair<string, int>> mp; // 使用了 map
// 错误原因: map 是基于红黑树实现的，插入和查找的时间复杂度是 O(log N)，
// 虽然也能通过此题，但不如 unordered_map 的 O(1) 高效。
// 修正方法: 使用 #include <unordered_map> 和 unordered_map<int, pair<string, int>> mp;

// 错误代码示例 2: pair 元素访问错误
cout << mp[querySeat].first << " " << mp[querySeat].first << endl; // 错误地输出了两次准考证号
// 错误原因: 访问 pair 的第二个元素应该用 .second。
// 修正方法: cout << mp[querySeat].first << " " << mp[querySeat].second << endl;

// 错误代码示例 3: 未包含必要的头文件
// #include <unordered_map> // 忘记包含
// 错误原因: 编译器会报错，找不到 unordered_map 的定义。
// 修正方法: 添加 #include <unordered_map> 和 #include <string>, #include <utility>。
```

### 2. 思路错误

*   **使用数组/Vector进行线性查找:** 虽然逻辑简单，但效率低下，时间复杂度为 O(N*M)，可能在 N 和 M 较大时超时。
*   **键值颠倒:** 错误地将准考证号作为键，试机座位号作为值的一部分。这不符合查询要求（根据试机号查信息）。
*   **未正确处理 `pair`:** 存储或访问 `pair` 的方式不正确。

### 3. 调试建议

*   **小规模测试:** 先用题目给的示例手动模拟一遍，再运行代码验证。
*   **边界测试:** 考虑 N=1, M=1 的情况；N=1000, M=1000 的情况。
*   **确认数据结构内容:** 如前所述，打印 `unordered_map` 的内容进行检查。

## 九、扩展思考

### 1. 题目变形

*   **查询考试座位号:** 如果题目要求根据“考试座位号”查询“试机座位号”和“准考证号”，怎么办？
    *   解法：需要再建立一个 `unordered_map<int, pair<string, int>> examSeatMap;`，以考试座位号为键。
*   **查询准考证号:** 如果要求根据“准考证号”查询“试机座位号”和“考试座位号”？
    *   解法：建立 `unordered_map<string, pair<int, int>> idMap;`，以准考证号（`string`）为键。
*   **数据量更大:** 如果 N 和 M 达到 10^6 或更高，需要更关注 `unordered_map` 的性能和可能的哈希冲突。

### 2. 面试相关

*   **为什么选择 `unordered_map`?** 因为需要根据键（试机座位号）进行快速查找，`unordered_map` 提供平均 O(1) 的查找效率。
*   **`unordered_map` vs `map`?** `unordered_map` 基于哈希表，平均 O(1) 查找，但元素无序；`map` 基于红黑树，O(log N) 查找，元素有序。在此题查找效率优先，且不需要有序性，故 `unordered_map` 更优。
*   **哈希冲突怎么办?** `unordered_map` 内部使用链地址法或开放地址法解决冲突。虽然最坏情况会影响性能，但通常表现良好。
*   **空间复杂度如何?** 主要由存储 N 个考生信息决定，为 O(N)。

### 3. 实战技巧

*   **STL 熟练度:** 熟练使用 `unordered_map`, `pair`, `string` 等常用 STL 组件是快速解题的关键。
*   **读题:** 准确理解输入输出格式和查询要求。
*   **数据结构选择:** 根据问题的核心需求（查找、排序、范围查询等）选择合适的数据结构。

## 十、相关题目

### 1. 类似题目

1.  **LeetCode 1. 两数之和:** [https://leetcode.cn/problems/two-sum/](https://leetcode.cn/problems/two-sum/) - 经典哈希表应用，查找目标值的补数是否存在。
2.  **PAT A1071 Speech Patterns:** ([https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805375444434944](https://pintia.cn/problem-sets/994805342720868352/exam/problems/994805375444434944)) - 使用 `map` 或 `unordered_map` 统计单词频率。
3.  **各种需要快速查找/映射的问题:** 很多题目都可以通过哈希表优化查找过程。

### 2. 推荐练习

*   **基础:** 多练习使用 `map` 和 `unordered_map` 解决查找、统计频率的问题。
*   **进阶:** 尝试解决需要组合使用多种数据结构（如哈希表+堆）的问题。
*   **综合:** LeetCode 或其他 OJ 平台上的哈希表标签下的题目。
