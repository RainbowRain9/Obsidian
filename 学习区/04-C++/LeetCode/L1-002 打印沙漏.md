# L1-002 打印沙漏（详细分析版）

## 一、前置知识
- 循环控制结构
- 数学计算（等差数列）
- 字符串和空格处理
- 图形打印规律

## 二、题目分析

### 1. 题目描述
- 题目链接：[L1-002 打印沙漏](https://pintia.cn/problem-sets/994805046380707840/exam/problems/994805145370476544)
- 本地链接：[L1-002 打印沙漏](../Algorithm/PTA/L1-002-打印沙漏.cpp)
- 难度：简单
- 考点：图形打印、数学计算

### 2. 题目要求
- 输入：正整数N(≤1000)和一个符号
- 输出：最大的沙漏图形和剩余符号数
- 关键点：使用尽可能多的符号

### 3. 关键概念
- 沙漏特征：
  - 每行符号数为奇数
  - 中心对齐
  - 相邻行差2个符号
  - 上下对称

## 三、数学分析

### 1. 符号数计算
```
设最大行符号数为a（必为奇数）
则各行符号数为：a, a-2, a-4, ..., 1, ..., a-4, a-2, a
```

### 2. 总符号数公式
```
上半部分（包括中间行）：1 + 3 + 5 + ... + a = ((a+1)/2)^2
总符号数：(上半部分 × 2) - 1 = 2 * ((a+1)/2)^2 - 1
```

### 3. 关键数列
```
a = 1: 需要1个符号
a = 3: 需要7个符号
a = 5: 需要17个符号
a = 7: 需要31个符号
规律：需要符号数 = 2 * ((a+1)/2)^2 - 1
```

## 四、代码实现

### 1. 核心代码
```cpp
// 计算最大可用符号数
int sum = 0; // 当前累计的行符号数
int x = 0;   // 当前使用的总符号数
int a = 1;   // 最大行的符号数，从1开始

// 循环计算最大可用符号数
while (true) {
    int next_sum = sum + a; // 下一行累计的符号数
    int next_x = 2 * next_sum * next_sum - 1; // 下一行后的总符号数
    
    // 如果下一行后的总符号数超过给定符号数，则跳出循环
    if (next_x > N) {
        break;
    }
    
    // 更新当前值
    sum = next_sum;
    x = next_x;
    a += 2; // 每行符号数增加2（奇数）
}

// 打印上半部分（包括中间行）
for (int i = a; i >= 1; i -= 2) {
    // 打印空格
    for (int j = 0; j < (a - i) / 2; j++) {
        cout << " ";
    }
    // 打印符号
    for (int j = 0; j < i; j++) {
        cout << c;
    }
    cout << endl;
}

// 打印下半部分（不包括中间行）
for (int i = 3; i <= a; i += 2) {
    // 打印空格
    for (int j = 0; j < (a - i) / 2; j++) {
        cout << " ";
    }
    // 打印符号
    for (int j = 0; j < i; j++) {
        cout << c;
    }
    cout << endl;
}

// 输出剩余符号数
cout << N - x << endl;
```

### 2. 关键变量说明
- sum：当前累计的行符号数
- x：当前使用的总符号数
- a：最大行的符号数
- next_sum：下一行累计的符号数
- next_x：下一行后的总符号数

## 五、算法分析

### 1. 核心算法
1. 计算最大可用符号数：
   - 逐行增加，直到超过给定符号数
   - 使用next_sum和next_x预判断
2. 打印图形：
   - 上半部分：从a递减到1
   - 下半部分：从3递增到a
3. 计算剩余符号

### 2. 时间复杂度
- O(sqrt(n))：计算最大可用符号数
- O(a^2)：打印图形
- 总体：O(sqrt(n))

### 3. 空间复杂度
- O(1)：只使用常数额外空间

## 六、代码执行模拟

### 1. 示例输入：19 *
```
步骤1：计算最大可用符号数
i=1: next_sum=1, next_x=1 < 19
i=3: next_sum=4, next_x=7 < 19
i=5: next_sum=9, next_x=17 < 19
i=7: next_sum=16, next_x=31 > 19, break
最终：a=5, x=17

步骤2：打印上半部分
i=5: *****
i=3:  ***
i=1:   *

步骤3：打印下半部分
i=3:  ***
i=5: *****

步骤4：输出剩余
19-17=2
```

### 2. 特殊情况处理
```
输入：3 *
计算过程：
i=1: next_x=1 < 3
i=3: next_x=7 > 3, break
结果：a=1, x=1
输出：
*
2
```

## 七、常见错误

### 1. 边界处理错误
```cpp
// 错误：没有处理a=1的特殊情况
for (int i = 3; i <= a; i += 2)

// 正确：添加条件判断
if (a > 1) {
    for (int i = 3; i <= a; i += 2)
}
```

### 2. 计算错误
```cpp
// 错误：直接使用当前值判断
if (x > n) break;

// 正确：使用下一步的值判断
if (next_x > n) break;
```

## 八、优化建议

### 1. 代码优化
- 使用函数封装打印逻辑
- 添加参数合法性检查
- 优化变量命名

### 2. 性能优化
- 可以使用数学公式直接计算
- 减少重复计算
- 优化空格打印

## 九、相关题目

### 1. 类似题目
- 打印菱形
- 打印三角形
- 字符图案打印

### 2. 进阶题目
- 复杂图形打印
- 动态图形生成
- 图形变换

## 十、总结

### 1. 关键点
- 正确计算最大可用符号数
- 处理特殊情况（a=1）
- 保持图形对称性

### 2. 技巧总结
- 使用next值预判断
- 分上下两部分处理
- 注意空格计算

### 3. 注意事项
- 边界条件处理
- 输出格式要求
- 代码可维护性
