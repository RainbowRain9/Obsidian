# L1-034 点赞

# PTA L1-034 点赞题解

## 一、前置知识
- 数组的基本操作
- 计数统计方法
- 最大值查找算法

## 二、题目分析

### 1. 题目描述
- 题目链接：[PTA L1-034 点赞](https://pintia.cn/problem-sets/994805342720868352/problems/994805401802440704)
- 本地链接：[L1-034-点赞.cpp](../Algorithm/PTA/L1-034-点赞.cpp)
- 难度级别：简单
- 相关标签：数组、计数统计

### 2. 题目要求
- 输入格式：
  1. 第一行一个整数N，表示点赞的博文数量
  2. 接下来N行，每行第一个数字M表示该博文包含的标签数量，后面跟着M个整数表示标签编号
- 输出要求：
  - 输出两个整数，分别是出现次数最多的标签编号和其出现次数
  - 如果多个标签出现次数相同，输出编号最大的标签
- 限制条件：
  - 标签编号范围：1-1000
  - 每篇博文标签数量：1-10
  - 点赞博文数量：≤1000

### 3. 关键概念
- 标签计数：统计每个标签出现的次数
- 最大值查找：找出出现次数最多的标签
- 相同次数处理：处理多个标签出现次数相同的情况

## 三、示例分析

### 1. 基本示例
```
输入：
4
3 889 233 2
5 100 3 233 2 73
4 3 73 889 2
2 233 123
输出：
233 3
解释：
- 标签233出现3次
- 标签2出现3次
- 标签889出现2次
- 其他标签出现1次
- 233和2都出现3次，233编号更大，所以输出233
```

### 2. 特殊情况
```
输入：
3
2 1 2
2 2 3
2 3 1
输出：
3 2
解释：
- 标签1、2、3都出现2次
- 3的编号最大，所以输出3
```

## 四、解题思路

### 1. 问题分析
- 需要统计每个标签的出现次数
- 需要在相同次数的标签中找出编号最大的
- 数据范围较小，可以使用数组直接统计

### 2. 算法设计
1. 使用数组记录每个标签出现的次数
2. 遍历所有博文的所有标签，进行计数
3. 遍历计数数组，找出出现次数最多且编号最大的标签

### 3. 解题步骤
1. 初始化计数数组
2. 读取并统计标签
3. 查找最大值和对应标签
4. 输出结果

## 五、代码实现

### 1. 完整代码
```cpp
#include <iostream>
#include <array>
#include <algorithm>
using namespace std;

int main() {
    // 读取博文数量
    int n;
    cin >> n;
    
    // 初始化计数数组
    array<int, 1001> cnt = {0};
    
    // 统计每个标签出现次数
    while (n--) {
        int m;
        cin >> m;
        while (m--) {
            int k;
            cin >> k;
            cnt[k]++;
        }
    }
    
    // 查找最大值和对应标签
    int max_tag = 0;
    int max_count = 0;
    for (int tag = 1; tag < 1001; tag++) {
        max_count = max(max_count, cnt[tag]);
        if (tag > max_tag && max_count == cnt[tag]) {
            max_tag = tag;
        }
    }
    
    // 输出结果
    cout << max_tag << " " << max_count << endl;
    
    return 0;
}
```

### 2. 关键代码段解析
```cpp
// 使用array而不是vector，因为大小固定且已知
array<int, 1001> cnt = {0};

// 更新最大值的同时更新标签
max_count = max(max_count, cnt[tag]);
if (tag > max_tag && max_count == cnt[tag]) {
    max_tag = tag;
}
```

## 六、模拟代码过程

### 1. 执行流程
以输入示例1为例：
```
输入：4
第一行：3 889 233 2
- cnt[889] = 1
- cnt[233] = 1
- cnt[2] = 1

第二行：5 100 3 233 2 73
- cnt[100] = 1
- cnt[3] = 1
- cnt[233] = 2
- cnt[2] = 2
- cnt[73] = 1

第三行：4 3 73 889 2
- cnt[3] = 2
- cnt[73] = 2
- cnt[889] = 2
- cnt[2] = 3

第四行：2 233 123
- cnt[233] = 3
- cnt[123] = 1

最终：
- max_count = 3
- max_tag = 233（因为233和2都出现3次，233编号更大）
```

### 2. 图示说明
```
标签计数过程：
2    -> ① -> ② -> ③
233  -> ① -> ② -> ③
889  -> ① -> ②
其他 -> ①
```

## 七、复杂度分析

### 1. 时间复杂度
- 统计标签：O(N*M)，其中N是博文数量，M是每篇博文的最大标签数
- 查找最大值：O(1000) = O(1)
- 总体：O(N*M)

### 2. 空间复杂度
- 计数数组：O(1000) = O(1)
- 总体：O(1)

## 八、常见错误

### 1. 代码错误
```cpp
// 错误写法：没有考虑相同次数时取最大编号
if (cnt[tag] > max_count) {
    max_count = cnt[tag];
    max_tag = tag;
}

// 正确写法：考虑相同次数时取最大编号
max_count = max(max_count, cnt[tag]);
if (tag > max_tag && max_count == cnt[tag]) {
    max_tag = tag;
}
```

### 2. 思路错误
- 使用动态数组存储所有标签再统计
- 没有考虑相同次数的情况
- 使用复杂的数据结构导致代码冗长

## 九、扩展思考

### 1. 题目变形
- 如果要输出所有出现次数最多的标签？
- 如果标签范围变大，如何优化？
- 如果要统计最少出现的标签？

### 2. 优化方向
- 使用哈希表处理更大范围的标签
- 使用堆维护出现次数最多的标签
- 使用位图优化内存使用

## 十、相关题目

### 1. 类似题目
1. 力扣 1365.有多少小于当前数字的数字
2. 力扣 347.前 K 个高频元素

### 2. 推荐练习
- 基础：统计数组中的元素
- 进阶：使用不同数据结构实现计数
- 提高：处理大规模数据的计数问题
