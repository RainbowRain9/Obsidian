# 713.乘积小于 K 的子数组

## 一、前置知识
- 数组基础知识
- 双指针技术
- 滑动窗口算法原理
- 连续子数组的性质及计数方法

## 二、题目分析

### 1. 题目描述
- 题目链接：[乘积小于 K 的子数组](https://leetcode.cn/problems/subarray-product-less-than-k/description/)
- 本地链接：[713-乘积小于 K 的子数组.cpp](<../Algorithm/LeetCode/All/713-subarray-product-less-than-k.cpp>)
- 难度级别：中等（Medium）
- 相关标签：数组、双指针、滑动窗口

### 2. 题目要求
- 输入格式和限制：
  - 一个整数数组 nums（1 ≤ nums.length ≤ 3 * 10^4，1 ≤ nums[i] ≤ 1000）
  - 一个整数 k（0 ≤ k ≤ 10^6）
- 输出要求：返回乘积严格小于 k 的连续子数组的数目
- 时间/空间限制：未明确指出，但需要高效解法

### 3. 关键概念
- **连续子数组**：原数组中连续的一段元素组成的数组
- **乘积严格小于 K**：子数组中所有元素的乘积必须严格小于给定值 k
- **元素全为正数**：题目给定的所有数组元素都是正整数，这确保了乘积的单调性

## 三、示例分析

### 1. 基本示例
```
输入：nums = [10,5,2,6], k = 100
输出：8
解释：8个乘积小于100的子数组分别为：
[10]       -> 10 < 100
[5]        -> 5 < 100
[2]        -> 2 < 100
[6]        -> 6 < 100
[10,5]     -> 10*5 = 50 < 100
[5,2]      -> 5*2 = 10 < 100
[2,6]      -> 2*6 = 12 < 100
[5,2,6]    -> 5*2*6 = 60 < 100
```

### 2. 特殊情况
```
输入：nums = [1,2,3], k = 0
输出：0
分析：由于所有数组元素都是正整数（>= 1），任何子数组的乘积至少为1，不可能小于0
```

### 3. 边界测试
```
输入：nums = [10], k = 9
输出：0
说明：单个元素10的乘积就已经超过k=9，所以没有满足条件的子数组

输入：nums = [1,1,1], k = 2
输出：6
说明：所有可能的子数组都满足条件：[1]×3 + [1,1]×2 + [1,1,1]×1 = 6
```

## 四、解题思路

### 1. 问题分析
- 这个问题要求我们找出所有乘积小于 k 的连续子数组的数量
- 暴力解法是枚举所有可能的子数组并计算乘积，时间复杂度为 O(n²)
- 观察到数组元素都是正整数，这意味着乘积具有单调性：子数组长度增加，乘积一定增加
- 这种单调性质使得我们可以应用滑动窗口（双指针）技术来优化解法

### 2. 算法设计
- 使用双指针维护一个滑动窗口，使窗口内所有元素的乘积小于 k
- 左指针 left 和右指针 right 分别表示窗口的左右边界
- 随着右指针向右移动，窗口可能需要从左侧收缩以保持乘积小于 k
- 对于每个右指针位置，计算以该位置结尾且满足条件的子数组数量

### 3. 解题步骤
1. 特殊情况处理：如果 k ≤ 1，由于所有元素都是正整数，不可能有乘积小于 k 的子数组
2. 初始化左指针 left = 0，累积乘积 product = 1，计数器 count = 0
3. 遍历数组，对于每个右指针 right：
   - 更新累积乘积：product *= nums[right]
   - 当累积乘积 >= k 时，不断移动左指针并更新累积乘积：product /= nums[left++]
   - 计算以当前右指针结尾的有效子数组数量：count += right - left + 1
4. 返回最终计数结果

## 五、代码实现

### 1. 完整代码
```cpp
/**
 * @brief 计算乘积小于K的子数组数量
 * @param nums 输入数组
 * @param k 乘积上限
 * @return 满足条件的子数组数量
 */
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        // 特殊情况处理：如果k <= 1，由于数组元素都是正整数（>= 1）
        // 不可能有乘积小于k的子数组
        if (k <= 1) return 0;
        
        int n = nums.size();
        int left = 0;      // 滑动窗口左边界
        int count = 0;     // 结果计数
        int product = 1;   // 当前窗口内元素乘积
        
        // 遍历数组，右指针不断向右扩展窗口
        for (int right = 0; right < n; right++) {
            // 将当前元素纳入累积乘积
            product *= nums[right];
            
            // 当累积乘积大于等于k时，不断收缩左边界
            while (product >= k && left <= right) {
                product /= nums[left];
                left++;
            }
            
            // 对于当前右边界，计算新增的有效子数组数量
            // 以right结尾的有效子数组数量等于窗口大小
            count += right - left + 1;
        }
        
        return count;
    }
};
```

### 2. 关键代码段解析
```cpp
// 收缩窗口直到乘积小于k
while (product >= k && left <= right) {
    product /= nums[left];
    left++;
}

// 对于当前右边界，计算新增的有效子数组数量
count += right - left + 1;
```
这是算法的核心部分：
- while循环确保窗口内的乘积始终小于k，通过不断移除左侧元素来收缩窗口
- 对于每个右边界位置，计算以该位置结尾的有效子数组数量
- 这个数量等于当前窗口大小(right-left+1)，因为对于窗口内的每个位置i，子数组[i...right]的乘积都小于k

### 3. 代码优化
```cpp
// 优化前
while (product >= k && left <= right) {
    product /= nums[left];
    left++;
}

// 优化后
while (product >= k) {
    product /= nums[left++];
}
```
优化说明：
- 简化了循环条件，因为如果product >= k且left > right，说明整个数组所有元素乘积都大于k
- 使用后置递增运算符简化代码，提高可读性

## 六、模拟代码过程

### 1. 执行流程
以输入 `nums = [10,5,2,6], k = 100` 为例：

初始化：left = 0, count = 0, product = 1

1. right = 0:
   - product *= nums[0] = 1 * 10 = 10 < 100
   - 无需收缩窗口
   - count += 0 - 0 + 1 = 1 (子数组: [10])

2. right = 1:
   - product *= nums[1] = 10 * 5 = 50 < 100
   - 无需收缩窗口
   - count += 1 - 0 + 1 = 2 (新增子数组: [5], [10,5])
   - 此时 count = 1 + 2 = 3

3. right = 2:
   - product *= nums[2] = 50 * 2 = 100 == 100
   - 需要收缩窗口：
     - product /= nums[0] = 100 / 10 = 10，left = 1
   - count += 2 - 1 + 1 = 2 (新增子数组: [2], [5,2])
   - 此时 count = 3 + 2 = 5

4. right = 3:
   - product *= nums[3] = 10 * 6 = 60 < 100
   - 无需收缩窗口
   - count += 3 - 1 + 1 = 3 (新增子数组: [6], [2,6], [5,2,6])
   - 最终 count = 5 + 3 = 8

最终结果：8个满足条件的子数组

### 2. 图示说明
```
数组: [10, 5, 2, 6], k = 100

步骤1 (right=0): 
窗口[10] -> product=10 -> 有效子数组:[10] -> count=1

步骤2 (right=1):
窗口[10,5] -> product=50 -> 有效子数组:[5],[10,5] -> count=3

步骤3 (right=2):
窗口变化: [10,5,2] -> product=100 >= k -> 收缩 -> [5,2] -> product=10
有效子数组: [2],[5,2] -> count=5

步骤4 (right=3):
窗口[5,2,6] -> product=60 -> 有效子数组:[6],[2,6],[5,2,6] -> count=8
```

### 3. 调试技巧
- 关键变量监控：
  - product: 当前窗口内元素乘积
  - left, right: 窗口边界
  - count: 累积结果

- 断点设置建议：
  - 窗口收缩前后
  - 计算子数组数量的位置

- 常见问题排查：
  - 检查特殊情况处理（k ≤ 1）
  - 确保窗口收缩逻辑正确
  - 验证子数组计数是否准确

## 七、复杂度分析

### 1. 时间复杂度
- 最好情况：O(n)，所有元素乘积都小于k，不需要收缩窗口
- 最坏情况：O(n)，虽然可能频繁收缩窗口，但每个元素最多被处理两次（进入和离开窗口各一次）
- 平均情况：O(n)，线性扫描数组一次

### 2. 空间复杂度
- 辅助空间：O(1)，只使用常数级额外空间
- 递归深度：无递归
- 总体空间：O(1)

### 3. 优化空间
- 时间优化方向：算法已经达到最优复杂度O(n)
- 空间优化方向：已经达到最优空间复杂度O(1)
- 权衡取舍：无需进一步优化

## 八、常见错误

### 1. 代码错误
```cpp
// 错误代码
while (left <= right) {
    if (product < k) {
        cnt++;
    }
    else {
        total /= nums[left];
        left++;
    }
}
```
错误原因：
- 这会导致无限循环，因为right位置固定时，如果条件满足，永远不会跳出循环
- 单个子数组计数不正确，应该计算窗口内的所有有效子数组数量

修正方法：
```cpp
// 正确代码
while (product >= k && left <= right) {
    product /= nums[left];
    left++;
}
count += right - left + 1;
```

### 2. 思路错误
- 常见误区：
  - 忽略特殊情况(k ≤ 1)
  - 错误理解窗口内有效子数组的计数方式
  - 混淆子序列和子数组的概念（子数组必须连续）

- 避免方法：
  - 仔细分析问题的边界条件和约束
  - 通过具体示例验证滑动窗口计数逻辑
  - 明确题目要求的是连续子数组

- 检查清单：
  - 窗口收缩条件是否正确
  - 子数组计数公式是否准确
  - 返回结果是否包含所有可能的子数组

### 3. 调试建议
- 测试用例设计：
  - 单元素数组：`[5], k = 10`
  - 所有元素乘积小于k：`[1,2,3], k = 10`
  - 所有元素乘积大于等于k：`[2,3,4], k = 5`
  - k值为边界：`[1,2,3], k = 1` 或 `k = 0`

- 边界情况验证：
  - k ≤ 1 的情况
  - 单元素数组
  - 所有元素都相同

- 性能分析方法：
  - 使用计数器统计窗口收缩次数
  - 分析不同输入规模下的运行时间

## 九、扩展思考

### 1. 题目变形
- 相似问题的解决方案：
  - "和小于K的子数组"：类似思路，计算元素和而非乘积
  - "乘积为K的子数组"：需要处理包含0的情况，可能需要哈希表辅助

- 不同约束下的解法：
  - 如果允许负数元素：乘积不再具有单调性，需要同时维护最大和最小乘积
  - 如果要求非连续子序列：需要使用动态规划而非滑动窗口

- 扩展应用场景：
  - 可应用于股票交易、数据流监控等需要维护连续窗口属性的场景

### 2. 面试相关
- 面试常见追问：
  - "如果数组包含负数元素，如何解决？"
  - "能否进一步优化算法的常数因子？"
  - "如何处理乘法可能导致的数值溢出问题？"

- 性能优化方向：
  - 使用位运算优化乘法操作（针对特定情况）
  - 预处理数组元素（例如移除所有等于1的元素）

- 代码改进建议：
  - 添加详细注释说明算法原理
  - 增加输入验证和边界检查
  - 使用更有描述性的变量名

### 3. 实战技巧
- 代码模板积累：
  ```cpp
  // 滑动窗口模板
  int slidingWindowTemplate(vector<int>& nums, int k) {
      int left = 0, result = 0;
      // 其他必要的状态变量
      
      for (int right = 0; right < nums.size(); right++) {
          // 扩展窗口，更新状态
          
          // 根据条件收缩窗口
          while (/* 需要收缩的条件 */) {
              // 更新状态
              left++;
          }
          
          // 计算结果
      }
      
      return result;
  }
  ```

- 解题套路总结：
  - 连续数组问题优先考虑滑动窗口
  - 涉及求和/乘积的子数组问题，注意元素的正负性对解法的影响
  - 滑动窗口计数时，注意窗口大小与有效子数组数量的关系

- 效率提升建议：
  - 快速识别问题类型
  - 熟练掌握滑动窗口模板
  - 通过多练习加深对不同计数逻辑的理解

## 十、相关题目

### 1. 类似题目
1. [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/) - 求和大于等于目标值的最小子数组长度
2. [560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/) - 求和等于K的子数组数量
3. [904. 水果成篮](https://leetcode.cn/problems/fruit-into-baskets/) - 最多包含两种元素的最长子数组
4. [992. K 个不同整数的子数组](https://leetcode.cn/problems/subarrays-with-k-different-integers/) - 恰好包含K个不同整数的子数组数量

### 2. 推荐练习
- 基础巩固题：
  - [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)
  - [643. 子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/)

- 提高进阶题：
  - [862. 和至少为 K 的最短子数组](https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/)
  - [1248. 统计「优美子数组」](https://leetcode.cn/problems/count-number-of-nice-subarrays/)

- 综合应用题：
  - [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)
  - [424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)

## 模板使用说明
1. 根据题目特点选择性使用相关章节
2. 保持格式统一,内容精炼
3. 注重实用性和可理解性
4. 适当添加图示和示例
5. 突出重点,标注难点
