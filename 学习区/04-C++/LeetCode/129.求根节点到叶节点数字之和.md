# 129.求根节点到叶节点数字之和

## 一、前置知识
- 二叉树的基本概念和结构
- 深度优先搜索(DFS)
- 递归算法
- 树的遍历方法

## 二、题目分析

### 1. 题目描述
- 题目链接：[求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/)
- 本地链接：[129-sum-root-to-leaf-numbers.cpp](../Algorithm/LeetCode/All/129-sum-root-to-leaf-numbers.cpp)
- 难度级别：中等
- 相关标签：树、深度优先搜索、二叉树

### 2. 题目要求
- 输入：二叉树的根节点root，每个节点包含0-9的数字
- 输出：所有从根节点到叶节点路径形成的数字之和
- 限制条件：
  - 树中节点数目在[1, 1000]范围内
  - 节点值在[0, 9]范围内
  - 树的深度不超过10

### 3. 关键概念
- 叶节点：没有子节点的节点
- 路径数字：从根到叶的路径上的数字依次组成的整数
- 路径和：所有路径数字的总和

## 三、示例分析

### 1. 基本示例
```
输入：root = [1,2,3]
输出：25
解释：
    1
   / \
  2   3
路径 1->2 形成数字12
路径 1->3 形成数字13
总和 = 12 + 13 = 25
```

### 2. 复杂示例
```
输入：root = [4,9,0,5,1]
输出：1026
解释：
     4
    / \
   9   0
  / \
 5   1
路径 4->9->5 形成数字495
路径 4->9->1 形成数字491
路径 4->0 形成数字40
总和 = 495 + 491 + 40 = 1026
```

## 四、解题思路

### 1. 问题分析
- 需要遍历所有从根到叶的路径
- 每经过一个节点，需要将当前数字乘10再加上节点值
- 到达叶节点时，将路径数字加入总和

### 2. 算法设计
- 使用DFS遍历二叉树
- 维护一个变量记录当前路径的数字
- 在叶节点处累加路径数字到结果中

### 3. 解题步骤
1. 处理空节点情况
2. 计算当前路径数字
3. 判断是否为叶节点
4. 递归处理左右子树

## 五、代码实现

### 1. 完整代码
```cpp
class Solution {
public:
    int sumNumbers(TreeNode* root, int x = 0) {
        // 处理空节点
        if (root == nullptr) {
            return 0;
        }
        
        // 计算当前路径数字
        x = x * 10 + root->val;
        
        // 如果是叶节点，返回当前数字
        if (root->left == root->right) {
            return x;
        }
        
        // 递归处理左右子树并返回和
        return sumNumbers(root->left, x) + 
               sumNumbers(root->right, x);
    }
};
```

### 2. 关键代码段解析
```cpp
x = x * 10 + root->val;
```
这行代码实现了路径数字的构建：
- x * 10：将已有数字左移一位
- + root->val：在最低位加入当前节点值

## 六、模拟代码过程

### 1. 执行流程
以示例[1,2,3]为例：
```
初始状态：x = 0
访问节点1：x = 0*10 + 1 = 1
访问节点2：x = 1*10 + 2 = 12 (叶节点，返回12)
访问节点3：x = 1*10 + 3 = 13 (叶节点，返回13)
最终结果：12 + 13 = 25
```

### 2. 图示说明
```
       1(x=1)
      /      \
   2(x=12)  3(x=13)
   返回12    返回13
   总和 = 12 + 13 = 25
```

## 七、复杂度分析

### 1. 时间复杂度
- O(N)，其中N是二叉树的节点数
- 每个节点只访问一次

### 2. 空间复杂度
- O(H)，其中H是树的高度
- 递归调用栈的深度等于树的高度

## 八、常见错误

### 1. 代码错误
```cpp
// 错误代码
if (!root->left && !root->right) {
    return x;
}
// 正确代码
if (root->left == root->right) {
    return x;
}
```
错误原因：两种写法虽然都能判断叶节点，但第二种更简洁。

### 2. 思路错误
- 忘记处理空节点情况
- 忘记在叶节点处返回路径数字
- 错误地累加非叶节点的值

## 九、扩展思考

### 1. 题目变形
- 如果节点值可以是负数？
- 如果要求最大/最小的路径数字？
- 如果要求所有路径数字都是偶数？

### 2. 相关题目
1. [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)
2. [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)
3. [437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

## 十、总结
1. 本题是典型的二叉树DFS应用
2. 关键是理解如何构建路径数字
3. 代码实现简洁但需要注意细节
4. 可以作为树形DP的入门练习
