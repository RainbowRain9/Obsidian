
好的，我们来详细讲解一下 LeetCode 377 题 "组合总和 Ⅳ"。

# 377. 组合总和 Ⅳ

## 一、前置知识

-   **动态规划 (Dynamic Programming):** 理解动态规划的基本思想，包括状态定义、状态转移方程、边界条件和最优子结构。
-   **C++ `vector`:** 熟悉 C++ 标准库中的 `vector` 容器的基本用法，包括初始化、访问元素和遍历。
-   **完全背包问题:** 对背包问题有一定了解，特别是完全背包（物品可以无限次使用）的模型会有助于理解本题。

## 二、题目分析

### 1. 题目描述

-   **题目链接:** [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/description/)
-   **本地链接:** [377. 组合总和 Ⅳ](../Algorithm/LeetCode/All/377-combination-sum-iv.cpp)
-   **难度级别:** 中等 (Medium)
-   **相关标签:** 数组、动态规划

### 2. 题目要求

-   **输入:** 一个由 **不同** 正整数组成的数组 `nums`，一个目标正整数 `target`。
-   **输出:** 从 `nums` 中找出和为 `target` 的元素 **组合** 的个数。
-   **重要说明:** 顺序不同的序列被视作 **不同** 的组合。例如 `(1, 1, 2)` 和 `(1, 2, 1)` 是不同的组合。
-   **限制:** 答案保证符合 32 位整数范围。`1 <= nums.length <= 200`, `1 <= nums[i] <= 1000`, `1 <= target <= 1000`。

### 3. 关键概念

-   **组合 vs 排列:** 虽然题目名为“组合总和”，但由于“顺序不同的序列被视作不同的组合”，这实际上是一个 **排列** 问题。我们需要计算的是能组成 `target` 的 **排列** 的数量。
-   **完全背包变种:** 每个数字可以使用无限次，类似于完全背包问题。但是，与标准的求组合数的背包问题不同，本题关心的是排列数。

## 三、示例分析

### 1. 基本示例

```
输入：nums = [1, 2, 3], target = 4
输出：7
解释：
所有可能的组合（排列）为：
(1, 1, 1, 1)  -> 1+1+1+1 = 4
(1, 1, 2)    -> 1+1+2 = 4
(1, 2, 1)    -> 1+2+1 = 4
(1, 3)       -> 1+3 = 4
(2, 1, 1)    -> 2+1+1 = 4
(2, 2)       -> 2+2 = 4
(3, 1)       -> 3+1 = 4
共有 7 种。
```

### 2. 特殊情况

```
输入：nums = [9], target = 3
输出：0
分析：nums 中最小的数是 9，无法组成比 9 小的目标值 3，所以组合（排列）数为 0。
```

### 3. 边界测试

```
输入：nums = [1], target = 1
输出：1
说明：只有一种方式 (1)。

输入：nums = [1], target = 2
输出：1
说明：只有一种方式 (1, 1)。
```

## 四、解题思路

### 1. 问题分析

-   **问题的本质:** 求解用 `nums` 中的数字组成 `target` 的所有不同排列的数量。
-   **动态规划适用性:** 题目要求计算总数，且问题具有最优子结构（组成 `target` 的排列数可以由组成更小值的排列数推导出来）和重叠子问题（计算过程中会多次遇到求解相同子问题的需求），适合使用动态规划。
-   **与组合问题的区别:** 如果是求组合数（不考虑顺序），我们通常先遍历物品再遍历背包容量。但本题要求排列数，需要改变遍历顺序。

### 2. 算法设计

-   **状态定义:** `dp[i]` 表示组成目标和为 `i` 的排列的总数。
-   **状态转移方程:**
    考虑 `dp[i]` 如何计算。要组成和为 `i`，最后一个数字可以是 `nums` 中的任意一个 `num` (只要 `i >= num`)。
    如果最后一个数字是 `num`，那么前面的数字组成的和就必须是 `i - num`。组成 `i - num` 的排列数是 `dp[i - num]`。
    因此，对于所有 `num` in `nums` 且 `i >= num`，`dp[i]` 应该是所有 `dp[i - num]` 的和。
    即：`dp[i] = sum(dp[i - num])` for `num` in `nums` if `i >= num`。
-   **初始化:** `dp[0] = 1`。表示组成目标和为 0 的排列只有一种，即什么都不选。这是递推的基础。
-   **遍历顺序:**
    因为要求的是排列数，不同的顺序算作不同的结果（例如 `(1, 2)` 和 `(2, 1)` 不同）。我们需要先遍历背包容量（目标和 `i` 从 1 到 `target`），再遍历物品（`num` in `nums`）。
    这样可以保证在计算 `dp[i]` 时，考虑的是以 `num` 结尾的所有排列。例如计算 `dp[4]` 时：
    -   遍历 `num = 1`: `dp[4] += dp[3]` (考虑以 1 结尾的排列)
    -   遍历 `num = 2`: `dp[4] += dp[2]` (考虑以 2 结尾的排列)
    -   遍历 `num = 3`: `dp[4] += dp[1]` (考虑以 3 结尾的排列)
    这种方式自然地包含了不同顺序的情况。

### 3. 解题步骤

1.  **初始化 DP 数组:** 创建一个大小为 `target + 1` 的 `dp` 数组（类型建议为 `unsigned int` 或 `long long` 以防止中间结果溢出，题目保证最终结果在 `int` 内），并将 `dp[0]` 初始化为 1，其余初始化为 0。
2.  **外层循环 (背包容量):** 遍历 `i` 从 1 到 `target`。
3.  **内层循环 (物品):** 遍历 `nums` 中的每一个数字 `num`。
4.  **状态转移:** 如果 `i >= num`，则执行 `dp[i] += dp[i - num]`。
5.  **返回结果:** 循环结束后，`dp[target]` 就是最终答案。

## 五、代码实现

### 1. 完整代码

```cpp
/*
 * @lc app=leetcode.cn id=377 lang=cpp
 * @lcpr version=30104
 *
 * [377] 组合总和 Ⅳ
 */

#include <vector> // 引入 vector 头文件
#include <numeric> // accumulate 等可能用到，但本题 dp 解法不需要

using namespace std;

// @lc code=start
class Solution {
public:
    /**
     * @brief 计算组成目标和 target 的排列总数
     * @param nums 可选的不同正整数数组
     * @param target 目标正整数
     * @return 组成 target 的排列总数
     */
    int combinationSum4(vector<int>& nums, int target) {
        // dp[i] 表示目标和为 i 的排列总数
        // 使用 unsigned int 防止中间计算结果溢出 int，题目保证最终结果在 int 范围内
        vector<unsigned int> dp(target + 1, 0);

        // 初始化：目标和为 0 的排列只有一种（什么都不选）
        dp[0] = 1;

        // 外层循环遍历背包容量（目标和）
        for (int i = 1; i <= target; ++i) {
            // 内层循环遍历物品（可选数字）
            for (int num : nums) {
                // 如果当前目标和 i 大于等于可选数字 num
                if (i >= num) {
                    // 状态转移：累加 dp[i - num]
                    // dp[i - num] 可能很大，所以 dp[i] 需要用 unsigned int
                    dp[i] += dp[i - num];
                }
            }
        }

        // 返回目标和为 target 的排列总数
        return dp[target];
    }
};
// @lc code=end

/* main 函数用于本地测试，非 LeetCode 提交部分
int main()
{
    Solution solution;
    vector<int> nums1 = {1, 2, 3};
    int target1 = 4;
    cout << "Example 1: " << solution.combinationSum4(nums1, target1) << endl; // Output: 7

    vector<int> nums2 = {9};
    int target2 = 3;
    cout << "Example 2: " << solution.combinationSum4(nums2, target2) << endl; // Output: 0
    return 0;
}
*/

```

### 2. 关键代码段解析

```cpp
// dp 数组定义与初始化
vector<unsigned int> dp(target + 1, 0); // 大小为 target + 1，初始值全为 0
dp[0] = 1; // 目标为 0 只有一种方法

// 核心状态转移循环
for (int i = 1; i <= target; ++i) { // 遍历目标和
    for (int num : nums) {         // 遍历可选数字
        if (i >= num) {
            // 核心转移方程
            dp[i] += dp[i - num];
        }
    }
}
```

-   `vector<unsigned int> dp(target + 1, 0);`: 使用 `unsigned int` 是为了防止计算 `dp[i] += dp[i - num]` 时发生整数溢出。虽然最终结果保证在 `int` 范围内，但中间过程可能超过 `int` 的最大值。
-   `dp[0] = 1;`: 这是动态规划的基础，表示构成和为 0 的方法只有一种（空集）。
-   **双层循环的顺序至关重要:** 先遍历背包容量 `i`，再遍历物品 `num`，确保了计算的是排列数。如果反过来，先遍历物品再遍历背包，得到的是组合数（如 LeetCode 518. 零钱兑换 II）。

### 3. 代码优化

当前解法已经是标准的动态规划解法，时间和空间复杂度都比较理想。对于本题的数据范围，通常不需要进一步优化。如果 `target` 非常大，可能需要考虑其他方法或优化空间复杂度（例如滚动数组，但本题不适用，因为 `dp[i]` 依赖于多个之前的状态）。

## 六、模拟代码过程

以 `nums = [1, 2, 3], target = 4` 为例：

### 1. 执行流程

1.  **初始化:** `dp` 数组大小为 5，`dp = [1, 0, 0, 0, 0]`
2.  **i = 1:**
    -   `num = 1`: `i >= 1`, `dp[1] += dp[1-1] = dp[0] = 1`. `dp = [1, 1, 0, 0, 0]`
    -   `num = 2`: `i < 2`, 跳过
    -   `num = 3`: `i < 3`, 跳过
3.  **i = 2:**
    -   `num = 1`: `i >= 1`, `dp[2] += dp[2-1] = dp[1] = 1`. `dp = [1, 1, 1, 0, 0]`
    -   `num = 2`: `i >= 2`, `dp[2] += dp[2-2] = dp[0] = 1`. `dp = [1, 1, 2, 0, 0]`
    -   `num = 3`: `i < 3`, 跳过
4.  **i = 3:**
    -   `num = 1`: `i >= 1`, `dp[3] += dp[3-1] = dp[2] = 2`. `dp = [1, 1, 2, 2, 0]`
    -   `num = 2`: `i >= 2`, `dp[3] += dp[3-2] = dp[1] = 1`. `dp = [1, 1, 2, 3, 0]`
    -   `num = 3`: `i >= 3`, `dp[3] += dp[3-3] = dp[0] = 1`. `dp = [1, 1, 2, 4, 0]`
5.  **i = 4:**
    -   `num = 1`: `i >= 1`, `dp[4] += dp[4-1] = dp[3] = 4`. `dp = [1, 1, 2, 4, 4]`
    -   `num = 2`: `i >= 2`, `dp[4] += dp[4-2] = dp[2] = 2`. `dp = [1, 1, 2, 4, 6]`
    -   `num = 3`: `i >= 3`, `dp[4] += dp[4-3] = dp[1] = 1`. `dp = [1, 1, 2, 4, 7]`
6.  **循环结束。** 返回 `dp[4] = 7`。

### 2. 图示说明（DP 表格填充过程）

| i   | dp[i] (初始) | num=1              | num=2              | num=3              | dp[i] (最终) | 解释                                          |
| --- | ------------ | ------------------ | ------------------ | ------------------ | ------------ | --------------------------------------------- |
| 0   | 1            | -                  | -                  | -                  | 1            | Base Case                                     |
| 1   | 0            | `dp[1]+=dp[0]=1`   | -                  | -                  | 1            | (1)                                           |
| 2   | 0            | `dp[2]+=dp[1]=1`   | `dp[2]+=dp[0]=1+1` | -                  | 2            | (1,1), (2)                                    |
| 3   | 0            | `dp[3]+=dp[2]=2`   | `dp[3]+=dp[1]=2+1` | `dp[3]+=dp[0]=3+1` | 4            | (1,1,1), (1,2), (2,1), (3)                    |
| 4   | 0            | `dp[4]+=dp[3]=4`   | `dp[4]+=dp[2]=4+2` | `dp[4]+=dp[1]=6+1` | 7            | (1,1,1,1), (1,1,2), (1,2,1), (2,1,1), (2,2), (1,3), (3,1) |

### 3. 调试技巧

-   **打印 DP 数组:** 在循环中或循环后打印 `dp` 数组的值，可以帮助理解状态转移的过程。
-   **检查边界:** 确保 `i >= num` 的判断正确，避免数组越界。
-   **数据类型:** 注意 `dp` 数组使用 `unsigned int` 或 `long long` 防止溢出。
-   **小规模测试:** 用简单的 `nums` 和 `target` 手动模拟计算过程，与代码运行结果对比。

## 七、复杂度分析

### 1. 时间复杂度

-   外层循环从 1 遍历到 `target`，复杂度为 O(target)。
-   内层循环遍历 `nums` 数组，复杂度为 O(N)，其中 N 是 `nums` 的长度。
-   总时间复杂度为 O(target * N)。

### 2. 空间复杂度

-   需要一个大小为 `target + 1` 的 `dp` 数组。
-   空间复杂度为 O(target)。

### 3. 优化空间

-   时间复杂度 O(target * N) 对于本题的数据范围 (target <= 1000, N <= 200) 是可以通过的。
-   空间复杂度 O(target) 也是可以接受的。没有明显的优化空间且必要性不大。

## 八、常见错误

### 1. 代码错误

```cpp
// 错误示例：使用 int 可能导致溢出
vector<int> dp(target + 1, 0);
// ...
dp[i] += dp[i - num]; // 如果 dp[i-num] 很大，这里可能溢出

// 错误示例：循环顺序错误（会导致计算组合数而非排列数）
for (int num : nums) {
    for (int i = num; i <= target; ++i) { // 错误：这是计算组合数的顺序
        dp[i] += dp[i - num];
    }
}
```

-   **错误原因:** 未考虑中间结果溢出；混淆了排列和组合的 DP 计算顺序。
-   **修正方法:** 使用 `unsigned int` 或 `long long`；确保循环顺序是先背包容量后物品。

### 2. 思路错误

-   **误解题意:** 将问题当作纯粹的组合问题（不考虑顺序），使用了计算组合数的 DP 方法。
-   **边界条件错误:** `dp[0]` 初始化不正确或未初始化。
-   **状态转移错误:** 状态转移方程写错，例如漏加或重复计算。

### 3. 调试建议

-   **明确 DP 定义:** 始终清晰地知道 `dp[i]` 代表什么（是排列数还是组合数？）。
-   **手动模拟:** 用小例子验证状态转移方程和循环顺序的正确性。
-   **对比相关题目:** 与 LeetCode 518 (零钱兑换 II，组合数) 对比，理解循环顺序的影响。

## 九、扩展思考

### 1. 题目变形

-   **如果 `nums` 中包含 0:** 如果允许使用 0，且 `target > 0`，可能会有无限种组合（例如 `target=1`, `nums=[0, 1]`，可以是 `(1)`, `(0, 1)`, `(0, 0, 1)`...）。需要根据具体要求调整（例如限制 0 的使用次数或不允许使用 0）。本题明确说明 `nums` 中是正整数。
-   **如果 `nums` 中包含负数 (进阶问题):**
    -   **问题:** 如果存在负数，可能会出现无限循环的组合。例如 `nums = [1, -1]`, `target = 1`。可以有 `(1)`, `(1, 1, -1)`, `(1, -1, 1)`, `(1, 1, -1, 1, -1)`... 无限种。
    -   **变化:** DP 可能不再适用，或者需要额外的约束。
    -   **限制条件:** 为了使问题有意义，需要添加限制，例如：
        1.  限制每个数字的使用次数（变成多重背包或 0/1 背包问题）。
        2.  限制路径长度（组合中元素的个数）。
        3.  保证不会出现和为 0 的循环子集（例如，不允许同时存在 `x` 和 `-x`）。

### 2. 面试相关

-   **核心考察点:** 动态规划思想，特别是区分排列和组合问题的 DP 实现差异。
-   **常见追问:**
    -   解释 DP 状态的含义。
    -   解释为什么需要当前的循环顺序。
    -   如果改成求组合数，代码如何修改？（交换内外循环）
    -   时间/空间复杂度分析。
    -   如何处理溢出问题？
    -   讨论包含负数的情况。

### 3. 实战技巧

-   **模板化:** 将完全背包求排列数和组合数的 DP 模板记清楚。
    -   排列数：外层背包容量，内层物品。
    -   组合数：外层物品，内层背包容量。
-   **数据类型敏感:** 对于计数类 DP 问题，要特别注意潜在的整数溢出。

## 十、相关题目

### 1. 类似题目

1.  [LeetCode 518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/) - 完全背包求 **组合** 数，与本题的主要区别在于不考虑顺序（循环顺序相反）。
2.  [LeetCode 39. 组合总和](https://leetcode.cn/problems/combination-sum/) - 求 **组合**，但要求返回所有具体组合而非数量，通常用回溯法。
3.  [LeetCode 40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/) - 求 **组合**，`nums` 中有重复数且每个数只能用一次，回溯法 + 去重。
4.  [LeetCode 216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/) - 求 **组合**，使用 1-9 数字，限制个数 k，回溯法。
5.  [LeetCode 322. 零钱兑换](https://leetcode.cn/problems/coin-change/) - 完全背包求凑成目标金额所需的最少硬币数（求最优值而非计数）。

### 2. 推荐练习

-   **基础巩固:** LeetCode 70. 爬楼梯 (简单的 DP 计数)
-   **背包基础:** LeetCode 416. 分割等和子集 (0/1 背包判断可行性), LeetCode 494. 目标和 (0/1 背包计数)
-   **提高进阶:** 上述“类似题目”中的背包问题和组合问题。
