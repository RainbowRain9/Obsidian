# 31.下一个排列

## 一、前置知识
- 排列组合基础
- 字典序算法
- 数组操作
- 双指针技巧

## 二、题目分析

### 1. 题目描述
- 题目链接：[下一个排列](https://leetcode.cn/problems/next-permutation/description/)
- 本地链接：[31-next-permutation.cpp](../Algorithm/LeetCode/All/31-next-permutation.cpp)
- 难度级别：Medium
- 相关标签：数组、双指针

### 2. 题目要求
- 输入：整数数组nums
- 输出：将数组修改为下一个字典序更大的排列
- 限制条件：
  - 必须原地修改
  - 只允许使用常数额外空间
  - 1 <= nums.length <= 100
  - 0 <= nums[i] <= 100

### 3. 关键概念
- 排列：数组元素的一种排列顺序
- 字典序：排列的大小关系
- 下一个排列：字典序中的下一个更大排列
- 原地修改：不使用额外数组空间

## 三、示例分析

### 1. 基本示例
```
输入：nums = [1,2,3]
输出：[1,3,2]
解释：
[1,2,3]的所有排列按字典序排序为：[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]
所以[1,2,3]的下一个排列是[1,3,2]
```

### 2. 特殊情况
```
输入：nums = [3,2,1]
输出：[1,2,3]
分析：当数组降序排列时，已经是最大字典序，返回最小字典序
```

### 3. 边界测试
```
输入：nums = [1,1,5]
输出：[1,5,1]
说明：处理重复元素的情况
```

## 四、解题思路

### 1. 问题分析
- 本质是找到一个比当前序列大的最小序列
- 如果不存在这样的序列，则返回最小序列
- 需要考虑重复元素的情况

### 2. 算法设计
1. 从右向左找第一个相邻升序对(i,i+1)，满足nums[i] < nums[i+1]
2. 如果找不到，说明序列降序，直接翻转整个序列
3. 找到升序对后，从右向左找第一个大于nums[i]的数
4. 交换这两个数
5. 将i+1后的序列翻转

### 3. 解题步骤
1. 寻找交换位置
   - 从后向前找第一个升序对
   - 记录较小数的位置i
2. 寻找交换数字
   - 从后向前找第一个大于nums[i]的数
   - 记录位置j
3. 交换并重排
   - 交换i和j位置的数字
   - 将i+1到末尾的序列翻转

## 五、代码实现

### 1. 完整代码
```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int i = nums.size() - 2;
        // 1. 从右向左找第一个升序对
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        
        // 2. 如果找到升序对
        if (i >= 0) {
            int j = nums.size() - 1;
            // 从右向左找第一个大于nums[i]的数
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            // 交换这两个数
            swap(nums[i], nums[j]);
        }
        
        // 3. 将i+1后的序列翻转
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```

### 2. 关键代码段解析
```cpp
// 寻找升序对
while (i >= 0 && nums[i] >= nums[i + 1]) {
    i--;
}
```
- 从右向左扫描，找到第一个不满足降序的位置
- 这个位置就是需要改变的起始位置

```cpp
// 寻找交换位置
while (j >= 0 && nums[j] <= nums[i]) {
    j--;
}
swap(nums[i], nums[j]);
```
- 找到第一个大于nums[i]的数
- 交换这两个数，保证增加的幅度最小

### 3. 代码优化
```cpp
// 使用STL
void nextPermutation(vector<int>& nums) {
    ranges::next_permutation(nums);
}
```
- 使用C++内置的next_permutation函数
- 代码更简洁，但面试时最好展示手动实现

## 六、模拟代码过程

### 1. 执行流程
以nums = [1,2,3]为例：
```
初始状态：[1,2,3]
1. 找到升序对：i=1 (2<3)
2. 找到交换数：j=2 (3>2)
3. 交换2和3：[1,3,2]
4. i+1后序列已经是降序，无需翻转
最终结果：[1,3,2]
```

### 2. 图示说明
```
[1,2,3] -> 找到2<3
[1,2,3] -> 交换2和3
[1,3,2] -> 完成
```

### 3. 调试技巧
- 重点关注i和j的边界条件
- 注意处理完全降序的情况
- 验证翻转操作的正确性

## 七、复杂度分析

### 1. 时间复杂度
- 最好情况：O(1)，直接找到升序对
- 最坏情况：O(n)，需要扫描整个数组
- 平均情况：O(n)

### 2. 空间复杂度
- 辅助空间：O(1)，只使用常数额外空间
- 递归深度：O(1)，没有递归
- 总体空间：O(1)

### 3. 优化空间
- 时间优化：已经是最优解
- 空间优化：已经达到最小空间要求
- 代码优化：可以使用STL简化实现

## 八、常见错误

### 1. 代码错误
```cpp
// 错误：忘记处理降序序列
if (i >= 0) {
    // 处理找到升序对的情况
} 
// 漏掉了else情况，需要翻转整个序列
```

### 2. 思路错误
- 没有考虑完全降序的情况
- 交换数字时没有选择最小的可能值
- 忘记翻转后续序列

### 3. 调试建议
- 使用降序序列测试边界情况
- 验证重复元素的处理
- 检查翻转操作的正确性

## 九、扩展思考

### 1. 题目变形
- 求上一个排列
- 求第k个排列
- 处理重复元素的全排列

### 2. 面试相关
- 手写next_permutation实现
- 优化空间复杂度
- 处理大数据情况

### 3. 实战技巧
- 掌握双指针技巧
- 理解字典序算法
- 熟练数组操作

## 十、相关题目

### 1. 类似题目
1. [46. 全排列](https://leetcode.cn/problems/permutations/) - 生成所有排列
2. [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/) - 包含重复数字的排列

### 2. 推荐练习
- [60. 排列序列](https://leetcode.cn/problems/permutation-sequence/)
- [556. 下一个更大元素 III](https://leetcode.cn/problems/next-greater-element-iii/)
- [1053. 交换一次的先前排列](https://leetcode.cn/problems/previous-permutation-with-one-swap/)
