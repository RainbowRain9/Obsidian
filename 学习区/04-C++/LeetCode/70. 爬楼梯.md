# 70. 爬楼梯

## 一、前置知识

-   **动态规划 (Dynamic Programming):**
    -   理解动态规划的基本思想：将大问题分解为小问题，并存储子问题的解以避免重复计算。
    -   掌握状态定义、状态转移方程和边界条件的处理。
-   **C++ `std::vector`:**
    -   了解 `vector` 的基本用法，包括声明、初始化、访问元素和获取大小。
-   **斐波那契数列 (Fibonacci Sequence):**
    -   了解斐波那契数列的定义 \(F(n) = F(n-1) + F(n-2)\)，以及其与本题的关系。

## 二、题目分析

### 1. 题目描述

-   **题目链接：** [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)
-   **本地链接：** [70. 爬楼梯](../Algorithm/LeetCode/All/70-climbing-stairs.cpp)
-   **难度级别：** 简单 (Easy)
-   **相关标签：** 记忆化搜索, 数学, 动态规划

### 2. 题目要求

-   **输入：** 一个正整数 `n`，表示楼梯的总阶数。
-   **输出：** 一个整数，表示爬到楼顶的不同方法总数。
-   **限制：**
    -   每次只能爬 1 阶或 2 阶。
    -   `1 <= n <= 45`

### 3. 关键概念

-   **方法总数：** 需要计算所有可能的爬楼梯路径数量。
-   **每次 1 或 2 阶：** 这是到达上一阶的唯一方式，构成了递推关系的基础。
-   **到达第 n 阶：** 我们的目标是计算到达第 `n` 阶的方法数。

## 三、示例分析

### 1. 基本示例 1

```
输入：n = 2
输出：2
图解：
  方法1: 1 -> 1
  方法2: 2
解释：
  1. 爬 1 阶，再爬 1 阶。
  2. 直接爬 2 阶。
  共有 2 种不同的方法。
```

### 2. 基本示例 2

```
输入：n = 3
输出：3
图解：
  方法1: 1 -> 1 -> 1
  方法2: 1 -> 2
  方法3: 2 -> 1
解释：
  1. 爬 1 阶，再爬 1 阶，再爬 1 阶。
  2. 爬 1 阶，再爬 2 阶。
  3. 爬 2 阶，再爬 1 阶。
  共有 3 种不同的方法。
```

### 3. 边界测试

```
输入：n = 1
输出：1
说明：只有一种方法：爬 1 阶。
```

## 四、解题思路

### 1. 问题分析

-   **问题的本质：** 这是一个典型的计数问题，可以看作求解满足特定约束条件的路径数量。
-   **与斐波那契数列的关系：** 仔细观察示例可以发现，到达第 `n` 阶的方法数等于到达第 `n-1` 阶的方法数（最后一步爬 1 阶）加上到达第 `n-2` 阶的方法数（最后一步爬 2 阶）。这恰好是斐波那契数列的递推关系。
-   **可能的解决方案：**
    -   **递归:** 直接根据递推关系写递归，但会产生大量重复计算，效率低下（时间复杂度指数级）。
    -   **递归 + 记忆化搜索:** 在递归基础上增加缓存，存储已计算过的子问题结果，避免重复计算。
    -   **动态规划:** 使用迭代的方式，从底向上计算每个子问题的解，并存储起来供后续使用。

### 2. 算法设计

-   **核心算法选择：** 动态规划 (DP)。这是解决此类具有重叠子问题和最优子结构问题的经典方法。
-   **状态定义：** `dp[i]` 表示爬到第 `i` 阶楼梯的不同方法总数。
-   **状态转移方程：** 要到达第 `i` 阶，可以从第 `i-1` 阶爬 1 阶上来，也可以从第 `i-2` 阶爬 2 阶上来。因此，`dp[i] = dp[i-1] + dp[i-2]`。
-   **边界条件（初始化）：**
    -   `dp[0]`：虽然题目说 `n >= 1`，但为了方便计算 `dp[2]`，我们定义 `dp[0] = 1`（表示到达第0阶有1种方法，即原地不动）。或者也可以将 `dp[1]` 和 `dp[2]` 作为初始条件。
    -   `dp[1] = 1`：爬到第 1 阶只有一种方法（爬 1 阶）。
    -   `dp[2] = 2`：爬到第 2 阶有两种方法（1+1 或 2）。
    -   代码中采用 `dp[0]=1`, `dp[1]=1` 作为初始化，然后从 `i=2` 开始递推。

### 3. 解题步骤

1.  **初始化 DP 数组:** 创建一个大小为 `n+1` 的 `vector<int> dp`，并将所有元素初始化为 0。
2.  **设置边界条件:** 设置 `dp[0] = 1` 和 `dp[1] = 1`。
3.  **迭代计算:** 使用循环从 `i = 2` 到 `n`，根据状态转移方程 `dp[i] = dp[i-1] + dp[i-2]` 计算每个 `dp[i]` 的值。
4.  **返回结果:** 返回 `dp[n]`，即爬到第 `n` 阶的方法总数。

## 五、代码实现

### 1. 完整代码

```cpp
/*
 * @Author: RainbowRain9
 * @Date: 2025-04-11 11:33:17
 * @LastEditTime: 2025-04-11 11:33:24
 * @FilePath: \C++\Algorithm\LeetCode\All\70-climbing-stairs.cpp
 * @Description: LeetCode 70. Climbing Stairs Solution using Dynamic Programming
 */
#include <vector> // 引入 vector 头文件
#include <iostream> // 引入 iostream 用于测试 (可选)

using namespace std; // 使用标准命名空间

// @lc code=start
class Solution {
public:
    /**
     * @brief 计算爬到 n 阶楼梯的不同方法总数
     * @param n 楼梯的总阶数
     * @return int 不同方法总数
     */
    int climbStairs(int n) {
        // 如果 n <= 1，可以直接返回 n (或 1，因为 dp[0]=1, dp[1]=1)
        // 但下面的 DP 初始化已包含此情况
        if (n <= 0) return 0; // 处理无效输入
        if (n == 1) return 1; // n=1 时只有一种方法

        // 1. 初始化 DP 数组
        // dp[i] 表示爬到第 i 阶的方法数
        // 大小为 n+1，因为我们需要索引从 0 到 n
        vector<int> dp(n + 1, 0);

        // 2. 设置边界条件
        // 爬到第 0 阶有 1 种方法 (方便计算 dp[2])
        dp[0] = 1;
        // 爬到第 1 阶有 1 种方法 (爬 1 阶)
        dp[1] = 1;

        // 3. 迭代计算
        // 从第 2 阶开始，计算到第 n 阶
        for (int i = 2; i <= n; i++) {
            // 状态转移方程：到达第 i 阶的方法 = 到达第 i-1 阶的方法 + 到达第 i-2 阶的方法
            dp[i] = dp[i - 1] + dp[i - 2];
        }

        // 4. 返回结果
        // 返回爬到第 n 阶的方法总数
        return dp[n];
    }
};
// @lc code=end

// 测试代码 (可选)
int main() {
    Solution solution;
    cout << "n = 2, ways = " << solution.climbStairs(2) << endl; // 输出 2
    cout << "n = 3, ways = " << solution.climbStairs(3) << endl; // 输出 3
    cout << "n = 1, ways = " << solution.climbStairs(1) << endl; // 输出 1
    cout << "n = 4, ways = " << solution.climbStairs(4) << endl; // 输出 5
    return 0;
}
```

### 2. 关键代码段解析

```cpp
// 状态定义：dp[i] 表示爬到第 i 阶的方法数
vector<int> dp(n + 1, 0);

// 边界条件/初始化
dp[0] = 1; // 到达第0阶1种方法
dp[1] = 1; // 到达第1阶1种方法 (爬1阶)

// 迭代计算
for (int i = 2; i <= n; i++) {
    // 状态转移方程
    // 到达第 i 阶的方法数等于
    // 从第 i-1 阶爬 1 步上来的方法数 (dp[i-1])
    // 加上从第 i-2 阶爬 2 步上来的方法数 (dp[i-2])
    dp[i] = dp[i - 1] + dp[i - 2];
}

// 返回最终结果
return dp[n];
```

### 3. 代码优化 (空间优化)

观察状态转移方程 `dp[i] = dp[i-1] + dp[i-2]`，我们发现计算 `dp[i]` 只需要知道前两个状态 `dp[i-1]` 和 `dp[i-2]` 的值。因此，没有必要存储整个 `dp` 数组，可以用两个变量来滚动记录前两个状态的值，将空间复杂度从 O(n) 优化到 O(1)。

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 0) return 0;
        if (n == 1) return 1;

        // 使用两个变量滚动记录前两个状态
        int prev1 = 1; // 相当于 dp[i-1]
        int prev2 = 1; // 相当于 dp[i-2]
        int current = 0; // 相当于 dp[i]

        // 从第 2 阶开始计算
        for (int i = 2; i <= n; i++) {
            // 计算当前阶的方法数
            current = prev1 + prev2;
            // 更新前两个状态的值，为下一次迭代做准备
            prev2 = prev1;
            prev1 = current;
        }
        // 循环结束后，prev1 (或 current) 存储的就是 dp[n] 的值
        return prev1; // 或者 return current; 因为循环最后一次 prev1 = current
    }
};
```

## 六、模拟代码过程

以 `n = 3` 为例，模拟未优化版本的 DP 过程：

### 1. 执行流程

1.  **输入数据准备:** `n = 3`
2.  **初始化 DP 数组:** `dp = {0, 0, 0, 0}` (大小为 n+1 = 4)
3.  **设置边界条件:** `dp[0] = 1`, `dp[1] = 1`。此时 `dp = {1, 1, 0, 0}`。
4.  **开始循环 (i = 2):**
    -   `dp[2] = dp[1] + dp[0] = 1 + 1 = 2`。
    -   此时 `dp = {1, 1, 2, 0}`。
5.  **继续循环 (i = 3):**
    -   `dp[3] = dp[2] + dp[1] = 2 + 1 = 3`。
    -   此时 `dp = {1, 1, 2, 3}`。
6.  **循环结束 (i > n)。**
7.  **返回结果:** `dp[n] = dp[3] = 3`。

### 2. 图示说明

```mermaid
graph LR
    Start --> Init_DP[初始化 dp = {0,0,0,0}]
    Init_DP --> Set_Base[设置边界 dp[0]=1, dp[1]=1\ndp = {1,1,0,0}]
    Set_Base --> Loop_i2[i=2: dp[2]=dp[1]+dp[0]=2\ndp = {1,1,2,0}]
    Loop_i2 --> Loop_i3[i=3: dp[3]=dp[2]+dp[1]=3\ndp = {1,1,2,3}]
    Loop_i3 --> End[循环结束]
    End --> Return[返回 dp[3] = 3]
```

### 3. 调试技巧

-   **打印中间状态:** 在循环内部打印 `i` 和 `dp[i]` 的值，观察状态转移是否正确。
    ```cpp
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
        // cout << "i = " << i << ", dp[i] = " << dp[i] << endl; // 添加打印语句
    }
    ```
-   **检查边界条件:** 确保 `dp[0]` 和 `dp[1]` 的初始化符合预期。对于空间优化版本，检查 `prev1` 和 `prev2` 的初始值。
-   **单步调试:** 使用调试器逐行执行代码，观察变量值的变化。

## 七、复杂度分析

### 1. 时间复杂度

-   **未优化版本:** 需要一个循环从 2 遍历到 n，循环体内是常数时间操作。因此时间复杂度为 O(n)。
-   **空间优化版本:** 同样需要一个循环从 2 遍历到 n。时间复杂度仍为 O(n)。
-   **最好/最坏/平均情况:** 都是 O(n)。

### 2. 空间复杂度

-   **未优化版本:** 使用了一个大小为 `n+1` 的 DP 数组。因此空间复杂度为 O(n)。
-   **空间优化版本:** 只使用了常数个额外变量 (`prev1`, `prev2`, `current`)。因此空间复杂度为 O(1)。
-   **递归深度:** 如果使用未优化的递归，递归深度可能达到 n，导致栈溢出。

### 3. 优化空间

-   **时间优化:** 对于此问题，O(n) 已经是相当优的时间复杂度。如果 n 非常大，可以使用矩阵快速幂将时间复杂度降至 O(log n)，但这超出了本题 `n <= 45` 的范围。
-   **空间优化:** 如上所述，可以将空间复杂度从 O(n) 优化到 O(1)。

## 八、常见错误

### 1. 代码错误

```cpp
// 错误代码 1: DP 数组大小错误
vector<int> dp(n); // 应该是 n+1，否则访问 dp[n] 会越界

// 错误代码 2: 边界条件设置错误
dp[0] = 0; // 如果 dp[0] 设为 0, dp[2] 会计算错误
dp[1] = 1;

// 错误代码 3: 循环范围错误
for (int i = 2; i < n; i++) { // 应该是 <= n，否则计算不到 dp[n]
    dp[i] = dp[i - 1] + dp[i - 2];
}
```

### 2. 思路错误

-   **直接使用递归未加记忆化:** 对于 `n=45`，会导致大量重复计算，超出时间限制。
-   **混淆状态定义:** 错误地理解 `dp[i]` 的含义。
-   **忽略边界情况:** 未正确处理 `n=1` 或 `n=2` 的情况（尽管通用 DP 可以处理）。

### 3. 调试建议

-   **从小规模输入开始测试:** 先用 `n=1`, `n=2`, `n=3` 等简单例子验证代码逻辑。
-   **对比数学推导:** 计算出的 `dp` 值应与斐波那契数列一致（稍微错位）。
-   **注意整数溢出:** 虽然本题 `n <= 45` 结果在 `int` 范围内，但对于更大的 `n`，需要使用 `long long`。

## 九、扩展思考

### 1. 题目变形

-   **每次可以爬 1, 2, ..., k 阶:** 状态转移方程变为 `dp[i] = dp[i-1] + dp[i-2] + ... + dp[i-k]`。
-   **某些阶梯不能踩:** 在 DP 计算中跳过这些阶梯，即 `dp[forbidden_step] = 0`。
-   **带权重的阶梯 (不同步数代价不同):** 可能需要更复杂的 DP 状态定义。

### 2. 面试相关

-   **解释 DP 思路:** 清晰地阐述状态定义、转移方程和边界条件。
-   **空间优化:** 主动提出并实现 O(1) 空间复杂度的优化。
-   **时间复杂度分析:** 准确给出时间复杂度 O(n)。
-   **对比递归:** 说明纯递归的低效性以及记忆化搜索的改进。

### 3. 实战技巧

-   **识别 DP 模式:** 很多计数问题、最值问题可以尝试用 DP 解决。
-   **自底向上 vs 自顶向下:** 理解迭代 DP (自底向上) 和记忆化搜索 (自顶向下) 的优劣。
-   **滚动数组优化:** 熟练掌握空间优化技巧。

## 十、相关题目

### 1. 类似题目

1.  [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/) - 直接计算斐波那契数，是本题的基础。
2.  [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/) - DP 应用，但目标是最小花费而非方法数。
3.  [198. 打家劫舍](https://leetcode.cn/problems/house-robber/) - 经典的 DP 问题，状态转移略有不同。

### 2. 推荐练习

-   **基础巩固题:** LeetCode 509 (斐波那契数)
-   **提高进阶题:** LeetCode 746 (最小花费爬楼梯), LeetCode 62 (不同路径)
-   **综合应用题:** LeetCode 198 (打家劫舍), LeetCode 322 (零钱兑换)
