# 1. 迷宫问题 (DFS)

## 一、前置知识

*   **深度优先搜索 (DFS)**：一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点 v 的所在边都已被探寻过，搜索将回溯到发现节点 v 的那条边的起始节点。
*   **递归**：函数调用自身的过程。DFS 通常使用递归实现。
*   **二维数组/向量 (vector<vector<T>>)**：用于表示迷宫网格。
*   **C++ 基本输入输出 (cin, cout)**：用于读取迷宫布局和输出结果。
*   **布尔数组/向量**：用于标记单元格是否在当前路径探索中被访问过，以检测循环。

## 二、题目分析

### 1. 题目描述

*   在一个 10x10 的网格迷宫中，每个单元格包含一个字符（'U', 'D', 'L', 'R'），指示从该单元格出发的唯一移动方向。
*   玩家从某个单元格开始，必须严格按照单元格上的字符指示移动。
*   如果玩家的移动路径超出了 10x10 的边界，则认为该玩家成功走出了迷宫。
*   需要计算从所有 100 个单元格出发，有多少个起始位置最终能让玩家走出迷宫。

### 2. 题目链接与信息

*   题目链接：这是一个典型的迷宫/图遍历问题，常见于在线编程平台（如蓝桥杯、LeetCode 等），但未提供具体链接。
*   本地链接：`Algorithm/Lanqiao/DFS-迷宫.cpp`
*   难度级别：中等
*   相关标签：DFS, 递归, 图遍历, 迷宫

### 3. 题目要求

*   输入：一个 10x10 的字符矩阵，表示迷宫布局。
*   输出：一个整数，表示能够成功走出迷宫的起始单元格数量。
*   时间/空间限制：虽然未明确给出，但 N=10 的规模通常要求算法复杂度在 O(N^4) 或更优。

### 4. 关键概念

*   **确定性路径**：每个单元格只有一个固定的移动方向。
*   **边界退出**：走出迷宫的唯一方式是移动到网格边界之外。
*   **循环路径**：玩家可能陷入一个循环，永远无法到达边界。需要检测这种情况。
*   **独立起点**：每个单元格都是一个独立的起点，需要分别判断。

## 三、示例分析

以一个简化的 3x3 迷宫为例：

```
RRD
DLL
RUU
```

*   从 (0, 0) 出发: (0,0)R -> (0,1)R -> (0,2)D -> (1,2)L -> (1,1)L -> (1,0)D -> (2,0)R -> (2,1)U -> (1,1) ... 进入循环 (1,1) -> (1,0) -> (2,0) -> (2,1) -> (1,1)，无法走出。
*   从 (0, 2) 出发: (0,2)D -> (1,2)L -> (1,1)L -> (1,0)D -> (2,0)R -> (2,1)U -> (1,1) ... 同上，进入循环。
*   从 (2, 2) 出发: (2,2)U -> (1,2)L -> (1,1)L -> (1,0)D -> (2,0)R -> (2,1)U -> (1,1) ... 同上，进入循环。
*   从 (0, 1) 出发: (0,1)R -> (0,2)D -> ... 进入循环。
*   从 (2, 0) 出发: (2,0)R -> (2,1)U -> (1,1)L -> (1,0)D -> (2,0) ... 进入循环。

假设有一个格子是 'U' 并且它位于第 0 行，例如 (0, 5) 是 'U'。那么从 (0, 5) 出发，下一步是 (-1, 5)，超出了上边界，所以从 (0, 5) 出发可以走出迷宫。

**核心**：需要对每个格子作为起点进行模拟，看最终是走出边界还是陷入循环。

## 四、解题思路

### 1. 问题分析

*   本质是从图中的每个节点出发，沿着固定路径判断是否能到达边界（图外）。
*   图中可能存在环。
*   需要遍历所有可能的起始点。

### 2. 算法设计

*   **深度优先搜索 (DFS)** 是自然的选择，可以模拟玩家的移动路径。
*   **访问标记 (visited)**：为了检测循环，我们需要记录在 *当前* DFS 探索路径中已经访问过的格子。**关键点**：对于每个新的起始点，都需要重置 `visited` 状态，因为不同的起始路径可能会经过相同的格子，但一个可能是死循环，另一个可能通向出口。
*   **递归函数 `dfs(x, y)`**：
    *   接收当前坐标 `(x, y)`。
    *   返回 `true` 如果能走出迷宫，`false` 如果不能（例如陷入循环）。

### 3. 解题步骤

1.  初始化能走出迷宫的玩家数量 `count = 0`。
2.  读取 10x10 的迷宫 `grid`。
3.  使用一个二维布尔向量 `visited[N][N]` 来记录访问状态。
4.  **外层循环**：遍历所有可能的起始点 `(i, j)` (从 0 到 N-1)。
5.  **内层重置**：对于每个起始点 `(i, j)`，在调用 DFS 之前，必须将 `visited` 数组所有元素重置为 `false`。这确保了每次 DFS 都是一次独立的路径探索。
6.  **调用 DFS**：调用 `dfs(i, j)`。
7.  **计数**：如果 `dfs(i, j)` 返回 `true`，则 `count++`。
8.  **输出**：循环结束后，输出 `count`。

**`dfs(x, y)` 函数逻辑:**

1.  **边界检查 (出口)**：如果 `x` 或 `y` 超出边界 ( `x < 0 || x >= N || y < 0 || y >= N` )，说明成功走出迷宫，返回 `true`。
2.  **循环检查**：如果 `visited[x][y]` 为 `true`，说明在当前路径中再次访问到该格子，形成了循环，无法走出，返回 `false`。
3.  **标记访问**：设置 `visited[x][y] = true`。
4.  **计算下一步**：根据 `grid[x][y]` 的字符确定下一个坐标 `(nx, ny)`。
    *   'U': `nx = x - 1, ny = y`
    *   'D': `nx = x + 1, ny = y`
    *   'L': `nx = x, ny = y - 1`
    *   'R': `nx = x, ny = y + 1`
5.  **递归调用**：返回 `dfs(nx, ny)` 的结果。

## 五、代码实现

### 1. 完整代码

```cpp
/**
 * @file DFS-迷宫.cpp
 * @brief 使用DFS解决X星球迷宫问题，统计能走出迷宫的玩家数量。
 */
#include <bits/stdc++.h> // 包含常用的头文件
#include <vector>

using namespace std;

const int N = 10;      // 迷宫大小
char grid[N][N];       // 存储迷宫布局
vector<vector<bool>> visited; // 访问标记数组，用于检测单次DFS中的循环

/**
 * @brief 深度优先搜索函数，判断从(x, y)出发是否能走出迷宫
 * @param x 当前行坐标
 * @param y 当前列坐标
 * @return true 如果能走出迷宫, false 如果不能（陷入循环或已在之前的路径中访问过）
 */
bool dfs(int x, int y)
{
    // 1. 边界检查 (出口): 如果坐标超出边界，说明成功走出
    if (x < 0 || x >= N || y < 0 || y >= N) {
        return true;
    }

    // 2. 循环检查: 如果当前格子在本次DFS中已被访问，说明陷入循环
    if (visited[x][y]) {
        return false;
    }

    // 3. 标记访问: 标记当前格子为已访问
    visited[x][y] = true;

    // 4. 计算下一步坐标
    int next_x = x, next_y = y;
    switch (grid[x][y]) {
    case 'U': // 向上移动
        next_x = x - 1;
        break;
    case 'D': // 向下移动
        next_x = x + 1;
        break;
    case 'L': // 向左移动
        next_y = y - 1;
        break;
    case 'R': // 向右移动
        next_y = y + 1;
        break;
    }

    // 5. 递归调用: 返回从下一步开始探索的结果
    return dfs(next_x, next_y);
}

int main()
{
    // 优化输入输出速度 (可选)
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    // 初始化 visited 数组，大小为 N x N，初始值全为 false
    visited.resize(N, vector<bool>(N, false));

    // 读入迷宫布局
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            cin >> grid[i][j];
        }
    }

    int successful_exits = 0; // 统计能走出迷宫的玩家数量

    // 遍历所有可能的起始点
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            // !!关键点: 为每个新的起始点重置visited数组!!
            // 可以创建一个临时的 visited 数组，或者每次重置全局的
            for (int row = 0; row < N; ++row) {
                fill(visited[row].begin(), visited[row].end(), false);
            }
            // 或者: visited.assign(N, vector<bool>(N, false));

            // 从当前起始点(i, j)开始DFS
            if (dfs(i, j)) {
                successful_exits++; // 如果能走出，计数器加1
            }
        }
    }

    // 输出结果
    cout << successful_exits << endl;

    return 0;
}
```

### 2. 关键代码段解析

*   **`dfs` 函数**：
    *   `if (x < 0 || x >= N || y < 0 || y >= N)`: 这是递归的终止条件之一，代表成功。
    *   `if (visited[x][y])`: 这是另一个终止条件，代表失败（循环）。
    *   `visited[x][y] = true;`: 标记当前节点，防止在 *同一条* 路径中重复访问导致死循环。
    *   `switch (grid[x][y])`: 根据指令确定下一步方向。
    *   `return dfs(next_x, next_y);`: 递归调用，将当前状态传递给下一步。

*   **`main` 函数中的循环和 `visited` 重置**：
    ```cpp
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            // 为每个起点 (i, j) 重置 visited 状态
            for (int row = 0; row < N; ++row) {
                fill(visited[row].begin(), visited[row].end(), false);
            }
            // 或 visited.assign(N, vector<bool>(N, false));

            if (dfs(i, j)) { // 对每个起点进行独立DFS
                successful_exits++;
            }
        }
    }
    ```
    这是整个算法的核心逻辑：保证每次从 `(i, j)` 出发的探索都是全新的，不受之前探索路径的影响。

### 3. 代码优化

*   **输入输出优化**：`ios_base::sync_with_stdio(false); cin.tie(NULL);` 可以加速 C++ 的 `cin` 和 `cout`，对于大量输入输出的题目有帮助。
*   **Visited 重置**：代码中使用了 `fill` 函数逐行重置 `visited`。另一种方式是 `visited.assign(N, vector<bool>(N, false));`，效果类似。对于 N=10 的规模，两者效率差异不大。
*   **全局 `visited` vs 局部**：虽然这里使用了全局 `visited` 并在每次 `main` 循环中重置，也可以在 `main` 循环内创建一个局部的 `visited` 数组传递给 `dfs` 函数，效果相同。
*   **记忆化搜索 (Memoization)**：对于本题，因为路径是固定的，如果能检测到多个起始点汇入同一个已知结果（能出去/死循环）的路径，可以进行优化。但这会增加实现的复杂度。当前 N=10 的规模下，O(N^4) 是可以接受的。

## 六、模拟代码过程

假设迷宫一小部分如下，且 N=3：

```
(0,0)R  (0,1)D  (0,2)L
(1,0)D  (1,1)U  (1,2)U
(2,0)R  (2,1)L  (2,2)X <- (假设X会出界)
```

模拟从 `(0, 0)` 出发：

1.  `main`: `i=0, j=0`. 重置 `visited` (全 false)。调用 `dfs(0, 0)`.
2.  `dfs(0, 0)`:
    *   边界检查：否。
    *   `visited[0][0]`? 否。
    *   `visited[0][0] = true`.
    *   `grid[0][0]` is 'R'. `next_x=0, next_y=1`.
    *   调用 `dfs(0, 1)`.
3.  `dfs(0, 1)`:
    *   边界检查：否。
    *   `visited[0][1]`? 否。
    *   `visited[0][1] = true`.
    *   `grid[0][1]` is 'D'. `next_x=1, next_y=1`.
    *   调用 `dfs(1, 1)`.
4.  `dfs(1, 1)`:
    *   边界检查：否。
    *   `visited[1][1]`? 否。
    *   `visited[1][1] = true`.
    *   `grid[1][1]` is 'U'. `next_x=0, next_y=1`.
    *   调用 `dfs(0, 1)`.
5.  `dfs(0, 1)`:
    *   边界检查：否。
    *   `visited[0][1]`? 是 (`true`)。 **检测到循环！**
    *   返回 `false`.
6.  `dfs(1, 1)` 收到 `false`，返回 `false`.
7.  `dfs(0, 1)` 收到 `false`，返回 `false`.
8.  `dfs(0, 0)` 收到 `false`，返回 `false`.
9.  `main`: `dfs(0, 0)` 返回 `false`，`successful_exits` 不变。

模拟从 `(1, 2)` 出发：

1.  `main`: `i=1, j=2`. 重置 `visited` (全 false)。调用 `dfs(1, 2)`.
2.  `dfs(1, 2)`:
    *   边界检查：否。
    *   `visited[1][2]`? 否。
    *   `visited[1][2] = true`.
    *   `grid[1][2]` is 'U'. `next_x=0, next_y=2`.
    *   调用 `dfs(0, 2)`.
3.  `dfs(0, 2)`:
    *   ... (假设经过一系列移动到达) ...
    *   调用 `dfs(2, 2)`
4.  `dfs(2, 2)`:
    *   ...
    *   `grid[2][2]` is 'X' (假设指令是 'D'，导致下一步 x=3)
    *   调用 `dfs(3, 2)`
5.  `dfs(3, 2)`:
    *   边界检查：`x=3 >= N=3`? 是。**成功走出！**
    *   返回 `true`.
6.  `dfs(2, 2)` 收到 `true`，返回 `true`.
7.  ... 递归调用链一路返回 `true` ...
8.  `dfs(1, 2)` 收到 `true`，返回 `true`.
9.  `main`: `dfs(1, 2)` 返回 `true`，`successful_exits++`.

## 七、复杂度分析

### 1. 时间复杂度

*   对于每个起始点 `(i, j)`，DFS 最多访问 N*N 个格子（因为有 `visited` 标记防止在单次 DFS 中重复访问同一个格子形成无限循环）。
*   总共有 N*N 个起始点。
*   每次启动 DFS 前需要重置 `visited` 数组，这需要 O(N*N) 时间。
*   总时间复杂度 = 起始点数量 * (重置 visited + 单次 DFS 访问量) = O(N*N * (N*N + N*N)) = **O(N^4)**。
*   对于 N=10，N^4 = 10000。总操作次数约为 100 * (100 + 100) = 20000，远小于典型的 10^8 操作限制，因此该复杂度是可接受的。

### 2. 空间复杂度

*   `grid[N][N]`：存储迷宫，O(N^2)。
*   `visited[N][N]`：存储访问标记，O(N^2)。
*   **递归栈深度**：在最坏的情况下，路径可能非常长，理论上可能达到 O(N^2)，例如一条蛇形路径覆盖所有格子。
*   总体空间复杂度主要由存储空间和递归栈深度决定，为 **O(N^2)**。

### 3. 优化空间

*   **时间**：对于更大的 N，O(N^4) 可能过高。可以考虑记忆化搜索：如果从格子 A 开始的 DFS 计算出结果（能出去/死循环），并且后续从格子 B 开始的 DFS 路径到达了格子 A，可以直接复用 A 的结果，避免重复计算。这需要额外的数据结构来存储每个格子的最终状态。
*   **空间**：空间复杂度主要是 O(N^2)，优化空间不大，除非 N 极大需要考虑其他方法。

## 八、常见错误

### 1. 代码错误

*   **忘记重置 `visited`**：这是最常见的错误。如果不为每个起点重置 `visited`，一个起点导致的循环会错误地阻止其他可能通过该点的出口路径。
    ```cpp
    // 错误示例：没有在循环内重置 visited
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            // 缺少 visited 重置!
            if (dfs(i, j)) {
                count++;
            }
        }
    }
    ```
*   **边界条件错误**：`x < 0 || x >= N || y < 0 || y >= N` 确保正确判断出界。
*   **坐标更新错误**：'U' 对应 `x-1`，'D' 对应 `x+1`，'L' 对应 `y-1`，'R' 对应 `y+1`，写反会导致逻辑错误。
*   **`visited` 数组初始化**：确保 `visited` 数组在程序开始时或使用 `resize`/`assign` 正确初始化为 N x N 的 `false`。

### 2. 思路错误

*   **对 `visited` 的理解偏差**：认为 `visited` 应该全局共享并且不清零。必须理解 `visited` 在这里的目的是检测 *当前探索路径* 是否进入循环，而不是记录整个图的访问历史。
*   **错误处理循环**：仅仅检查 `visited` 状态就足够了，不需要其他复杂的循环检测机制。

### 3. 调试建议

*   **打印路径**：在 `dfs` 函数内部打印当前的 `(x, y)` 坐标，可以帮助追踪路径。
*   **检查 `visited` 状态**：在 `main` 循环开始和 `dfs` 函数内部关键位置打印 `visited` 数组的部分内容，确认它是否按预期被设置和重置。
*   **小规模测试**：手动构造一个 3x3 或 4x4 的迷宫，包含出口和循环，手动推演结果，然后用代码验证。
*   **边界测试**：确保起始点在边界附近（可能第一步就出去）或直接陷入简单循环的情况能正确处理。

## 九、扩展思考

### 1. 题目变形

*   **寻找最短路径**：如果目标不是判断能否出去，而是找到出去的最短步数，应该使用广度优先搜索 (BFS)。
*   **多方向选择**：如果每个格子允许多个移动方向（例如，一个列表），问题就变成标准的图搜索。
*   **带权重的路径**：如果移动有成本，可能需要 Dijkstra 或类似算法。
*   **动态迷宫**：如果迷宫结构会变化，需要更复杂的处理。

### 2. 面试相关

*   面试官可能会问：
    *   为什么需要重置 `visited` 数组？
    *   时间复杂度和空间复杂度是多少？如何分析？
    *   如果 N 很大（比如 1000x1000），O(N^4) 不可行，如何优化？（提示：记忆化搜索）
    *   如果改成找最短路径，你会用什么算法？（BFS）
    *   代码中 `switch` 部分可以如何简化或替代？（例如，用 `dx`, `dy` 数组）

### 3. 实战技巧

*   掌握 DFS 的递归模板。
*   理解 `visited` 数组在不同场景下的作用（全局防重 vs. 路径防环）。
*   对于网格问题，熟练使用 `dx = {-1, 1, 0, 0}`, `dy = {0, 0, -1, 1}` 来简化方向处理（虽然本题方向固定，不需要这个）。

## 十、相关题目

### 1. 类似题目

*   **LeetCode 200. 岛屿数量 (Number of Islands)**：经典的 DFS/BFS 网格遍历。
*   **LeetCode 695. 岛屿的最大面积 (Max Area of Island)**：在岛屿数量基础上增加计算。
*   **LeetCode 542. 01 矩阵 (01 Matrix)**：典型的 BFS 应用，计算距离。
*   **LeetCode 130. 被围绕的区域 (Surrounded Regions)**：DFS/BFS 从边界开始遍历。

### 2. 推荐练习

*   多做 LeetCode 或其他平台的迷宫、图遍历相关题目，熟悉 DFS 和 BFS 的应用。
*   尝试实现带记忆化搜索的版本。
*   尝试用 BFS 解决判断是否能走出的问题（需要处理循环）。
