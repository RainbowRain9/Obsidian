# ! round舍入函数

## 一、`round` 函数概述

### 1. 功能与用途

`round` 函数的主要功能是将一个浮点数（如 `float`, `double`, `long double`）**四舍五入**到最接近的整数值。

"四舍五入" 在这里的具体含义是：
*   如果小数部分大于等于 0.5，则向上（远离 0 的方向）舍入到下一个整数。
*   如果小数部分小于 0.5，则向下（朝向 0 的方向）舍入到当前整数。
*   对于负数，规则类似，但方向相反（例如 -2.3 向下舍入到 -2，-2.7 向上舍入到 -3，-2.5 向上舍入到 -3）。

**关键点：对于恰好在两个整数中间的数值（小数部分为 0.5），`round` 函数采用“四舍五入到远离零”的策略 (round half away from zero)。**

### 2. 头文件

要使用 `round` 函数，需要包含 C++ 的数学库头文件 `<cmath>`。

```cpp
#include <cmath>
```

### 3. 函数原型 (签名)

`round` 函数针对不同的浮点类型有多个重载版本：

```cpp
double round( double arg );
float roundf( float arg );       // C++11 起，或者在 C 中使用 roundf
long double roundl( long double arg ); // C++11 起，或者在 C 中使用 roundl

// C++11 起还提供了基于模板的重载
double round( float arg );
double round( long double arg );
// 以及针对整数类型的重载（它们直接返回参数本身）
double round( IntegralType arg ); // IntegralType 可以是 int, long, etc.
```

*   最常用的是 `double round(double arg)` 版本。
*   输入参数 `arg` 是需要进行四舍五入的浮点数。
*   返回值是四舍五入后的结果，类型与输入参数对应的浮点类型相同（或 `double` 对于模板版本）。虽然结果是整数值，但返回类型仍然是浮点类型。

## 二、舍入规则详解与示例

`round` 遵循 "round half away from zero"（距离中点时向绝对值更大的方向舍入）的规则。

| 输入 (arg) | 小数部分 | 比较  | 舍入方向          | 输出 (round(arg)) |
| :--------- | :------- | :---- | :---------------- | :---------------- |
| 3.14       | 0.14     | < 0.5 | 向下 (朝 0)       | 3.0               |
| 3.75       | 0.75     | > 0.5 | 向上 (远离 0)     | 4.0               |
| **3.5**    | **0.5**  | = 0.5 | **向上 (远离 0)** | **4.0**           |
| 4.0        | 0.0      | -     | 不变              | 4.0               |
| -3.14      | -0.14    | < 0.5 | 向下 (朝 0)       | -3.0              |
| -3.75      | -0.75    | > 0.5 | 向上 (远离 0)     | -4.0              |
| **-3.5**   | **-0.5** | = 0.5 | **向上 (远离 0)** | **-4.0**          |
| -4.0       | 0.0      | -     | 不变              | -4.0              |
| 0.4        | 0.4      | < 0.5 | 向下 (朝 0)       | 0.0               |
| 0.5        | 0.5      | = 0.5 | 向上 (远离 0)     | 1.0               |
| -0.4       | -0.4     | < 0.5 | 向下 (朝 0)       | -0.0 (即 0.0)     |
| -0.5       | -0.5     | = 0.5 | 向上 (远离 0)     | -1.0              |

**注意**: "向上" 和 "向下" 是相对于数值本身而言，更准确的描述是 "朝向正无穷" 和 "朝向负无穷"，或者 "远离零" 和 "朝向零"。对于 `round` 处理 `.5` 的情况，是 "远离零"。

## 三、与其他舍入函数的比较

`<cmath>` 库还提供了其他相关的舍入函数，它们有不同的行为：

*   **`floor(x)`**: 向下取整。返回不大于 `x` 的最大整数值。 (floor: 地板)
    *   `floor(3.7) == 3.0`
    *   `floor(3.1) == 3.0`
    *   `floor(-3.1) == -4.0`
    *   `floor(-3.7) == -4.0`
    *   `floor(3.0) == 3.0`
*   **`ceil(x)`**: 向上取整。返回不小于 `x` 的最小整数值。 (ceil: 天花板)
    *   `ceil(3.7) == 4.0`
    *   `ceil(3.1) == 4.0`
    *   `ceil(-3.1) == -3.0`
    *   `ceil(-3.7) == -3.0`
    *   `ceil(3.0) == 3.0`
*   **`trunc(x)`**: 向零取整 (截断)。移除小数部分，返回整数部分。 (truncate: 截断)
    *   `trunc(3.7) == 3.0`
    *   `trunc(3.1) == 3.0`
    *   `trunc(-3.1) == -3.0`
    *   `trunc(-3.7) == -3.0`
    *   `trunc(3.0) == 3.0`
*   **`rint(x)`** / **`nearbyint(x)`**: 舍入到最近的整数，但对于 `.5` 的情况，通常采用 "round half to even"（舍入到最近的偶数）策略（具体行为可能受当前浮点环境的舍入模式影响）。`nearbyint` 在舍入时不会引发 "inexact" 浮点异常。
    *   `rint(3.5) == 4.0` (4 是偶数)
    *   `rint(4.5) == 4.0` (4 是偶数)
    *   `rint(-3.5) == -4.0` (-4 是偶数)
    *   `rint(-4.5) == -4.0` (-4 是偶数)
*   **`lround(x)`** / **`llround(x)`**: 功能与 `round` 类似（也是 round half away from zero），但返回值是 `long` 或 `long long` 整数类型，而不是浮点类型。这在需要直接得到整数结果时更方便，且可能性能稍好。
    *   `lround(3.7) == 4L`
    *   `lround(-3.7) == -4L`
    *   `lround(3.5) == 4L`
    *   `lround(-3.5) == -4L`

**总结 `round` 与其他函数的关键区别**：
*   与 `floor`, `ceil`, `trunc` 不同：`round` 是基于 "最接近" 原则，而不是固定的方向。
*   与 `rint` 不同：`round` 处理 `.5` 时总是远离零，而 `rint` 通常朝向偶数。
*   与 `lround`, `llround` 不同：`round` 返回浮点类型，后两者返回整数类型。

## 四、示例代码

```cpp
#include <iostream>
#include <cmath>
#include <iomanip> // For std::fixed and std::setprecision

int main() {
    double vals[] = {3.14, 3.75, 3.5, 4.0, -3.14, -3.75, -3.5, -4.0, 0.4, 0.5, -0.4, -0.5};

    std::cout << std::fixed << std::setprecision(2); // 设置输出格式

    std::cout << "Value\tround()\tfloor()\tceil()\ttrunc()\trint()\tlround()" << std::endl;
    std::cout << "-----\t-------\t-------\t------\t-------\t------\t--------" << std::endl;

    for (double val : vals) {
        std::cout << val << "\t"
                  << std::round(val) << "\t"
                  << std::floor(val) << "\t"
                  << std::ceil(val) << "\t"
                  << std::trunc(val) << "\t"
                  << std::rint(val) << "\t"
                  << std::lround(val) << std::endl;
    }

    return 0;
}
```

**预期输出:**

```
Value   round() floor() ceil()  trunc() rint()  lround()
-----   ------- ------- ------  ------- ------  --------
3.14    3.00    3.00    4.00    3.00    3.00    3
3.75    4.00    3.00    4.00    3.00    4.00    4
3.50    4.00    3.00    4.00    3.00    4.00    4
4.00    4.00    4.00    4.00    4.00    4.00    4
-3.14   -3.00   -4.00   -3.00   -3.00   -3.00   -3
-3.75   -4.00   -4.00   -3.00   -3.00   -4.00   -4
-3.50   -4.00   -4.00   -3.00   -3.00   -4.00   -4
-4.00   -4.00   -4.00   -4.00   -4.00   -4.00   -4
0.40    0.00    0.00    1.00    0.00    0.00    0
0.50    1.00    0.00    1.00    0.00    0.00    1
-0.40   -0.00   -1.00   -0.00   -0.00   -0.00   0
-0.50   -1.00   -1.00   -0.00   -0.00   -0.00   -1
```
*(注意：`rint(0.5)` 和 `rint(-0.5)` 的输出为 0.00，是因为它们舍入到最近的偶数 0。)*

## 五、注意事项与潜在问题

*   **浮点数精度**: 计算机中的浮点数表示可能存在微小的误差。一个你认为是 `3.5` 的数，在内存中可能是 `3.4999999999999996` 或 `3.5000000000000004`。这可能导致 `round` 的结果与预期不符。例如，`round(3.4999999999999996)` 结果是 `3.0`，而 `round(3.5000000000000004)` 结果是 `4.0`。在进行涉及浮点数比较或依赖精确舍入的计算时要特别小心。
*   **返回值类型**: 记住 `round` 返回的是浮点类型 (`double`, `float`, `long double`)。如果需要整数结果，要么使用 `lround`/`llround`，要么对 `round` 的结果进行显式类型转换（如 `static_cast<int>(round(x))`），但要注意转换可能带来的截断或溢出问题。
*   **不同语言/库的差异**: 其他编程语言或数学库可能有不同的 `round` 实现，特别是对于 `.5` 的处理（例如 Python 3 的 `round` 默认是 round half to even）。在跨语言或库工作时要注意这一点。

希望这个详细讲解能帮助你理解 C++ 中的 `round` 函数！
