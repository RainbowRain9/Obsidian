# 密码脱落

## 一、前置知识

*   **动态规划 (Dynamic Programming, DP)**：理解 DP 的基本思想，包括状态定义、状态转移方程、边界条件和最优子结构。
*   **最长公共子序列 (Longest Common Subsequence, LCS)**：了解 LCS 问题的定义以及如何使用 DP 求解。
*   **字符串操作**：熟悉 C++ `string` 的基本操作，特别是字符串反转 (`reverse`)。
*   **回文串**：理解回文串（正读反读都一样的字符串）的概念。

## 二、题目分析

### 1. 题目描述

*   **题目链接**：(这通常是蓝桥杯的题目，可能没有公开的 LeetCode 链接，但可以搜索 "蓝桥杯 密码脱落")
*   **本地链接**：[密码脱落](../Algorithm/Lanqiao/Dp/密码脱落.cpp)
*   **问题**：给定一个由 'A', 'B', 'C', 'D' 组成的字符串，它原本是一个回文串，但由于年代久远，部分字符脱落了。需要计算至少脱落了多少个字符，才能变成现在的样子。
*   **核心**：找到最少需要删除多少个字符，使得原字符串变成一个回文串。这等价于找到原字符串中最长的回文子序列，删除的字符数 = 原字符串长度 - 最长回文子序列长度。

### 2. 题目要求

*   **输入**：一行字符串，只包含 'A', 'B', 'C', 'D'。
*   **输出**：一个整数，表示至少需要脱落的字符数。
*   **限制**：字符串长度 \(N \le 1000\)，时间限制 1s，空间限制 256M。

### 3. 关键概念

*   **回文串 (Palindrome)**：正着读和反着读都一样的字符串，例如 "ABCBA"。
*   **子序列 (Subsequence)**：从原字符串中删除零个或多个字符，保持剩下字符的相对顺序不变，得到的字符串。例如 "ACE" 是 "ABCDE" 的子序列。
*   **回文子序列 (Palindromic Subsequence)**：既是原字符串的子序列，本身又是一个回文串。例如 "ABA" 是 "ABCBDA" 的一个回文子序列。
*   **最长回文子序列 (Longest Palindromic Subsequence, LPS)**：原字符串中最长的那个回文子序列。
*   **问题转化**：求“至少脱落多少个字符”等价于求“最多保留多少个字符形成回文串”。因此，问题转化为求解原字符串的**最长回文子序列 (LPS)** 的长度。
*   **LPS 与 LCS 的关系**：一个字符串 `s` 的最长回文子序列，等于 `s` 和其反转字符串 `s_rev` 的**最长公共子序列 (LCS)**。

## 三、示例分析

### 1. 基本示例

```
输入：ABCBA
输出：0
解释：
原字符串 s = "ABCBA"
反转字符串 s1 = "ABCBA"
s 和 s1 的 LCS 是 "ABCBA"，长度为 5。
原字符串长度 n = 5。
至少脱落字符数 = n - LCS长度 = 5 - 5 = 0。
```

```
输入：ABDCDCBABC
输出：3
解释：
原字符串 s = "ABDCDCBABC"，长度 n = 10。
反转字符串 s1 = "CBABCDCDAB"。
s 和 s1 的一个最长公共子序列 (LCS) 是 "BDCDCBC" 或 "BABCDCB" 或 "ABCDCBA" 等，长度为 7。
至少脱落字符数 = n - LCS长度 = 10 - 7 = 3。
保留下来的 7 个字符可以构成一个回文串，例如 "BDCDCBC"。
```

### 2. 特殊情况

```
输入：AAAA
输出：0
解释：本身就是回文串。
```

```
输入：ABCD
输出：3
解释：
s = "ABCD", n = 4
s1 = "DCBA"
LCS("ABCD", "DCBA") 是 "A", "B", "C", "D" 中的任意一个，长度为 1。
至少脱落字符数 = 4 - 1 = 3。
```

### 3. 边界测试

```
输入：A
输出：0
解释：单个字符是回文串。
```

```
输入：AB
输出：1
解释：
s = "AB", n = 2
s1 = "BA"
LCS("AB", "BA") 是 "A" 或 "B"，长度为 1。
至少脱落字符数 = 2 - 1 = 1。
```

## 四、解题思路

### 1. 问题分析

*   问题的本质是求原字符串 `s` 的最长回文子序列 (LPS) 的长度。
*   将求解 LPS 问题转化为求解原字符串 `s` 和其反转字符串 `s1` 的最长公共子序列 (LCS) 的长度。
*   LCS 问题是经典的动态规划问题。

### 2. 算法设计

*   **核心算法**：动态规划求 LCS。
*   **状态定义**：`dp[i][j]` 表示字符串 `s` 的前 `i` 个字符 (`s[0...i-1]`) 与字符串 `s1` 的前 `j` 个字符 (`s1[0...j-1]`) 的最长公共子序列的长度。
*   **状态转移方程**：
    *   如果 `s[i-1] == s1[j-1]` (注意 C++ 字符串下标从 0 开始，所以第 i 个字符是 `s[i-1]`)，说明这两个字符可以匹配，加入 LCS 中：
        \[ dp[i][j] = dp[i-1][j-1] + 1 \]
    *   如果 `s[i-1] != s1[j-1]`，说明这两个字符不能同时加入 LCS，需要考虑两种情况：
        *   `s` 的前 `i` 个字符和 `s1` 的前 `j-1` 个字符的 LCS (`dp[i][j-1]`)
        *   `s` 的前 `i-1` 个字符和 `s1` 的前 `j` 个字符的 LCS (`dp[i-1][j]`)
        取两者中的最大值：
        \[ dp[i][j] = \max(dp[i-1][j], dp[i][j-1]) \]
*   **边界条件**：`dp[0][j] = 0` ( `s` 为空串) 和 `dp[i][0] = 0` ( `s1` 为空串)，表示空串与任何字符串的 LCS 长度都是 0。
*   **最终结果**：LCS 的长度为 `dp[n][n]`，其中 `n` 是原字符串 `s` 的长度。需要脱落的字符数 = `n - dp[n][n]`。

### 3. 解题步骤

1.  **读取输入**：读取字符串 `s`。
2.  **获取长度**：计算字符串 `s` 的长度 `n`。
3.  **创建反转串**：创建 `s` 的反转字符串 `s1`。
4.  **处理特殊情况**：如果 `s == s1` (即 `s` 本身就是回文串)，直接输出 0 并结束。
5.  **初始化 DP 表**：创建一个大小为 `(n+1) x (n+1)` 的二维数组 `dp`，并将其所有元素初始化为 0（或根据边界条件初始化）。代码中使用 `vector<vector<int>> dp(N, vector<int>(N))`，默认初始化为 0 满足边界条件。
6.  **填充 DP 表**：使用两层循环，根据状态转移方程计算 `dp[i][j]` 的值，其中 `i` 从 1 到 `n`，`j` 从 1 到 `n`。
7.  **计算结果**：最终的 LCS 长度为 `dp[n][n]`。计算 `result = n - dp[n][n]`。
8.  **输出结果**：输出 `result`。

## 五、代码实现

### 1. 完整代码

```cpp
/*
 * @Author: RainbowRain9
 * @Date: 2025-04-11 09:05:21
 * @LastEditTime: 2025-04-11 09:29:26
 * @FilePath: \C++\Algorithm\Lanqiao\Dp\密码脱落.cpp
 * @Description: 计算将字符串变为回文串所需的最少删除字符数
 */
#include <bits/stdc++.h> // 包含常用的 C++ 标准库头文件
using namespace std;

int main()
{
    // 优化输入输出速度
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    string s; // 存储输入的字符串
    cin >> s; // 读取输入字符串

    // 创建 s 的反转字符串 s1
    string s1 = s;
    reverse(s1.begin(), s1.end());

    // 如果原字符串已经是回文串，则不需要删除，输出 0
    if (s == s1) {
        cout << 0 << "\n";
        return 0;
    }

    int n = s.size(); // 获取字符串长度
    const int N = 1005; // 定义 DP 表的最大维度 (略大于题目限制 1000)

    // 定义 DP 表：dp[i][j] 表示 s 的前 i 个字符和 s1 的前 j 个字符的 LCS 长度
    // 注意：这里 dp 表的大小是 N x N，但实际使用 (n+1) x (n+1)
    // vector 默认初始化为 0，满足边界条件 dp[0][j] = 0 和 dp[i][0] = 0
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));

    // 填充 DP 表
    // i 对应 s 的字符索引 i-1, j 对应 s1 的字符索引 j-1
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            // 如果当前比较的字符相等 (s[i-1] 和 s1[j-1])
            if (s[i - 1] == s1[j - 1]) {
                // LCS 长度等于左上角的值加 1
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                // 如果字符不相等，LCS 长度等于上方或左方值的较大者
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    // 最长回文子序列长度 = s 和 s1 的 LCS 长度 = dp[n][n]
    // 最少脱落字符数 = 原字符串长度 n - 最长回文子序列长度
    int result = n - dp[n][n];
    cout << result << "\n"; // 输出结果

    return 0; // 程序正常结束
}
```

### 2. 关键代码段解析

```cpp
    // 创建 s 的反转字符串 s1
    string s1 = s;
    reverse(s1.begin(), s1.end());

    // 如果原字符串已经是回文串，则不需要删除，输出 0
    if (s == s1) {
        cout << 0 << "\n";
        return 0;
    }
```

*   **反转**：利用 `std::reverse` 函数快速得到反转字符串 `s1`。
*   **优化**：如果原串 `s` 本身就是回文串 (`s == s1`)，则 LPS 长度就是 `n`，需要删除 0 个字符。提前判断可以省去后续 DP 计算。

```cpp
    vector<vector<int>> dp(n + 1, vector<int>(n + 1, 0));

    // 填充 DP 表
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            // 核心状态转移
            if (s[i - 1] == s1[j - 1]) { // 比较 s 的第 i 个字符和 s1 的第 j 个字符
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
```

*   **DP 表定义**：`dp[i][j]` 存储 `s[0...i-1]` 和 `s1[0...j-1]` 的 LCS 长度。大小设为 `(n+1)x(n+1)` 是为了方便处理边界情况（`i=0` 或 `j=0`）。
*   **状态转移**：这是标准的 LCS 状态转移逻辑。`s[i-1]` 是 `s` 的第 `i` 个字符，`s1[j-1]` 是 `s1` 的第 `j` 个字符。
    *   相等时，当前字符可以加入 LCS，长度基于 `dp[i-1][j-1]` 增加 1。
    *   不等时，当前字符至少有一个不能加入 LCS，取 `dp[i-1][j]`（不考虑 `s[i-1]`）和 `dp[i][j-1]`（不考虑 `s1[j-1]`）中的最大值。

```cpp
    // 计算结果
    int result = n - dp[n][n];
    cout << result << "\n";
```

*   **结果计算**：`dp[n][n]` 存储了 `s` (长度 n) 和 `s1` (长度 n) 的 LCS 长度，也就是 `s` 的最长回文子序列的长度。用总长度 `n` 减去它，即为最少需要删除的字符数。

### 3. 代码优化

*   **空间优化**：标准的 LCS 算法的空间复杂度是 O(N^2)。注意到 `dp[i][j]` 的计算只依赖于 `dp[i-1][...]` 和 `dp[i][j-1]`，即只依赖于上一行和当前行的左边。因此，可以使用滚动数组将空间复杂度优化到 O(N)。
    *   **使用两行**：`vector<vector<int>> dp(2, vector<int>(n + 1, 0))`，用 `i % 2` 和 `(i - 1) % 2` 来访问当前行和上一行。
    *   **使用一行**：`vector<int> dp(n + 1, 0)`，内层循环 `j` 需要从 `n` 倒序到 1，以避免覆盖还需用到的 `dp[j-1]` (代表 `dp[i-1][j-1]`)。

    优化后的状态转移（以一维 DP 为例）：
    ```cpp
    vector<int> dp(n + 1, 0);
    for (int i = 1; i <= n; ++i) {
        int prev_diag = 0; // 存储 dp[i-1][j-1] 的值
        for (int j = 1; j <= n; ++j) {
            int temp = dp[j]; // 存储 dp[i-1][j] 的值，用于下一次迭代的 prev_diag
            if (s[i - 1] == s1[j - 1]) {
                dp[j] = prev_diag + 1;
            } else {
                dp[j] = max(dp[j], dp[j - 1]); // dp[j] 是 dp[i-1][j], dp[j-1] 是 dp[i][j-1]
            }
            prev_diag = temp; // 更新 dp[i-1][j-1] 的值
        }
    }
    // 最终结果 n - dp[n]
    ```
    对于本题 256M 的空间限制，O(N^2) 的 `1005 * 1005 * sizeof(int)` 大约 4MB，是完全足够的，所以不优化空间也能通过。

## 六、模拟代码过程

以 `s = "ABAC"` 为例进行模拟：
`n = 4`
`s = "ABAC"`
`s1 = "CABA"`

DP 表 `dp[5][5]` 初始化为 0。

**i=1 (s[0]='A')**:
*   j=1 (s1[0]='C'): s[0]!=s1[0] => dp[1][1] = max(dp[0][1], dp[1][0]) = max(0, 0) = 0
*   j=2 (s1[1]='A'): s[0]==s1[1] => dp[1][2] = dp[0][1] + 1 = 0 + 1 = 1
*   j=3 (s1[2]='B'): s[0]!=s1[2] => dp[1][3] = max(dp[0][3], dp[1][2]) = max(0, 1) = 1
*   j=4 (s1[3]='A'): s[0]==s1[3] => dp[1][4] = dp[0][3] + 1 = 0 + 1 = 1

**i=2 (s[1]='B')**:
*   j=1 (s1[0]='C'): s[1]!=s1[0] => dp[2][1] = max(dp[1][1], dp[2][0]) = max(0, 0) = 0
*   j=2 (s1[1]='A'): s[1]!=s1[1] => dp[2][2] = max(dp[1][2], dp[2][1]) = max(1, 0) = 1
*   j=3 (s1[2]='B'): s[1]==s1[2] => dp[2][3] = dp[1][2] + 1 = 1 + 1 = 2
*   j=4 (s1[3]='A'): s[1]!=s1[3] => dp[2][4] = max(dp[1][4], dp[2][3]) = max(1, 2) = 2

**i=3 (s[2]='A')**:
*   j=1 (s1[0]='C'): s[2]!=s1[0] => dp[3][1] = max(dp[2][1], dp[3][0]) = max(0, 0) = 0
*   j=2 (s1[1]='A'): s[2]==s1[1] => dp[3][2] = dp[2][1] + 1 = 0 + 1 = 1
*   j=3 (s1[2]='B'): s[2]!=s1[2] => dp[3][3] = max(dp[2][3], dp[3][2]) = max(2, 1) = 2
*   j=4 (s1[3]='A'): s[2]==s1[3] => dp[3][4] = dp[2][3] + 1 = 2 + 1 = 3

**i=4 (s[3]='C')**:
*   j=1 (s1[0]='C'): s[3]==s1[0] => dp[4][1] = dp[3][0] + 1 = 0 + 1 = 1
*   j=2 (s1[1]='A'): s[3]!=s1[1] => dp[4][2] = max(dp[3][2], dp[4][1]) = max(1, 1) = 1
*   j=3 (s1[2]='B'): s[3]!=s1[2] => dp[4][3] = max(dp[3][3], dp[4][2]) = max(2, 1) = 2
*   j=4 (s1[3]='A'): s[3]!=s1[3] => dp[4][4] = max(dp[3][4], dp[4][3]) = max(3, 2) = 3

最终 `dp[4][4] = 3`。
最长回文子序列长度为 3 (例如 "ABA")。
至少脱落字符数 = `n - dp[n][n]` = `4 - 3 = 1`。

**图示说明（DP 表填充过程）**

```
      "" C A B A
""    0  0 0 0 0
A     0  0 1 1 1
B     0  0 1 2 2
A     0  0 1 2 3
C     0  1 1 2 3
```

## 七、复杂度分析

### 1. 时间复杂度

*   需要填充一个 `(n+1) x (n+1)` 的 DP 表。
*   每个状态 `dp[i][j]` 的计算时间是 O(1)。
*   总时间复杂度为 O(N^2)，其中 N 是字符串的长度。
*   对于 N=1000，N^2 = 1,000,000，在 1 秒的时间限制内是可以通过的。

### 2. 空间复杂度

*   使用了一个 `(n+1) x (n+1)` 的二维 DP 表。
*   空间复杂度为 O(N^2)。
*   对于 N=1000，需要大约 `1000 * 1000 * 4 bytes ≈ 4MB` 的空间，远小于 256M 的限制。
*   如果使用空间优化，空间复杂度可以降为 O(N)。

### 3. 优化空间

*   **时间优化**：对于求解 LCS 问题，O(N^2) 基本上是标准解法，难以进一步优化。
*   **空间优化**：如前所述，可以优化到 O(N)。

## 八、常见错误

### 1. 代码错误

*   **下标错误**：DP 表和字符串的下标混淆。DP 表通常从 1 开始（或大小为 n+1），而字符串从 0 开始。`dp[i][j]` 对应 `s[i-1]` 和 `s1[j-1]`。代码中 `for` 循环使用 1 到 `n`，访问 `s[i-1]` 和 `s1[j-1]` 是正确的。
*   **边界条件错误**：DP 表的第 0 行和第 0 列应为 0，表示空串与任何串的 LCS 都是 0。`vector` 默认初始化为 0 可以处理好。
*   **`max` 函数使用错误**：确保在 `s[i-1] != s1[j-1]` 时正确取 `max(dp[i-1][j], dp[i][j-1])`。

### 2. 思路错误

*   **误解题意**：错误地理解为求最长回文子串（连续）而非子序列（不连续）。
*   **直接对原串 DP**：尝试直接在原串上 DP 求 LPS 而不是转化为 LCS 问题，可能导致状态定义或转移复杂化（虽然也有直接求 LPS 的 DP 方法，但转化为 LCS 更通用）。
*   **忘记结果转换**：算出了 LCS 长度 `dp[n][n]`，但忘记用 `n` 减去它得到最终答案。

### 3. 调试建议

*   **打印 DP 表**：对于小规模输入，可以打印出完整的 DP 表，检查状态转移是否符合预期。
*   **单步调试**：跟踪 `i`, `j` 的变化，观察 `dp[i][j]` 是如何根据 `dp[i-1][j-1]`, `dp[i-1][j]`, `dp[i][j-1]` 计算出来的。
*   **构造简单测试用例**：用 "A", "AB", "ABA", "ABC", "AAA" 等简单用例手动推演 DP 过程并与程序输出对比。

## 九、扩展思考

### 1. 题目变形

*   **最小插入次数使字符串成为回文串**：这个问题与本题等价，最少需要插入的字符数等于最少需要删除的字符数，都等于 `n - LPS长度`。因为插入的字符和删除的字符是“对称”的。
*   **输出最长回文子序列**：不仅仅是求长度，还需要回溯 DP 表来构造出具体的 LPS 字符串。
*   **带权重的字符**：如果删除不同的字符有不同的代价，问题会更复杂。

### 2. 面试相关

*   面试官可能会问 LCS 的状态转移方程推导过程。
*   可能会要求实现空间优化 O(N) 的版本。
*   可能会追问如何回溯 DP 表找到具体的 LCS 或 LPS。
*   可能会考察对回文串、子序列等基本概念的理解。

### 3. 实战技巧

*   **LCS 模板**：掌握 LCS 的标准 DP 写法，可以快速解决一系列相关问题。
*   **问题转化**：学会将看似不同的问题（如求 LPS、最小删除/插入回文）转化为熟悉的核心模型（如 LCS）。
*   **边界意识**：写 DP 时始终注意边界条件的处理。

## 十、相关题目

### 1. 类似题目

1.  [LeetCode 516. 最长回文子序列](https://leetcode.cn/problems/longest-palindromic-subsequence/) - 完全相同的问题。
2.  [LeetCode 1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/) - 本题的核心算法。
3.  [LeetCode 1312. 让字符串成为回文串的最少插入次数](https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/) - 与本题等价。
4.  [LeetCode 5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/) - 注意区分“子串”（连续）和“子序列”（不连续）。

### 2. 推荐练习

*   **基础**：LeetCode 1143 (LCS), LeetCode 5 (Longest Palindromic Substring)
*   **进阶**：LeetCode 516 (LPS), LeetCode 1312 (Min Insertions Palindrome)
*   **综合**：LeetCode 72 (Edit Distance)，编辑距离问题也常用二维 DP 解决。
