# 876.链表的中间结点

## 一、前置知识
- 链表数据结构
- 双指针技巧
- 快慢指针算法

## 二、题目分析

### 1. 题目描述
- 题目链接：[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)
- 本地链接：[876-middle-of-the-linked-list.cpp](../Algorithm/LeetCode/All/876-middle-of-the-linked-list.cpp)
- 难度级别：简单
- 相关标签：链表、双指针

### 2. 题目要求
- 输入：单链表的头结点 head
- 输出：链表的中间结点
- 特殊说明：如果有两个中间结点，返回第二个中间结点
- 约束条件：
  - 链表结点数范围 [1, 100]
  - 结点值范围 [1, 100]

### 3. 关键概念
- 单链表：每个节点包含一个值和指向下一个节点的指针
- 中间结点：链表长度为n时，中间结点为第⌊n/2⌋+1个节点
- 快慢指针：一种在链表中寻找中点的经典技巧

## 三、示例分析

### 1. 基本示例
```
输入：head = [1,2,3,4,5]
输出：[3,4,5]
解释：
- 链表长度为5，中间结点是第3个节点
- 返回从中间结点开始的子链表[3,4,5]
```

### 2. 特殊情况
```
输入：head = [1,2,3,4,5,6]
输出：[4,5,6]
解释：
- 链表长度为6，有两个中间结点3和4
- 根据题目要求，返回第二个中间结点[4,5,6]
```

### 3. 边界测试
```
输入：head = [1]
输出：[1]
解释：
- 链表只有一个节点时，该节点即为中间结点
```

## 四、解题思路

### 1. 问题分析
- 核心问题：如何在不知道链表长度的情况下找到中间结点
- 可能的解决方案：
  1. 两次遍历：第一次计算长度，第二次找中点
  2. 快慢指针：一次遍历即可找到中点

### 2. 算法设计
- 采用快慢指针法：
  - 快指针每次移动两步
  - 慢指针每次移动一步
  - 当快指针到达末尾时，慢指针恰好在中间位置

### 3. 解题步骤
1. 初始化快慢指针
   - 快指针fast指向头结点
   - 慢指针slow指向头结点
2. 移动指针
   - 快指针每次移动两步
   - 慢指针每次移动一步
3. 返回结果
   - 当快指针到达末尾时，返回慢指针位置

## 五、代码实现

### 1. 完整代码
```cpp
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

### 2. 关键代码段解析
```cpp
while (fast && fast->next) {
    fast = fast->next->next;  // 快指针移动两步
    slow = slow->next;        // 慢指针移动一步
}
```
- 循环条件确保快指针及其下一个节点非空
- 快指针每次移动两步，需要检查两个节点
- 慢指针稳步前进一个节点

### 3. 代码优化
- 当前实现已经是最优解，时间复杂度O(n)，空间复杂度O(1)
- 无需进一步优化

## 六、模拟代码过程

### 1. 执行流程
以输入[1,2,3,4,5]为例：
```
初始状态：
slow = 1, fast = 1

第一次循环：
slow = 2, fast = 3

第二次循环：
slow = 3, fast = 5

第三次循环：
fast->next = null，循环结束

返回slow(值为3)
```

### 2. 图示说明
```
第一次循环：
1 -> 2 -> 3 -> 4 -> 5
s    s'
f         f'

第二次循环：
1 -> 2 -> 3 -> 4 -> 5
     s    s'
          f         f'

结束状态：
1 -> 2 -> 3 -> 4 -> 5
          s
                    f
```

### 3. 调试技巧
- 重点关注快指针的边界检查
- 验证奇偶长度链表的处理是否正确
- 检查返回值是否为正确的中间节点

## 七、复杂度分析

### 1. 时间复杂度
- O(n)：只需要一次遍历
- 快指针移动速度是慢指针的两倍
- 总体仍是线性时间复杂度

### 2. 空间复杂度
- O(1)：只使用了两个指针
- 不需要额外的存储空间
- 空间复杂度为常数级

### 3. 优化空间
- 当前解法已经达到最优
- 时间复杂度无法进一步优化
- 空间复杂度已经是常数级

## 八、常见错误

### 1. 代码错误
```cpp
// 错误代码
while (fast->next) {  // 缺少对fast的判空
    fast = fast->next->next;
    slow = slow->next;
}
```
- 没有检查fast是否为空
- 可能导致空指针异常

### 2. 思路错误
- 忽略链表长度为偶数的情况
- 返回第一个中间节点而不是第二个
- 边界条件处理不当

### 3. 调试建议
- 使用不同长度的链表测试
- 特别关注边界情况
- 验证奇偶长度的处理逻辑

## 九、扩展思考

### 1. 题目变形
- 如果要求返回第一个中间节点？
- 如何找到链表的倒数第k个节点？
- 如何判断链表是否有环？

### 2. 面试相关
- 快慢指针的其他应用场景
- 如何处理链表相关的其他问题
- 考虑空间复杂度的优化方案

### 3. 实战技巧
- 掌握快慢指针模板
- 注意边界条件的处理
- 培养代码的鲁棒性意识

## 十、相关题目

### 1. 类似题目
1. [141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)
2. [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)
3. [19. 删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

### 2. 推荐练习
- [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)
- [142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)
- [160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)
