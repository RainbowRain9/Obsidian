# 25. K个一组翻转链表

## 一、前置知识
- 链表的基本操作
- 指针的使用
- 链表翻转算法
- 分组处理思想

## 二、题目分析

### 1. 题目描述
- 题目链接：[K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/description/)
- 本地链接：[25-reverse-nodes-in-k-group.cpp](../Algorithm/LeetCode/All/25-reverse-nodes-in-k-group.cpp)
- 难度级别：Hard
- 相关标签：链表、递归

### 2. 题目要求
- 输入：链表头节点head和正整数k
- 要求：每k个节点一组进行翻转
- 特殊情况：如果最后剩余节点数小于k，保持原有顺序
- 限制：不能只改变节点值，必须实际交换节点
- 进阶要求：设计O(1)额外空间的算法

### 3. 关键概念
- 链表分组：每k个节点为一组
- 部分翻转：对每组内的节点进行翻转
- 连接处理：翻转后需要正确连接各组
- 剩余处理：最后不足k个节点的处理

## 三、示例分析

### 1. 基本示例
```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
解释：
1. 第一组[1,2]翻转为[2,1]
2. 第二组[3,4]翻转为[4,3]
3. 最后一个节点5不足2个，保持原样
```

### 2. 特殊情况
```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
解释：
1. 第一组[1,2,3]翻转为[3,2,1]
2. 剩余节点[4,5]不足3个，保持原样
```

### 3. 边界测试
```
输入：head = [1], k = 1
输出：[1]
说明：单个节点的情况，直接返回
```

## 四、解题思路

### 1. 问题分析
- 核心问题：如何实现分组翻转并保持正确连接
- 关键点：
  1. 计算链表长度确定分组数
  2. 每组内部翻转
  3. 组间正确连接
  4. 处理最后剩余节点

### 2. 算法设计
1. 计算链表长度n
2. 使用虚拟头节点简化操作
3. 每次处理k个节点：
   - 翻转这k个节点
   - 更新连接关系
4. 重复步骤3直到剩余节点数小于k

### 3. 解题步骤
1. 初始化阶段
   - 计算链表长度
   - 创建虚拟头节点
   - 初始化指针
2. 分组翻转
   - 翻转k个节点
   - 更新组间连接
3. 返回结果

## 五、代码实现

### 1. 完整代码
```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        // 计算链表长度
        int n = 0;
        for (ListNode* cur = head; cur; cur = cur->next) {
            n++;
        }
        
        // 创建虚拟头节点
        ListNode dummy(0, head);
        ListNode* p0 = &dummy;
        ListNode* pre = NULL;
        ListNode* cur = head;
        
        // 每次处理k个节点
        for (; n >= k; n -= k) {
            // 翻转k个节点
            for (int i = 0; i < k; i++) {
                ListNode* nxt = cur->next;
                cur->next = pre;
                pre = cur;
                cur = nxt;
            }
            
            // 连接翻转后的组
            ListNode* nxt = p0->next;
            p0->next->next = cur;
            p0->next = pre;
            p0 = nxt;
        }
        return dummy.next;
    }
};
```

### 2. 关键代码段解析
```cpp
// 翻转k个节点的核心代码
for (int i = 0; i < k; i++) {
    ListNode* nxt = cur->next;  // 保存下一个节点
    cur->next = pre;            // 反转指针
    pre = cur;                  // 移动pre指针
    cur = nxt;                  // 移动cur指针
}
```

### 3. 代码优化
- 使用虚拟头节点避免了对头节点的特殊处理
- 提前计算链表长度，避免了额外的遍历判断
- 使用有限的指针完成翻转，实现O(1)空间复杂度

## 六、模拟代码过程

### 1. 执行流程
以输入[1,2,3,4,5], k=2为例：
```
初始状态：1->2->3->4->5
第一组翻转后：2->1->3->4->5
第二组翻转后：2->1->4->3->5
最后节点5保持不变
```

### 2. 图示说明
```
原始链表：    1 -> 2 -> 3 -> 4 -> 5
第一次翻转：  2 -> 1 -> 3 -> 4 -> 5
第二次翻转：  2 -> 1 -> 4 -> 3 -> 5
```

### 3. 调试技巧
- 重点关注组间连接的更新
- 注意指针移动的顺序
- 检查边界情况的处理

## 七、复杂度分析

### 1. 时间复杂度
- O(n)：需要遍历整个链表
- 每个节点最多被访问两次：计数和翻转

### 2. 空间复杂度
- O(1)：只使用有限的指针变量
- 不需要额外的数据结构

### 3. 优化空间
- 时间复杂度已经是最优
- 空间复杂度已经达到题目进阶要求

## 八、常见错误

### 1. 代码错误
```cpp
// 错误：忘记保存next指针
cur->next = pre;
pre = cur;
cur = cur->next;  // 错误：cur->next已经被修改

// 正确：应该先保存next
ListNode* nxt = cur->next;
cur->next = pre;
pre = cur;
cur = nxt;
```

### 2. 思路错误
- 忘记计算链表长度
- 组间连接顺序错误
- 未处理剩余节点

### 3. 调试建议
- 使用小规模测试用例
- 画图辅助理解指针变化
- 检查每步指针更新

## 九、扩展思考

### 1. 题目变形
- 如何实现从后往前每k个一组翻转？
- 如何判断是否需要翻转（根据节点值）？
- 如何实现部分翻转（翻转部分节点）？

### 2. 面试相关
- 链表操作的基本功考察
- 指针操作的熟练度
- 代码的鲁棒性

### 3. 实战技巧
- 使用虚拟头节点简化操作
- 画图帮助理解指针变化
- 多写多练，熟能生巧

## 十、相关题目

### 1. 类似题目
1. [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/) - 基础版本
2. [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/) - 部分翻转

### 2. 推荐练习
- 链表基础操作题目
- 指针操作相关题目
- 分组处理类题目
