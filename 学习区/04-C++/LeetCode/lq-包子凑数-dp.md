# 包子凑数

## 一、前置知识

*   **动态规划 (Dynamic Programming):** 特别是完全背包问题的思想。我们需要判断一个数是否能由给定的一些数（包子数量）组合而成，每个数可以使用无限次。
*   **最大公约数 (Greatest Common Divisor, GCD):** 理解GCD的概念及其在判断数论问题（如是否能凑出所有足够大的数）中的作用。裴蜀定理（Bézout's identity）指出，对于一组整数 \(A_1, A_2, ..., A_N\)，它们能凑出的数的集合是 \( \{ c_1A_1 + c_2A_2 + ... + c_NA_N \mid c_i \in \mathbb{Z} \} \)，这个集合等于所有 \( g = \gcd(A_1, A_2, ..., A_N) \) 的倍数的集合。在本题中，由于我们只能使用非负整数次（\(c_i \ge 0\)），如果 \(g > 1\)，则所有不是 \(g\) 的倍数的数都无法凑出，导致有无限个凑不出的数。
*   **数论基础:** 了解如果 \( \gcd(A_1, A_2, ..., A_N) = 1 \)，那么不能由这组数凑出的数的个数是有限的（扩展自弗罗贝尼乌斯币问题 Frobenius Coin Problem）。

## 二、题目分析

### 1. 题目描述

*   题目链接：(通常来自蓝桥杯等竞赛平台，这里缺少具体链接)
*   本地链接：[包子凑数](../Algorithm/Lanqiao/Dp/包子凑数.cpp)
*   难度级别：中等
*   相关标签：动态规划 (DP), 数论, 完全背包

### 2. 题目要求

*   输入：第一行一个整数 `N`，表示蒸笼的种类数。接下来 `N` 行，每行一个整数 `Ai`，表示第 `i` 种蒸笼能放的包子数。
*   输出：一个整数或字符串。如果不能凑出的包子数目是有限的，输出这个数目；如果是无限多个，输出 "INF"。
*   限制：`1 ≤ N ≤ 100`, `1 ≤ Ai ≤ 100`。

### 3. 关键概念

*   **凑数:** 指使用给定的 `N` 种蒸笼，每种可以使用任意多次，问某个数量 `X` 是否能刚好凑出。这等价于问 `X` 是否能表示为 \( X = c_1A_1 + c_2A_2 + ... + c_NA_N \)，其中 \( c_i \ge 0 \) 是整数。
*   **无限不可凑数:** 当且仅当所有 `Ai` 的最大公约数 `g = gcd(A1, A2, ..., AN)` 大于 1 时，只有 `g` 的倍数可能被凑出，所有不是 `g` 的倍数的正整数都无法凑出，因此有无限个。
*   **有限不可凑数:** 当 `gcd(A1, A2, ..., AN) = 1` 时，根据数论知识，存在一个最大不能凑出的数（虽然具体公式复杂），大于这个数的数都能凑出，所以不能凑出的数的个数是有限的。

## 三、示例分析

### 1. 基本示例

```
输入：
2
4
5
输出：
6
解释：
A = [4, 5]。gcd(4, 5) = 1，不可凑出的数有限。
可以凑出的数：4, 5, 8(4+4), 9(4+5), 10(5+5), 12(4+4+4), 13(4+4+5), 14(4+5+5), 15(5+5+5), ...
不能凑出的数：1, 2, 3, 6, 7, 11。总共 6 个。
```

### 2. 特殊情况

```
输入：
2
4
6
输出：
INF
分析：
A = [4, 6]。gcd(4, 6) = 2。
只能凑出偶数：4, 6, 8(4+4), 10(4+6), 12(6+6 或 4+4+4), ...
所有奇数都无法凑出，例如 1, 3, 5, 7, 9, ...。因此有无限多个凑不出的数，输出 INF。
```

### 3. 边界测试

```
输入：
1
7
输出：
INF
说明：
A = [7]。gcd(7) = 7 > 1。
只能凑出 7 的倍数：7, 14, 21, ...
所有不是 7 的倍数的数都无法凑出，有无限个。
```

```
输入：
3
2
3
5
输出：
0
说明：
A = [2, 3, 5]。gcd(2, 3, 5) = 1。
可以凑出的数：2, 3, 4(2+2), 5, 6(3+3), 7(2+5), 8(3+5), ...
可以证明所有正整数都能凑出（实际上，gcd=1 时，总有一个最大不能凑出的数，如果连 1 都能凑出，那所有数都能凑出，但这里 1 不能凑出，但 2 和 3 可以，它们是连续的，所以大于 1 的数都能凑出。这里需要严谨证明或 DP 验证）。通过 DP 验证，可以发现所有正整数都能凑出（除了 1），但题目问的是凑不出的**正整数**个数，如果所有正整数都能凑出，则个数为 0。
```

## 四、解题思路

### 1. 问题分析

*   问题的本质是判断哪些正整数 `X` 可以表示为 `A_i` 的非负整数线性组合。
*   首先需要处理无限情况：计算所有 `A_i` 的最大公约数 `g`。如果 `g > 1`，则直接输出 "INF"。
*   如果 `g = 1`，则不可凑出的数的个数是有限的。我们需要找出所有不能凑出的正整数。这是一个典型的完全背包/凑零钱问题变种：判断数字 `i` 是否能被凑出。

### 2. 算法设计

*   **GCD 计算:** 需要一个函数来计算 `N` 个数的最大公约数。可以迭代计算 `gcd(A1, A2)`, `gcd(result, A3)`, ...
*   **动态规划:**
    *   状态定义：`dp[i]` 表示数字 `i` 是否可以被凑出。可以用 `bool` 类型或者 `int` 类型（0 表示不能，非 0 表示可以）。
    *   状态转移：`dp[i]` 能凑出，当且仅当存在某个 `Aj` 使得 `dp[i - Aj]` 能凑出。即 `dp[i] = dp[i] || dp[i - Aj]` （对于所有 `j` 且 `i >= Aj`）。
    *   基本情况：`dp[0] = true` (或 1)，表示凑出 0 是可以的（不选任何蒸笼）。
    *   计算顺序：从小到大计算 `dp[i]`，从 1 开始。
    *   DP 数组上限：由于 `gcd = 1` 时，不可凑出的数是有限的，我们需要确定 DP 数组计算到多大就足够了。题目没有明确给出上限，但根据 `Ai <= 100`，以及数论的一些结论（如 `min(Ai)` 个连续数可凑出后，更大的数都能凑出），一个相对安全的上限可以是 `100 * 100 = 10000` 左右。如果在这个范围内仍有大量无法凑出的数，可能暗示着 GCD > 1（尽管我们应该先计算 GCD）。代码中使用了 `1e7` 这个非常大的上限，可能是为了绝对安全或简化边界判断。
*   **统计结果:** 遍历 DP 数组 `dp[1]` 到 `dp[UpperBound]`，统计 `dp[i]` 为 `false` (或 0) 的个数。

### 3. 解题步骤

1.  **计算 GCD:**
    *   读入 `N` 和所有 `Ai`。
    *   计算 `g = gcd(A1, A2, ..., AN)`。可以使用 `std::gcd` (C++17) 或手写欧几里得算法。
    *   如果 `g > 1`，输出 "INF" 并结束程序。
2.  **初始化 DP:**
    *   创建一个足够大的 DP 数组（例如 `dp[10001]` 或根据代码 `dp[N=1e7]`），初始化所有元素为 `false` (或 0)。
    *   设置 `dp[0] = true` (或 1)。
3.  **执行 DP:**
    *   有两种常见的 DP 循环方式：
        *   **方式一（物品驱动）：**
            ```cpp
            for (int j = 1; j <= n; ++j) { // 遍历物品 (蒸笼)
                for (int i = num[j]; i <= MaxSum; ++i) { // 遍历容量 (包子数)
                    dp[i] = dp[i] || dp[i - num[j]]; // 或 dp[i] += dp[i - num[j]];
                }
            }
            ```
        *   **方式二（容量驱动，类似代码中的方式）：**
            ```cpp
            for (int i = 1; i <= MaxSum; ++i) { // 遍历容量
                for (int j = 1; j <= n; ++j) { // 遍历物品
                    if (i >= num[j] && dp[i - num[j]]) { // 如果 i-num[j] 能凑出
                        dp[i] = true; // 那么 i 也能凑出
                        break; // 找到一种方法即可
                    }
                }
            }
            ```
            *注意：代码中的 `dp[i] = dp[i - num[j]] + dp[i]` 逻辑上是判断 `dp[i-num[j]]` 是否非零，如果是就让 `dp[i]` 也非零。虽然能工作，但使用 `bool` 或简单的 `dp[i] = true` 更清晰。代码也没有显式初始化 `dp[0]`，而是通过 `dp[num[i]]++` 来初始化，这依赖于 `dp[0]` 默认为 0。*
4.  **统计结果:**
    *   初始化计数器 `count = 0`。
    *   遍历 `dp` 数组从 `i = 1` 到 `MaxSum`。
    *   如果 `dp[i]` 为 `false` (或 0)，则 `count++`。
    *   代码中使用 `des` 作为计数器，并在 DP 过程中累加。如果 `des` 超过某个阈值 (10000)，则判断为 INF (这是对 GCD>1 情况的另一种不精确的判断方式)。
5.  **输出结果:**
    *   输出最终的 `count` (或代码中的 `des`)。

## 五、代码实现

### 1. 完整代码（带注释和改进）

```cpp
#include <iostream>
#include <vector>
#include <numeric> // 包含 gcd (C++17) 或需要手写

// 手写 GCD (如果 C++17 不可用)
int calculate_gcd(int a, int b) {
    while (b) {
        a %= b;
        std::swap(a, b);
    }
    return a;
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(0);
    std::cout.tie(0);

    int n;
    std::cin >> n;

    std::vector<int> a(n);
    int overall_gcd = 0; // 用于计算所有 Ai 的 GCD
    for (int i = 0; i < n; ++i) {
        std::cin >> a[i];
        if (i == 0) {
            overall_gcd = a[i];
        } else {
            // 使用 C++17 的 gcd
            // overall_gcd = std::gcd(overall_gcd, a[i]);
            // 或使用手写的 gcd
            overall_gcd = calculate_gcd(overall_gcd, a[i]);
        }
    }

    // 检查 GCD 是否大于 1
    if (overall_gcd > 1) {
        std::cout << "INF\n";
        return 0;
    }

    // 如果 GCD = 1，则不可凑出的数是有限的，进行 DP
    // 设置一个合理的 DP 上限，例如 100*100 = 10000，或者更大一些以防万一
    // 考虑到题目数据范围和常见做法，可以设置一个稍大的值，如 20000 或 100000
    // 原代码使用 1e7 是过大的，但我们这里模拟其思路，用一个足够大的值
    const int MAX_SUM = 100000; // 调整此上限
    std::vector<bool> dp(MAX_SUM + 1, false); // dp[i] 表示 i 是否能凑出
    dp[0] = true; // 0 可以凑出（不选任何蒸笼）

    // 方式二：容量驱动 DP
    for (int i = 1; i <= MAX_SUM; ++i) {
        for (int j = 0; j < n; ++j) {
            if (i >= a[j] && dp[i - a[j]]) {
                dp[i] = true;
                break; // 只要找到一种凑法即可
            }
        }
    }

    // 统计无法凑出的数的个数
    int unattainable_count = 0;
    for (int i = 1; i <= MAX_SUM; ++i) {
        if (!dp[i]) {
            unattainable_count++;
        }
    }

    std::cout << unattainable_count << "\n";

    return 0;
}
```

### 2. 关键代码段解析 (原代码)

```cpp
// Algorithm/Lanqiao/Dp/包子凑数.cpp
// ... includes ...
using namespace std;
const int N = 1e7; // 非常大的 DP 上限
int num[105];      // 存储 Ai
int dp[N];         // DP 数组，dp[i] != 0 表示 i 可凑出

int main() {
    // ... io setup ...
    int n;
    int des = 0; // 统计无法凑出的个数
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> num[i];
        // 初始化：直接将 Ai 标记为可达
        // 注意：这里使用 ++，如果 num[i] 重复，dp 值会 > 1，但不影响逻辑
        // 但没有初始化 dp[0]，这是个潜在问题，依赖于全局数组默认为 0
        dp[num[i]]++;
    }

    // DP 过程：容量驱动
    for (int i = 1; i <= N; i++) { // 遍历所有可能的包子数
        for (int j = 1; j <= n; j++) { // 遍历所有蒸笼类型
            if (i < num[j]) { // 如果当前包子数小于蒸笼容量，跳过
                continue;
            }
            // 状态转移：如果 i - num[j] 可达 (dp非0)，则 i 也可达
            // 使用加法模拟逻辑或：如果 dp[i-num[j]] > 0，dp[i] 会变成正数
            // 如果 dp[i] 本身因为之前的 Aj' 已经为正，它会保持正数
            dp[i] = dp[i - num[j]] + dp[i];
            if (dp[i] != 0) { // 一旦发现 i 可达，就没必要再试其他 j
                break;
            }
        }
        if (dp[i] == 0) { // 如果循环结束后 dp[i] 仍为 0，说明 i 无法凑出
            des++;
        }
    }

    // 使用阈值判断 INF，这是对 GCD > 1 情况的间接/不精确判断
    if (des > 10000) { // 如果无法凑出的数过多，则认为是无限
        cout << "INF";
        return 0;
    }
    cout << des; // 输出有限的不可凑出数

    return 0;
}
```

### 3. 代码优化

*   **GCD 检查:** 显式计算 GCD 是判断 INF 条件的正确且高效的方法，避免依赖 DP 结果和阈值。
*   **DP 状态:** 使用 `vector<bool>` 更直观且节省空间。
*   **DP 初始化:** 明确设置 `dp[0] = true`。
*   **DP 上限:** `1e7` 过于庞大，导致时间和空间复杂度过高。应根据 `Ai` 的范围确定一个更紧凑但安全的上限。理论上，若 `gcd=1`，最大不可凑数与 `max(Ai)` 和 `min(Ai)` 相关，但没有简单通用公式。实践中，`max(Ai)^2` 级别通常足够，如 `100*100 = 10000` 或稍大。
*   **DP 循环:** 物品驱动的 DP (`for Aj { for i ... }`) 通常在实现上更简洁，且不易出错。

## 六、模拟代码过程(使用改进后代码和示例1)

### 1. 执行流程

*   **输入:** `n = 2`, `a = [4, 5]`
*   **GCD 计算:** `gcd(4, 5) = 1`。不是 INF 情况。
*   **初始化 DP:** `MAX_SUM = 100000` (或其他选择的上限)。`dp` 数组大小为 `100001`，`dp[0] = true`，其余为 `false`。
*   **DP 计算 (容量驱动):**
    *   `i = 1`: `1 < 4`, `1 < 5` -> `dp[1] = false`
    *   `i = 2`: `2 < 4`, `2 < 5` -> `dp[2] = false`
    *   `i = 3`: `3 < 4`, `3 < 5` -> `dp[3] = false`
    *   `i = 4`: `4 >= 4`, `dp[4-4]=dp[0]=true` -> `dp[4] = true`, `break`
    *   `i = 5`: `5 >= 4`, `dp[5-4]=dp[1]=false`. `5 >= 5`, `dp[5-5]=dp[0]=true` -> `dp[5] = true`, `break`
    *   `i = 6`: `6 >= 4`, `dp[6-4]=dp[2]=false`. `6 >= 5`, `dp[6-5]=dp[1]=false` -> `dp[6] = false`
    *   `i = 7`: `7 >= 4`, `dp[7-4]=dp[3]=false`. `7 >= 5`, `dp[7-5]=dp[2]=false` -> `dp[7] = false`
    *   `i = 8`: `8 >= 4`, `dp[8-4]=dp[4]=true` -> `dp[8] = true`, `break`
    *   `i = 9`: `9 >= 4`, `dp[9-4]=dp[5]=true` -> `dp[9] = true`, `break`
    *   `i = 10`: `10 >= 4`, `dp[10-4]=dp[6]=false`. `10 >= 5`, `dp[10-5]=dp[5]=true` -> `dp[10] = true`, `break`
    *   `i = 11`: `11 >= 4`, `dp[11-4]=dp[7]=false`. `11 >= 5`, `dp[11-5]=dp[6]=false` -> `dp[11] = false`
    *   `i = 12`: `12 >= 4`, `dp[12-4]=dp[8]=true` -> `dp[12] = true`, `break`
    *   ... 继续计算直到 `MAX_SUM` ...
*   **统计结果:** 遍历 `dp[1]` 到 `dp[MAX_SUM]`。
    *   `dp[1]=false`, `count=1`
    *   `dp[2]=false`, `count=2`
    *   `dp[3]=false`, `count=3`
    *   `dp[4]=true`
    *   `dp[5]=true`
    *   `dp[6]=false`, `count=4`
    *   `dp[7]=false`, `count=5`
    *   `dp[8]=true`
    *   `dp[9]=true`
    *   `dp[10]=true`
    *   `dp[11]=false`, `count=6`
    *   `dp[12]=true`
    *   ... 之后 `dp` 值会持续为 `true`（因为 `gcd=1`） ...
*   **输出:** `6`

### 2. 图示说明 (DP 状态变化)

```mermaid
graph TD
    Start --> Init(dp[0]=T, others=F)
    Init --> DP_Loop(Loop i=1 to MaxSum)
    DP_Loop --> Check_A1(i>=A1 and dp[i-A1]?)
    Check_A1 -- Yes --> Set_dp_T(dp[i]=T) --> Next_i
    Check_A1 -- No --> Check_A2(i>=A2 and dp[i-A2]?)
    Check_A2 -- Yes --> Set_dp_T
    Check_A2 -- No --> ... --> Check_AN(i>=AN and dp[i-AN]?)
    Check_AN -- Yes --> Set_dp_T
    Check_AN -- No --> Next_i{i++}
    DP_Loop -- i > MaxSum --> Count(Count dp[i]==F for i>0)
    Count --> Output
```

### 3. 调试技巧

*   **检查 GCD:** 务必先正确计算 GCD 并处理 INF 情况。
*   **检查 DP 初始化:** 确保 `dp[0]` 正确设置，其余初始化为表示“不可达”的状态。
*   **检查 DP 边界:** `i >= num[j]` 的判断是否正确。
*   **检查 DP 上限:** `MAX_SUM` 是否足够大？如果太小，可能会漏掉一些本可凑出的数，导致计数偏大。如果过大，则浪费时间和空间。
*   **小数据测试:** 用简单的 `A` 数组（如 `[2, 3]`）手动推导 DP 过程并与代码运行结果对比。

## 七、复杂度分析

### 1. 时间复杂度

*   **GCD 计算:** 如果使用欧几里得算法，计算两个数的 GCD 是 \(O(\log(\min(a, b)))\)。计算 N 个数的 GCD 大约是 \(O(N \log(\max(A_i)))\)。
*   **DP 计算:**
    *   物品驱动：\(O(N \times \text{MaxSum})\)
    *   容量驱动（如原代码）：\(O(\text{MaxSum} \times N)\)
    *   改进后的容量驱动（带 `break`）：最好情况接近 \(O(\text{MaxSum})\)（如果总能很快找到一种凑法），最坏情况 \(O(\text{MaxSum} \times N)\)。
*   **统计:** \(O(\text{MaxSum})\)
*   **总体 (以原代码为准):** \(O(N \times \text{MaxSum})\)，其中 `MaxSum` 在原代码中是 `1e7`，这是一个非常大的值。如果使用更优化的上限（如 `10000`) 和显式 GCD 计算，复杂度会显著降低。

### 2. 空间复杂度

*   **DP 数组:** \(O(\text{MaxSum})\)。原代码是 \(O(10^7)\)，改进后可以是 \(O(10^4)\) 或 \(O(10^5)\)。

### 3. 优化空间

*   **时间优化:**
    *   显式计算 GCD 避免不必要的 DP。
    *   选择更紧凑的 `MaxSum` 上限。
    *   如果 `Ai` 都比较小，可以使用 `bitset` 优化 DP 状态转移，将内层循环或状态压缩，但对于 `Ai <= 100` 可能效果不明显。
*   **空间优化:**
    *   如果仅需判断某个数是否可达，可以使用滚动数组优化空间至 \(O(\max(A_i))\)。但本题需要统计所有不可达数，难以用滚动数组。
    *   使用 `vector<bool>` 或 `bitset` 代替 `int[]` 或 `vector<int>` 可以节省空间。

## 八、常见错误

### 1. 代码错误

```cpp
// 错误1：忘记初始化 dp[0]
bool dp[MAX_SUM + 1]; // 全是 false 或随机值
// ... DP 循环 ...  // 结果全错

// 错误2：DP 上限过小
const int MAX_SUM = 100; // 比如 Ai 有 99
std::vector<bool> dp(MAX_SUM + 1, false);
dp[0] = true;
// ... DP ...
// 统计时只到 100，会漏掉 100 之后可能无法凑出的数（虽然 gcd=1 时这种情况有限）

// 错误3：原代码的 INF 判断方式
if (des > 10000) { cout << "INF"; } // 不可靠，GCD=1 但不可凑出数 > 10000 是可能的（虽然罕见），GCD>1 但不可凑出数 <= 10000 也是可能的（如果 g 很大且 N=1e7 范围内 g 的倍数很密集）
```

### 2. 思路错误

*   **忽略 GCD > 1 的情况：** 直接进行 DP 并统计，对于 INF 情况会得到一个很大的错误数字。
*   **错误理解完全背包:** 误用 0-1 背包的 DP 写法（例如 `for i` 从大到小循环）。
*   **DP 上限选择不当:** 无法确定一个绝对安全的上限，只能选择一个相对足够大的值。

### 3. 调试建议

*   **分离 GCD 和 DP:** 先确保 GCD 计算正确。
*   **打印 DP 状态:** 对于小范围 `i`，打印 `dp[i]` 的值，检查是否符合预期。
*   **测试特殊用例:** `A=[4, 6]` (INF), `A=[2, 3]` (所有 > 1 的数都可达), `A=[7]` (INF)。

## 九、扩展思考

### 1. 题目变形

*   **求最大不能凑出的数:** 这是经典的 Frobenius Coin Problem。对于 N=2，有公式 `A1*A2 - A1 - A2`。对于 N>2，没有简单公式，但可以用 DP 找到。找到第一个使得 `dp[i]` 到 `dp[i + min(A)-1]` 都为 `true` 的 `i`，那么 `i-1` 就是最大不能凑出的数。
*   **求凑出某个数 X 的最少物品数:** 这是经典的 Coin Change 问题 (LeetCode 322)，DP 状态变为 `dp[i]` = 凑出 `i` 所需的最少物品数。
*   **求凑出某个数 X 的方案数:** DP 状态变为 `dp[i]` = 凑出 `i` 的方案数。转移变为 `dp[i] += dp[i - Aj]`。需要注意内外循环顺序影响组合还是排列。

### 2. 面试相关

*   **时间/空间复杂度分析:** 面试官常问。
*   **优化:** 如何优化 DP 的上限？如何处理 INF 情况？
*   **DP 状态设计:** 为什么这样设计 DP 状态？有无其他设计？
*   **边界条件:** `dp[0]` 的意义？循环的起止点？

### 3. 实战技巧

*   **模板化:** 掌握完全背包问题的标准 DP 模板。
*   **GCD 工具:** 准备好 GCD 的函数。
*   **上限估计:** 学会根据数据范围估计 DP 数组大小。

## 十、相关题目

### 1. 类似题目

1.  [LeetCode 322. Coin Change](https://leetcode.cn/problems/coin-change/) - 求凑成目标金额所需的最少硬币数。
2.  [LeetCode 518. Coin Change 2](https://leetcode.cn/problems/coin-change-ii/) - 求凑成目标金额的方案数。
3.  [LeetCode 279. Perfect Squares](https://leetcode.cn/problems/perfect-squares/) - 求一个数表示为完全平方数之和的最少个数（类似完全背包）。

### 2. 推荐练习

*   **基础:** 完全背包九讲 (AcWing 等平台)。
*   **提高:** 涉及数论和 DP 结合的题目，如一些 ACM 竞赛题。
*   **综合:** 弗罗贝尼乌斯币问题的相关题目。
