# L1-009 N个数求和

## 一、前置知识

*   **数据类型**: `long long` 用于存储可能较大的分子和分母。
*   **最大公约数 (GCD)**: 用于分数的约分。C++ `<numeric>` 头文件（或 `<algorithm>` 在旧标准中）提供了 `std::gcd` 或 `__gcd` 函数。
*   **最小公倍数 (LCM)**: 用于分数加法时的通分。可以通过公式 `lcm(a, b) = (a * b) / gcd(a, b)` 计算。
*   **分数运算**:
    *   加法： `a/b + c/d = (ad + bc) / bd`，之后需要通分 `lcm(b, d)` 得到 `(a * (lcm/b) + c * (lcm/d)) / lcm`。
    *   约分：分子分母同时除以它们的最大公约数。
*   **带分数表示**: 将假分数（分子大于或等于分母）表示为 `整数部分 分子/分母` 的形式。

## 二、题目分析

### 1. 题目描述

*   **题目链接**: [L1-009 N个数求和](https://pintia.cn/problem-sets/994805046380707840/exam/problems/994805133597065216)
*   **本地链接**: [L1-009-N个数求和.cpp](../Algorithm/PTA/L1-009-N%E4%B8%AA%E6%95%B0%E6%B1%82%E5%92%8C.cpp)
*   **难度级别**: 基础
*   **相关标签**: 数学, 分数运算, GCD

### 2. 题目要求

*   **输入格式**:
    *   第一行：一个正整数 N (N ≤ 100)。
    *   第二行：N 个有理数，格式为 `a1/b1 a2/b2 ... an/bn`。分子和分母都在 `long long` 范围内，负号只出现在分子前，分母不为0。
*   **输出要求**:
    *   输出 N 个有理数的和，以最简分数形式 `整数部分 分数部分` 输出。
    *   如果整数部分为 0，则只输出分数部分。
    *   如果分数部分为 0，则只输出整数部分。
    *   如果结果为 0，则输出 0。
    *   分数部分必须是真分数（分子小于分母），且分子分母没有公因子（除了1）。
*   **时间/空间限制**: 标准限制。

### 3. 关键概念

*   **有理数**: 可以表示为两个整数之比的数（即分数）。
*   **最简分数**: 分子和分母互质（最大公约数为1）的分数。
*   **带分数**: 由整数部分和真分数部分组成的分数表示形式。
*   **通分**: 将分母不同的分数化为分母相同的分数。
*   **约分**: 将分数的分子和分母同时除以它们的最大公约数，得到最简分数。

## 三、示例分析

### 1. 基本示例

```
输入：
5
2/5 4/15 1/30 -2/60 8/3
输出：
3 1/3
解释：
2/5 + 4/15 + 1/30 + (-2/60) + 8/3
= 2/5 + 4/15 + 1/30 - 1/30 + 8/3
= 2/5 + 4/15 + 8/3
通分（分母为15）：
= 6/15 + 4/15 + 40/15
= (6 + 4 + 40) / 15
= 50 / 15
约分（GCD(50, 15) = 5）：
= (50/5) / (15/5)
= 10 / 3
化为带分数：
= 3 余 1
= 3 1/3
```

### 2. 特殊情况 (结果为整数)

```
输入：
2
4/3 2/3
输出：
2
分析：
4/3 + 2/3 = (4+2)/3 = 6/3
约分（GCD(6, 3) = 3）：
= (6/3) / (3/3)
= 2 / 1 = 2
整数部分为2，分数部分为0，只输出整数部分。
```

### 3. 特殊情况 (结果为纯真分数)

```
输入：
3
1/3 -1/6 1/8
输出：
7/24
说明：
1/3 + (-1/6) + 1/8
= 1/3 - 1/6 + 1/8
通分（LCM(3, 6, 8) = 24）：
= (1 * 8)/24 - (1 * 4)/24 + (1 * 3)/24
= (8 - 4 + 3) / 24
= 7 / 24
约分（GCD(7, 24) = 1）：已经是
最简分数。
结果是真分数（7 < 24），整数部分为0，只输出分数部分。
```

## 四、解题思路

### 1. 问题分析

*   **本质**: 模拟分数的累加运算，并按要求格式化输出最终结果。
*   **核心**: 如何正确地进行分数加法并保持结果为最简形式。
*   **挑战**: 处理 `long long` 范围内的运算，避免中间过程溢出；正确处理负数；最终输出格式的判断。

### 2. 算法设计

*   **核心算法**: 迭代累加。
*   **数据结构**: 使用两个 `long long` 变量 `sum_x` 和 `sum_y` 分别存储当前累加和的分子和分母。初始时 `sum_x = 0`, `sum_y = 1` (表示和为 0/1 = 0)。
*   **优化思路**: 每进行一次加法运算后，立即对结果进行约分，可以有效防止分子分母变得过大，降低溢出的风险。

### 3. 解题步骤

1.  **初始化**: 定义 `long long sum_x = 0, sum_y = 1;` 用于存储累加结果。
2.  **读取N**: 读取需要相加的分数个数 `N`。
3.  **循环处理**: 循环 `N` 次，每次读取一个分数 `a/b`。
    a.  **计算LCM**: 计算当前分母 `sum_y` 和新分数分母 `b` 的最小公倍数 `lcm = (sum_y * b) / gcd(sum_y, b)`。
        *   **注意**: 直接 `sum_y * b` 可能溢出，但因为题目保证分子分母在 `long long` 范围内，最终和以及中间步骤通常也在 `long long` 内，这里直接乘通常没问题。更保险的做法是 `lcm = (sum_y / gcd(sum_y, b)) * b`。
    b.  **通分相加**: 更新分子 `sum_x = sum_x * (lcm / sum_y) + a * (lcm / b);`。
    c.  **更新分母**: 更新分母 `sum_y = lcm;`。
    d.  **约分**: 计算新的分子 `sum_x` 和分母 `sum_y` 的最大公约数 `g = gcd(abs(sum_x), sum_y)`。
        *   **注意**: 求 GCD 时分子需要取绝对值，因为负号只应保留在分子上。分母始终为正。
    e.  **执行约分**: `sum_x /= g; sum_y /= g;`。
4.  **格式化输出**: 循环结束后，根据 `sum_x` 和 `sum_y` 的值判断输出格式。
    a.  **结果为0**: 如果 `sum_x == 0`，输出 "0"。
    b.  **结果为纯分数**: 如果 `abs(sum_x) < sum_y`，输出 `sum_x/sum_y`。
    c.  **结果包含整数部分**: 如果 `abs(sum_x) >= sum_y`：
        i.  计算整数部分 `integer = sum_x / sum_y`。
        ii. 计算新的分子（余数） `sum_x = abs(sum_x) % sum_y`。
        iii. 如果新分子 `sum_x == 0`（即结果为纯整数），输出 `integer`。
        iv. 否则（结果为带分数），输出 `integer sum_x/sum_y`。

## 五、代码实现

### 1. 完整代码

```cpp
#include <iostream>
#include <numeric> // C++17 for std::gcd, or use <algorithm> for __gcd
#include <cmath>   // For std::abs

// 定义一个计算最大公约数的函数 (如果环境不支持 std::gcd 或 __gcd)
/*
long long gcd(long long a, long long b) {
    return b == 0 ? a : gcd(b, a % b);
}
*/

// 定义一个计算最小公倍数的辅助函数（可选，可以直接在主逻辑中计算）
/*
long long lcm(long long a, long long b) {
    if (a == 0 || b == 0) return 0;
    // 使用 std::gcd (C++17) 或 __gcd (GNU extension)
    long long common_divisor = std::gcd(std::abs(a), std::abs(b)); // C++17
    // long long common_divisor = __gcd(std::abs(a), std::abs(b)); // GCC/Clang
    // 为了防止溢出，先除后乘
    return (std::abs(a) / common_divisor) * std::abs(b);
}
*/

int main()
{
    int n;  // 定义整数n，表示要输入的分数个数
    cin >> n;  // 从标准输入读取分数个数n
    long long x = 0, y = 1;  // 初始化结果分数，x为分子，y为分母，初始值为0/1
    
    // 循环处理每个分数
    while (n--)
    {
        long long a, b;  // 定义当前分数的分子a和分母b
        char s;  // 定义字符s用于读取分数中的斜杠'/'
        cin >> a >> s >> b;  // 读取分数，格式为"分子/分母"
        
        // 计算当前分母和结果分母的最小公倍数
        long long lcm = (y * b) / __gcd(y, b);
        // 将两个分数转换为相同分母并相加
        x = x * (lcm / y) + a * (lcm / b);
        y = lcm;  // 更新结果分母为最小公倍数

        // 对结果分数进行约分
        long long g = __gcd(abs(x), y);  // 计算分子分母的最大公约数
        x /= g;  // 约分分子
        y /= g;  // 约分分母
    }
    
    // 处理最终结果输出
    if (x == 0)  // 如果分子为0
    {
        cout << "0" << endl;  // 直接输出0
    }
    else if (abs(x) < y)  // 如果分子绝对值小于分母（真分数）
    {
        cout << x << "/" << y << endl;  // 输出分数形式
    }
    else  // 如果分子绝对值大于等于分母（假分数）
    {
        long long integer = x / y;  // 计算整数部分
        x = abs(x) % y;  // 计算剩余分数部分的分子
        if (x == 0)  // 如果分数部分为0
        {
            cout << integer << endl;  // 只输出整数部分
        }
        else  // 如果还有分数部分
        {
            cout << integer << " " << x << "/" << y << endl;  // 输出带分数形式
        }
    }

    return 0;  // 程序正常结束
}
```

### 2. 关键代码段分析

*   **最大公约数和最小公倍数计算**:
    ```cpp
    // 使用 std::gcd (C++17) 或 __gcd (GNU 扩展)
    long long g = std::gcd(y, b); // C++17
    // long long g = __gcd(y, b); // GCC/Clang
    long long lcm = (y / g) * b; // 计算最小公倍数，避免溢出
    ```
    这里我们使用公式 `lcm(a, b) = (a / gcd(a, b)) * b` 来计算最小公倍数，这样可以减少中间结果的大小，降低溢出风险。

*   **通分加法**:
    ```cpp
    x = x * (lcm / y) + a * (lcm / b);
    y = lcm;
    ```
    将两个分数 `x/y` 和 `a/b` 转换为相同分母 `lcm`，然后进行分子相加。

*   **约分处理**:
    ```cpp
    if (x == 0) {
        y = 1;
    } else {
        long long g = std::gcd(std::abs(x), y); // 取分子的绝对值
        x /= g;
        y /= g;
    }
    ```
    每次加法后都进行约分，保持分数最简形式，防止数值过大。特别处理了分子为0的情况。

*   **输出格式处理**:
    ```cpp
    if (std::abs(x) >= y) { // 判断是否有整数部分
        long long integer = x / y;
        long long remainder_x = std::abs(x) % y;
        std::cout << integer;
        if (remainder_x != 0) {
            std::cout << " " << remainder_x << "/" << y;
        }
        std::cout << std::endl;
    } else { // 纯真分数
        std::cout << x << "/" << y << std::endl;
    }
    ```
    这是处理输出的核心逻辑，区分纯整数、带分数和纯真分数。

### 3. 代码优化

对于此题，上述实现已经足够高效且健壮。主要的优化在于每次加法后及时约分，避免数值膨胀。进一步的优化可能涉及手写更快的 GCD 算法（如二进制 GCD），但对于 `long long` 范围和 N=100 的约束，标准库的 `gcd` 性能足够。

## 六、模拟代码过程

### 1. 执行流程 (以示例1为例)

输入：
```
5
2/5 4/15 1/30 -2/60 8/3
```

*   **初始化**: `sum_x = 0`, `sum_y = 1` (表示 0)
*   **第1次 (读 2/5)**:
    *   `a=2, b=5`
    *   `gcd(1, 5) = 1`
    *   `lcm = (1 / 1) * 5 = 5`
    *   `sum_x = 0 * (5/1) + 2 * (5/5) = 2`
    *   `sum_y = 5`
    *   `g = gcd(abs(2), 5) = 1` (无需约分)
    *   结果: `sum_x = 2`, `sum_y = 5` (表示 2/5)
*   **第2次 (读 4/15)**:
    *   `a=4, b=15`
    *   `gcd(5, 15) = 5`
    *   `lcm = (5 / 5) * 15 = 15`
    *   `sum_x = 2 * (15/5) + 4 * (15/15) = 2 * 3 + 4 * 1 = 6 + 4 = 10`
    *   `sum_y = 15`
    *   `g = gcd(abs(10), 15) = 5`
    *   `sum_x = 10 / 5 = 2`
    *   `sum_y = 15 / 5 = 3`
    *   结果: `sum_x = 2`, `sum_y = 3` (表示 2/3)
*   **第3次 (读 1/30)**:
    *   `a=1, b=30`
    *   `gcd(3, 30) = 3`
    *   `lcm = (3 / 3) * 30 = 30`
    *   `sum_x = 2 * (30/3) + 1 * (30/30) = 2 * 10 + 1 * 1 = 20 + 1 = 21`
    *   `sum_y = 30`
    *   `g = gcd(abs(21), 30) = 3`
    *   `sum_x = 21 / 3 = 7`
    *   `sum_y = 30 / 3 = 10`
    *   结果: `sum_x = 7`, `sum_y = 10` (表示 7/10)
*   **第4次 (读 -2/60)**:
    *   `a=-2, b=60`
    *   `gcd(10, 60) = 10`
    *   `lcm = (10 / 10) * 60 = 60`
    *   `sum_x = 7 * (60/10) + (-2) * (60/60) = 7 * 6 - 2 * 1 = 42 - 2 = 40`
    *   `sum_y = 60`
    *   `g = gcd(abs(40), 60) = 20`
    *   `sum_x = 40 / 20 = 2`
    *   `sum_y = 60 / 20 = 3`
    *   结果: `sum_x = 2`, `sum_y = 3` (表示 2/3)
*   **第5次 (读 8/3)**:
    *   `a=8, b=3`
    *   `gcd(3, 3) = 3`
    *   `lcm = (3 / 3) * 3 = 3`
    *   `sum_x = 2 * (3/3) + 8 * (3/3) = 2 * 1 + 8 * 1 = 2 + 8 = 10`
    *   `sum_y = 3`
    *   `g = gcd(abs(10), 3) = 1` (无需约分)
    *   结果: `sum_x = 10`, `sum_y = 3` (表示 10/3)
*   **输出**:
    *   `abs(10) >= 3`，有整数部分。
    *   `integer_part = 10 / 3 = 3`
    *   `remainder_x = abs(10) % 3 = 1`
    *   `remainder_x != 0`
    *   输出 `3 1/3`

### 2. 图示说明

```mermaid
graph TD
    A[开始 sum_x=0, sum_y=1] --> B{读取 a/b};
    B --> C[计算 lcm = (sum_y/gcd(sum_y,b))*b];
    C --> D[计算 sum_x = sum_x*(lcm/sum_y) + a*(lcm/b)];
    D --> E[设置 sum_y = lcm];
    E --> F[计算 g = gcd(abs(sum_x), sum_y)];
    F --> G[约分 sum_x /= g, sum_y /= g];
    G --> H{所有数都读完了?};
    H -- 否 --> B;
    H -- 是 --> I[格式化输出结果];
    I --> J[结束];
```

### 3. 调试技巧

*   **中间值打印**: 在每次约分后打印 `sum_x` 和 `sum_y` 的值，检查计算过程是否正确。
*   **GCD/LCM验证**: 单独测试 GCD 和 LCM 的计算逻辑是否正确，特别是处理负数和0的情况。
*   **边界测试**: 使用结果为0、整数、负数、包含大数值的输入进行测试。
*   **格式化逻辑**: 单独测试最后输出部分的代码，确保各种情况（0、整数、带分数、真分数）都能正确处理。

## 七、复杂度分析

### 1. 时间复杂度

*   主要耗时在循环内的 GCD 计算。`std::gcd` 或 `__gcd` 通常使用欧几里得算法，其复杂度约为 O(log(min(a, b)))。
*   循环执行 N 次。
*   假设分数的分母最大值 M，则单次 GCD 复杂度可近似为 O(log M)。
*   **总体时间复杂度**: O(N * log M)。由于 M 在 `long long` 范围内，log M 是一个相对较小的常数，复杂度接近 O(N)。

### 2. 空间复杂度

*   只使用了固定数量的 `long long` 变量来存储中间结果和输入。
*   **总体空间复杂度**: O(1)。

### 3. 优化空间

*   对于本题的限制，O(N * log M) 或近似 O(N) 的时间复杂度已经足够。
*   空间复杂度 O(1) 已经是最小。
*   主要优化点是防止溢出和保证计算正确性，而不是追求极致的速度。

## 八、常见错误

### 1. 代码错误

```cpp
// 错误代码: LCM 计算可能溢出
long long common_multiple = (sum_y * b) / common_divisor; 
// 修正方法: 先除后乘
long long common_multiple = (sum_y / common_divisor) * b; 

// 错误代码: GCD 未处理负数
long long g = std::gcd(sum_x, sum_y);
// 修正方法: 对分子取绝对值
long long g = std::gcd(std::abs(sum_x), sum_y);

// 错误代码: 输出格式处理不全或错误
// (例如，没有正确处理纯整数或纯分数的情况)
// 修正方法: 仔细检查输出部分的 if-else 逻辑
```

### 2. 思路错误

*   **忘记约分**: 每次加法后不约分，可能导致中间值溢出 `long long`。
*   **约分不彻底**: 没有使用最大公约数约分。
*   **输出格式混淆**: 未能正确区分带分数、真分数、整数和0的输出要求。
*   **整数部分提取错误**: 在提取整数部分后，未正确计算剩余的分数部分（特别是负数情况）。

### 3. 调试建议

*   **构造测试用例**:
    *   全正数，有正有负。
    *   结果为0，正整数，负整数，正带分数，负带分数，正真分数，负真分数。
    *   包含大数值的分数。
    *   特殊分母（如1）。
*   **逐步验证**: 先确保单个分数加法和约分正确，再验证累加过程。最后检查输出格式。

## 九、扩展思考

### 1. 题目变形

*   **大数运算**: 如果分子分母超出 `long long` 范围，需要实现大数类或高精度分数类。
*   **其他运算**: 实现分数的乘法、除法。
*   **比较大小**: 实现分数比较函数。

### 2. 面试相关

*   可能会被问到 GCD/LCM 的实现原理和复杂度。
*   可能会被问到如何处理溢出问题。
*   可能会要求实现一个完整的分数类（Fraction Class）。

### 3. 实战技巧

*   封装分数运算逻辑：可以将分数表示为一个结构体或类，并重载 `+`, `-`, `*`, `/` 等运算符，使代码更清晰。
*   利用好标准库函数：`std::gcd` 是处理这类问题的利器。

## 十、相关题目

### 1. 类似题目

*   涉及分数计算、GCD/LCM 应用的题目。可以在 PTA 或 LeetCode 上搜索 "fraction", "rational number", "gcd" 等关键词。

### 2. 推荐练习

*   实现一个完整的分数类，支持加减乘除和比较运算。
*   解决需要处理大数分数的题目。
