# L1-054 福到了

## 一、前置知识

*   **基本C++输入输出**：`cin`, `cout`, `getline`。
*   **`std::vector`容器**：用于动态存储字符串（矩阵的行）。
*   **`std::string`类**：用于存储和操作每一行的字符。
*   **二维数组/矩阵概念**：理解如何通过 `vector<string>` 模拟二维字符矩阵。
*   **循环结构**：`for` 循环用于遍历矩阵。
*   **条件判断**：`if` 语句用于处理对称情况。

## 二、题目分析

### 1. 题目描述

*   **题目链接**：[PTA L1-054 福到了](https://pintia.cn/problem-sets/994805046380707840/problems/994805068250374144) (假设链接，请以实际为准)
*   **本地链接**：[L1-054-福到了.cpp](Algorithm/PTA/L1-054-福到了.cpp)
*   **难度级别**：L1 (入门级)
*   **相关标签**：字符串处理，二维数组模拟，图形旋转，模拟

### 2. 题目要求

*   **输入格式**：
    *   第一行包含一个字符 `C` 和一个正整数 `N` ( \(N \le 100\) )，用空格隔开。`C` 是用于替换 `@` 的字符。
    *   接下来 `N` 行，每行包含 `N` 个字符（`@` 或空格），构成一个 `N x N` 的字符矩阵。
*   **输出要求**：
    *   首先，将输入矩阵中的所有 `@` 字符替换为字符 `C`。
    *   然后，将替换后的矩阵旋转180度得到最终矩阵。
    *   **特殊情况**：如果在旋转前（仅替换 `@` 后）的矩阵与旋转180度后的矩阵完全相同，则需要在输出最终矩阵之前，先单独输出一行 "bu yong dao le"。
    *   最后，输出旋转180度后的 `N x N` 矩阵。
*   **时间/空间限制**：通常 PTA L1 题目的限制比较宽松，O(N^2) 的时间和空间复杂度都可以接受。

### 3. 关键概念

*   **字符替换**：将矩阵中的特定字符 `@` 更换为输入指定的字符 `C`。
*   **180度旋转**：将矩阵上下颠倒并且左右翻转。原始位置 `(i, j)` 的元素会移动到新位置 `(N-1-i, N-1-j)`。
*   **对称判断**：判断仅替换 `@` 后的矩阵与其旋转180度后的矩阵是否完全一致。
*   **带空格的行输入**：需要使用 `getline` 来读取包含空格的整行字符串。

## 三、示例分析

### 1. 基本示例

```
输入：
$ 9
 @  @@@@@
@@@  @@@
 @   @ @
@@@  @@@
@@@ @@@@@
@@@ @ @ @
@@@ @@@@@
 @  @ @ @
 @  @@@@@

替换'@'为'$'后 (我们称之为 矩阵B):
 $  $$$$$
 $$$  $$$
  $   $ $
 $$$  $$$
 $$$ $$$$$
 $$$ $ $ $
 $$$ $$$$$
  $  $ $ $
  $  $$$$$

旋转180度后 (我们称之为 矩阵C):
 $$$$$  $
 $ $ $  $
 $$$$$ $$$
 $ $ $ $$$
 $$$$$ $$$
  $$$  $$$
  $ $   $
  $$$  $$$
 $$$$$  $

比较: 矩阵B 和 矩阵C 不相同。

输出：
$$$$$  $
$ $ $  $
$$$$$ $$$
$ $ $ $$$
$$$$$ $$$
 $$$  $$$
 $ $   $
 $$$  $$$
$$$$$  $

解释：
```
将输入的 `@` 字符替换为 `$`，并将整个图形旋转180度（上下颠倒，左右翻转）。由于旋转前后图形不同，直接输出旋转后的结果。

### 2. 特殊情况 (对称)

```
输入：
& 3
@@@
 @
@@@

替换'@'为'&'后 (矩阵B):
&&&
 &
&&&

旋转180度后 (矩阵C):
&&&
 &
&&&

比较: 矩阵B 和 矩阵C 完全相同。

输出：
bu yong dao le
&&&
 &
&&&

解释：
```
将 `@` 替换为 `&` 后，得到的 3x3 矩阵是中心对称的。旋转180度后图形不变。因此，先输出提示信息 "bu yong dao le"，再输出旋转（其实未变）后的图形。

### 3. 边界测试

*   **N=1**: 输入 `@`，替换为 `C`，旋转后还是 `C`。属于对称情况。
*   **全空格**: 输入全空格矩阵，替换后不变，旋转后不变。属于对称情况。
*   **全@**: 输入全 `@` 矩阵，替换为 `C`，旋转后不变。属于对称情况。

## 四、解题思路

### 1. 问题分析

*   **问题的本质**：对二维字符矩阵进行操作，包括元素替换、几何变换（旋转）和内容比较。
*   **可能的解决方案**：
    1.  使用二维数组 `char grid[N][N]`：需要处理动态大小或使用足够大的静态数组，处理空格输入稍麻烦。
    2.  使用 `vector<string>`：更灵活，`getline` 可以方便处理带空格的行，易于比较。这是更推荐的方式。
*   **方案的优劣比较**：`vector<string>` 在处理字符串和动态大小方面更具优势，代码更简洁。

### 2. 算法设计

*   **核心算法选择**：
    *   **读取**：使用 `cin` 读取字符 `C` 和整数 `N`，然后使用 `getline` 循环读取 `N` 行字符串。注意 `cin` 后 `getline` 前要处理换行符。
    *   **替换**：直接在存储的 `vector<string>` 上进行双重循环遍历，找到 `@` 并替换。
    *   **旋转**：创建**新的** `vector<string>` 来存储旋转结果。遍历原矩阵（替换后），根据 `(i, j) -> (N-1-i, N-1-j)` 的映射关系填充新矩阵。
    *   **比较**：`vector<string>` 可以直接使用 `==` 运算符进行比较。
*   **数据结构设计**：
    *   `vector<string> input_grid`：存储原始读入的矩阵。
    *   `vector<string> original_replaced_grid`：存储替换 `@` 后的矩阵（用于后续比较和旋转）。
    *   `vector<string> rotated_grid`：存储旋转180度后的最终结果矩阵。
*   **优化思路**：对于 L1 题目，通常 O(N^2) 的直接模拟就是最优思路，不需要特殊优化。

### 3. 解题步骤

1.  **读取输入**：读取替换字符 `C` 和大小 `N`。清除 `cin` 留下的换行符。
2.  **存储原始矩阵**：循环 `N` 次，使用 `getline` 将每行读入 `input_grid`。
3.  **创建并替换**：复制 `input_grid` 到 `original_replaced_grid`。遍历 `original_replaced_grid`，将 `@` 替换为 `C`。
4.  **创建并旋转**：创建新的 `rotated_grid`。遍历 `original_replaced_grid`，计算旋转后的坐标 `(N-1-i, N-1-j)`，并将 `original_replaced_grid[i][j]` 的字符放入 `rotated_grid` 的相应位置。
5.  **比较判断**：比较 `original_replaced_grid` 和 `rotated_grid` 是否相等。
6.  **条件输出**：如果相等，输出 "bu yong dao le"。
7.  **最终输出**：遍历 `rotated_grid`，逐行输出。

## 五、代码实现

### 1. 完整代码

```cpp
/*
 * @Author: RainbowRain9
 * @Date: 2025-04-09 17:39:07
 * @LastEditTime: 2025-04-09 19:34:45
 * @FilePath: \C++\Algorithm\PTA\L1-054-福到了.cpp
 * @Description: PTA L1-054 题解，实现字符替换和180度旋转
 */
#include <iostream>
#include <vector>
#include <string>
#include <algorithm> // 包含 vector 比较等所需的头文件

using namespace std;

/**
 * @brief 主函数，解决“福到了”问题
 * @details 读取N*N字符矩阵，替换'@'，旋转180度，并处理对称情况
 * @return int 程序退出状态码
 */
int main() {
    char replace_char; // 用于替换'@'的字符
    int n;             // 矩阵的维度 N x N
    cin >> replace_char >> n;
    // 清除 cin 读取 n 后缓冲区中残留的换行符
    // 否则第一个 getline 会读取一个空行
    cin.ignore();

    // 使用 vector<string> 存储输入的 N 行字符
    vector<string> original_grid(n);
    for (int i = 0; i < n; ++i) {
        // 读取一整行，包括空格
        getline(cin, original_grid[i]);
    }

    // 创建一个副本用于替换 '@'，保留原始输入（虽然本题没要求）
    // 同时这个副本将作为旋转前的状态用于比较
    vector<string> replaced_grid = original_grid;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            // 如果当前字符是 '@'，则替换为指定的字符
            if (replaced_grid[i][j] == '@') {
                replaced_grid[i][j] = replace_char;
            }
        }
    }

    // 创建一个新的 vector<string> 用于存储旋转 180 度后的结果
    // 初始化为 N 行，每行 N 个空格，避免后续访问越界
    vector<string> rotated_grid(n, string(n, ' '));
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            // 核心旋转逻辑：
            // 原矩阵中 (i, j) 位置的元素，旋转 180 度后
            // 移动到新矩阵的 (n - 1 - i, n - 1 - j) 位置
            rotated_grid[n - 1 - i][n - 1 - j] = replaced_grid[i][j];
        }
    }

    // 比较 替换后的矩阵(replaced_grid) 和 旋转后的矩阵(rotated_grid)
    // vector<string> 可以直接用 == 比较，它会逐个比较 string
    bool is_symmetric = (replaced_grid == rotated_grid);

    // 如果两个矩阵相同，说明原图（替换后）中心对称
    if (is_symmetric) {
        cout << "bu yong dao le" << endl;
    }

    // 输出最终旋转后的矩阵
    for (int i = 0; i < n; ++i) {
        cout << rotated_grid[i] << endl;
    }

    return 0; // 程序正常结束
}
```

### 2. 关键代码段解析

```cpp
// 1. 处理 cin 后 getline 的换行符问题
cin >> replace_char >> n;
cin.ignore(); // 非常重要，否则 getline 会出错

// 2. 读取带空格的行
getline(cin, original_grid[i]);

// 3. 180度旋转的核心逻辑
// 将 replaced_grid[i][j] 的值赋给 rotated_grid 的对应位置
rotated_grid[n - 1 - i][n - 1 - j] = replaced_grid[i][j];

// 4. 比较两个 vector<string> 是否完全相同
bool is_symmetric = (replaced_grid == rotated_grid);
```

### 3. 代码优化

*   对于此题，O(N^2) 的实现已经足够高效，空间复杂度也是必需的 O(N^2) 来存储矩阵。
*   可以略微优化空间：如果不需要保留原始输入 `original_grid`，可以直接在读入的 `vector<string>` 上进行替换，减少一次复制。但当前代码逻辑更清晰。
*   旋转操作也可以尝试原地进行，但会增加代码复杂度，需要巧妙地交换元素，对于 L1 题目不推荐。

## 六、模拟代码过程

### 1. 执行流程 (以示例1为例)

*   **输入数据准备**: `replace_char = '$'`, `n = 9`。`original_grid` 被填充为输入的 9x9 字符矩阵。
*   **替换步骤**: `replaced_grid` 初始化为 `original_grid` 的副本。双重循环遍历 `replaced_grid`，将所有 `@` 修改为 `$`。此时 `replaced_grid` 内容如下：
    ```
     $  $$$$$
     $$$  $$$
      $   $ $
     $$$  $$$
     $$$ $$$$$
     $$$ $ $ $
     $$$ $$$$$
      $  $ $ $
      $  $$$$$
    ```
*   **旋转步骤**: `rotated_grid` 初始化为 9x9 的空格矩阵。双重循环遍历 `replaced_grid`：
    *   当 `i=0, j=0` (`replaced_grid[0][0]` 是空格)，计算新坐标 `(9-1-0, 9-1-0) = (8, 8)`，所以 `rotated_grid[8][8] = ' '`。
    *   当 `i=0, j=1` (`replaced_grid[0][1]` 是空格)，计算新坐标 `(8, 7)`，`rotated_grid[8][7] = ' '`。
    *   当 `i=0, j=2` (`replaced_grid[0][2]` 是 '$')，计算新坐标 `(8, 6)`，`rotated_grid[8][6] = '$'`。
    *   ... 以此类推，直到遍历完所有 `i` 和 `j`。
*   **中间结果展示**: 旋转完成后，`rotated_grid` 内容如下：
    ```
     $$$$$  $
     $ $ $  $
     $$$$$ $$$
     $ $ $ $$$
     $$$$$ $$$
      $$$  $$$
      $ $   $
      $$$  $$$
     $$$$$  $
    ```
*   **比较步骤**: `is_symmetric = (replaced_grid == rotated_grid)` 计算结果为 `false`。
*   **输出步骤**: `if (is_symmetric)` 条件不满足，不输出 "bu yong dao le"。接着循环输出 `rotated_grid` 的每一行。

### 2. 图示说明 (旋转映射关系)

```
原始矩阵 (replaced_grid)    旋转后矩阵 (rotated_grid)
 (0,0)  -----------------> (N-1, N-1)
 (0,j)  -----------------> (N-1, N-1-j)
 (i,0)  -----------------> (N-1-i, N-1)
 (i,j)  -----------------> (N-1-i, N-1-j)
 (N-1,N-1) --------------> (0, 0)
```

### 3. 调试技巧

*   **分步验证**：
    *   先确保输入读取正确，可以临时加 `cout` 输出 `original_grid`。
    *   再验证替换是否正确，输出 `replaced_grid`。
    *   最后验证旋转逻辑，输出 `rotated_grid`。
*   **小规模测试**：用 N=2 或 N=3 的简单例子手动推导，对比程序输出。
*   **边界检查**：注意旋转公式 `n - 1 - i` 和 `n - 1 - j` 是否可能越界（在正确实现下不会）。
*   **换行符问题**：如果 `getline` 行为不符合预期，首先检查是否正确处理了 `cin` 后的换行符 (`cin.ignore()`)。

## 七、复杂度分析

### 1. 时间复杂度

*   **读取输入**：读取 `C` 和 `N` 是 O(1)。读取 `N` 行，每行 `N` 字符，使用 `getline` 大致是 O(N^2)。
*   **替换字符**：双重循环遍历 `N x N` 矩阵，O(N^2)。
*   **旋转矩阵**：双重循环遍历 `N x N` 矩阵，进行赋值，O(N^2)。
*   **比较矩阵**：`vector<string>` 的比较在最坏情况下需要比较所有 N*N 个字符，O(N^2)。
*   **输出结果**：双重循环（隐式在 `cout << string` 中）输出 N*N 个字符，O(N^2)。
*   **总体时间复杂度**：各项操作都是 O(N^2) 级别，所以总时间复杂度为 **O(N^2)**。

### 2. 空间复杂度

*   `original_grid`: 存储 N 行 N 列字符，O(N^2)。
*   `replaced_grid`: 同上，O(N^2)。
*   `rotated_grid`: 同上，O(N^2)。
*   其他变量：如 `i`, `j`, `n`, `replace_char`, `is_symmetric` 都是 O(1)。
*   **总体空间复杂度**：主要由存储矩阵的 `vector` 决定，为 **O(N^2)**。

### 3. 优化空间

*   **时间优化**：对于 O(N^2) 的操作，在 N<=100 的情况下已足够快，基本没有优化必要。
*   **空间优化**：可以省去 `original_grid` 的副本，直接在读入的 `vector` 上修改。如果允许原地旋转（不推荐，易出错），可以进一步减少一个 `vector` 的空间。但 O(N^2) 的空间对于存储结果是必需的。

## 八、常见错误

### 1. 代码错误

```cpp
// 错误代码 1: 忘记 cin.ignore()
cin >> replace_char >> n;
// cin.ignore(); // 忘记加这行
vector<string> original_grid(n);
for (int i = 0; i < n; ++i) {
    getline(cin, original_grid[i]); // 第一行的 getline 会读到空行
}
// 错误原因：cin 读取 n 后，换行符留在缓冲区，被第一个 getline 读取。
// 修正方法：添加 cin.ignore();

// 错误代码 2: 旋转逻辑下标错误
// rotated_grid[i][j] = replaced_grid[n - 1 - i][n - 1 - j]; // 赋值方向反了
// 错误原因：应该将原矩阵的元素放到新矩阵的旋转后位置。
// 修正方法：rotated_grid[n - 1 - i][n - 1 - j] = replaced_grid[i][j];

// 错误代码 3: 初始化 rotated_grid 时大小不足或未初始化
// vector<string> rotated_grid; // 未指定大小
// ... 循环中直接访问 rotated_grid[x][y] 会导致越界或段错误
// 修正方法：vector<string> rotated_grid(n, string(n, ' '));
```

### 2. 思路错误

*   **误认为旋转90度两次**：旋转180度不是简单地执行两次90度旋转（虽然结果相同），直接用 `(i, j) -> (N-1-i, N-1-j)` 的映射更直接。
*   **比较时机错误**：应该比较“替换后”的矩阵和“旋转后”的矩阵，而不是原始输入矩阵。
*   **原地旋转的混淆**：试图在同一个 `vector<string>` 中完成旋转，容易导致数据在被读取前就被覆盖。

### 3. 调试建议

*   **打印中间状态**：在替换后、旋转后打印矩阵内容，检查每一步是否符合预期。
*   **使用小 N 值**：用 N=2 或 N=3 的简单矩阵进行测试，方便手动验证。
*   **关注坐标变换**：仔细检查旋转公式 `(N-1-i, N-1-j)` 是否正确应用。

## 九、扩展思考

### 1. 题目变形

*   **旋转90度/270度**：修改坐标映射关系。90度顺时针：`(i, j) -> (j, N-1-i)`。
*   **矩阵翻转**：水平翻转 `(i, j) -> (i, N-1-j)`，垂直翻转 `(i, j) -> (N-1-i, j)`。
*   **不同替换规则**：例如，将空格替换为某个字符，`@` 替换为另一个。
*   **查找子矩阵/模式匹配**：在旋转后的矩阵中查找特定模式。

### 2. 面试相关

*   面试中可能会考察二维数组/矩阵的操作，旋转是常见题目。
*   可能会追问空间优化（原地旋转）。
*   可能会要求分析不同旋转角度的时间/空间复杂度。
*   代码的清晰度、边界处理能力也是考察点。

### 3. 实战技巧

*   熟练使用 `vector<string>` 处理二维字符问题。
*   掌握常见的矩阵变换（旋转、翻转）的坐标映射公式。
*   注意 `cin` 和 `getline` 混用时的换行符处理。

## 十、相关题目

### 1. 类似题目

*   **LeetCode 48. 旋转图像 (Rotate Image)**：原地顺时针旋转90度（更难，要求原地）。
*   **PTA L1-006 连续因子**：虽然不是矩阵题，但也是 L1 级别的基础编程题。
*   其他 PTA 或 LeetCode 上的涉及二维数组/矩阵模拟和操作的题目。

### 2. 推荐练习

*   **基础巩固**：练习更多 `vector<string>` 的输入输出和遍历操作。
*   **提高进阶**：尝试实现原地旋转90度。
*   **综合应用**：解决需要多种矩阵操作组合的问题。
