# L1-048 矩阵A乘以B

## 一、前置知识

-   **C++基础**:
    -   `std::vector`: 动态数组，特别是 `std::vector<std::vector<int>>` 用于表示二维矩阵。
    -   输入/输出流 (`std::cin`, `std::cout`)。
    -   循环结构 (`for` 循环)。
    -   基本算术运算。
-   **数据结构**:
    -   二维数组（或等效的 `vector` 嵌套）。
-   **数学概念**:
    -   矩阵的定义（行、列、元素）。
    -   矩阵乘法的定义和规则。
    -   矩阵乘法的前提条件：第一个矩阵的列数必须等于第二个矩阵的行数。

## 二、题目分析

### 1. 题目描述
-   **题目链接**：[PTA L1-048](https://pintia.cn/problem-sets/994805046380707840/problems/994805066839769088)
-   **本地链接**：[L1-048-矩阵A乘以B.cpp](../Algorithm/PTA/L1-048-矩阵A乘以B.cpp)
-   **难度级别**：入门 / 基础
-   **相关标签**：数组、矩阵、模拟

### 2. 题目要求
-   **输入格式**：
    1.  先输入矩阵 A 的行数 `Ra` 和列数 `Ca`。
    2.  接着输入 `Ra` 行，每行 `Ca` 个整数，代表矩阵 A 的元素。
    3.  然后输入矩阵 B 的行数 `Rb` 和列数 `Cb`。
    4.  接着输入 `Rb` 行，每行 `Cb` 个整数，代表矩阵 B 的元素。
    5.  整数间用空格分隔，行首尾无多余空格。
-   **输出要求**：
    1.  如果 `Ca` 不等于 `Rb`，输出 `Error: Ca != Rb` （其中 `Ca` 和 `Rb` 替换为实际值）。
    2.  如果 `Ca` 等于 `Rb`，则输出结果矩阵 C 的维度（`Ra` 行 `Cb` 列），然后按输入格式输出矩阵 C 的所有元素。
-   **时间/空间限制**：通常 PTA L1 题目限制较为宽松，但仍需注意避免过高复杂度。

### 3. 关键概念
-   **矩阵乘法**：结果矩阵 C 的维度为 `Ra x Cb`。C 中第 `i` 行第 `j` 列的元素 `C[i][j]` 等于 A 的第 `i` 行所有元素与 B 的第 `j` 列对应元素乘积之和：
    \[ C[i][j] = \sum_{k=0}^{Ca-1} A[i][k] \times B[k][j] \]
-   **规模匹配**：只有当矩阵 A 的列数 (`Ca`) 等于矩阵 B 的行数 (`Rb`) 时，两个矩阵才能相乘。

## 三、示例分析

### 1. 基本示例 (示例 1)
```
输入：
2 3       // A: 2行3列
1 2 3
4 5 6
3 4       // B: 3行4列
7 8 9 0
-1 -2 -3 -4
5 6 7 8
```
**分析**：
-   A 的列数 `Ca = 3`。
-   B 的行数 `Rb = 3`。
-   因为 `Ca == Rb`，可以相乘。
-   结果矩阵 C 的维度为 `Ra x Cb = 2 x 4`。
-   计算 `C[0][0]`: `A[0][0]*B[0][0] + A[0][1]*B[1][0] + A[0][2]*B[2][0]`
    `= 1*7 + 2*(-1) + 3*5 = 7 - 2 + 15 = 20`
-   计算 `C[0][1]`: `A[0][0]*B[0][1] + A[0][1]*B[1][1] + A[0][2]*B[2][1]`
    `= 1*8 + 2*(-2) + 3*6 = 8 - 4 + 18 = 22`
-   ... 以此类推计算所有 C 的元素 ...
-   计算 `C[1][3]`: `A[1][0]*B[0][3] + A[1][1]*B[1][3] + A[1][2]*B[2][3]`
    `= 4*0 + 5*(-4) + 6*8 = 0 - 20 + 48 = 28`
```
输出：
2 4
20 22 24 16
53 58 63 28
```

### 2. 特殊情况 (示例 2 - 无法相乘)
```
输入：
3 2       // A: 3行2列
38 26
43 -5
0 17
3 2       // B: 3行2列
-11 57
99 68
81 72
```
**分析**：
-   A 的列数 `Ca = 2`。
-   B 的行数 `Rb = 3`。
-   因为 `Ca != Rb` (2 != 3)，两个矩阵无法相乘。
```
输出：
Error: 2 != 3
```

### 3. 边界测试
-   **1x1 矩阵**: 输入两个 1x1 矩阵，检查是否能正确计算。
    ```
    输入：
    1 1
    5
    1 1
    6
    输出：
    1 1
    30
    ```
-   **行列数不同的情况**: 确保能处理非方阵的情况，如 1xN 乘以 Nx1 得到 1x1 矩阵。
    ```
    输入：
    1 3
    1 2 3
    3 1
    4
    5
    6
    输出：
    1 1
    32 // 1*4 + 2*5 + 3*6 = 4 + 10 + 18 = 32
    ```

## 四、解题思路

### 1. 问题分析
-   **问题的本质**：模拟矩阵乘法的数学定义，并处理不能相乘的特殊情况。
-   **可能的解决方案**：直接根据定义使用循环计算。对于非常大的矩阵可能有更高级的算法（如 Strassen），但在此题的约束下，标准算法足够。
-   **方案的优劣比较**：标准三重循环算法直观易懂，易于实现，复杂度在可接受范围内。

### 2. 算法设计
-   **核心算法选择**：标准矩阵乘法算法。
-   **数据结构设计**：使用 `std::vector<std::vector<int>>` 存储矩阵 A、B 和结果 C。
-   **优化思路**：对于本题的规模，基本的三重循环是标准且足够高效的，无需复杂优化。

### 3. 解题步骤
1.  **读取输入**:
    -   读取 `Ra`, `Ca`。
    -   创建矩阵 A (`Ra` 行 `Ca` 列)。
    -   循环读取 A 的元素。
    -   读取 `Rb`, `Cb`。
    -   创建矩阵 B (`Rb` 行 `Cb` 列)。
    -   循环读取 B 的元素。
2.  **检查兼容性**:
    -   判断 `Ca == Rb` 是否成立。
    -   若不成立，输出错误信息 `Error: Ca != Rb`，程序结束。
3.  **计算乘积 (若兼容)**:
    -   创建结果矩阵 C (`Ra` 行 `Cb` 列)，并初始化所有元素为 0。
    -   使用三层嵌套循环：
        -   外层循环 `i` 从 0 到 `Ra-1` (遍历 C 的行)。
        -   中层循环 `j` 从 0 到 `Cb-1` (遍历 C 的列)。
        -   内层循环 `k` 从 0 到 `Ca-1` (或 `Rb-1`，因为它们相等，用于累加求和)。
        -   在最内层执行 `C[i][j] += A[i][k] * B[k][j]`。
4.  **输出结果**:
    -   输出结果矩阵 C 的维度 `Ra` 和 `Cb`。
    -   使用两层嵌套循环按格式打印矩阵 C 的元素。

## 五、代码实现

### 1. 完整代码
```cpp
/*
 * @Author: RainbowRain9
 * @Date: 2025-04-08 23:08:59
 * @LastEditTime: 2025-04-09 13:16:52
 * @FilePath: \C++\Algorithm\PTA\L1-048-矩阵A乘以B.cpp
 * @Description: PTA L1-048 矩阵A乘以B 题解
 */

#include <iostream>
#include <vector>
#include <string> // 包含常用的头文件

// 使用标准命名空间
using namespace std;

/**
 * @brief 读取指定维度的矩阵
 * @param rows 矩阵行数
 * @param cols 矩阵列数
 * @return 读取到的矩阵 (vector<vector<int>>)
 */
vector<vector<int>> readMatrix(int rows, int cols) {
    // 创建一个 rows 行 cols 列的二维 vector，并初始化
    vector<vector<int>> matrix(rows, vector<int>(cols));
    // 嵌套循环读取每个元素
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            cin >> matrix[i][j];
        }
    }
    return matrix; // 返回读取好的矩阵
}

/**
 * @brief 输出矩阵
 * @param matrix 常量引用，要输出的矩阵
 */
void printMatrix(const vector<vector<int>>& matrix) {
    // 检查矩阵是否为空
    if (matrix.empty() || matrix[0].empty()) {
        return; // 空矩阵不进行任何输出
    }
    // 获取矩阵的行数和列数
    int rows = matrix.size();
    int cols = matrix[0].size();
    // 首先输出矩阵的维度
    cout << rows << " " << cols << endl;
    // 嵌套循环输出矩阵的每个元素
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            // 输出元素，如果是行末元素则不加空格，否则加空格
            cout << matrix[i][j] << (j == cols - 1 ? "" : " ");
        }
        cout << endl; // 每行结束后换行
    }
}

// 主函数
int main() {
    // 定义矩阵A和B的维度变量
    int Ra, Ca, Rb, Cb;

    // --- 读取矩阵 A ---
    cin >> Ra >> Ca; // 输入 A 的行数和列数
    vector<vector<int>> A = readMatrix(Ra, Ca); //调用函数读取 A 的元素

    // --- 读取矩阵 B ---
    cin >> Rb >> Cb; // 输入 B 的行数和列数
    vector<vector<int>> B = readMatrix(Rb, Cb); // 调用函数读取 B 的元素

    // --- 检查维度是否匹配 ---
    if (Ca != Rb) {
        // 如果 A 的列数不等于 B 的行数，则无法相乘
        cout << "Error: " << Ca << " != " << Rb << endl;
    } else {
        // --- 计算乘积矩阵 C ---
        // 创建结果矩阵 C，维度为 Ra x Cb，并初始化所有元素为 0
        vector<vector<int>> C(Ra, vector<int>(Cb, 0));

        // 使用三重循环计算矩阵乘积
        for (int i = 0; i < Ra; ++i) {       // 遍历 C 的行 (i)
            for (int j = 0; j < Cb; ++j) {   // 遍历 C 的列 (j)
                for (int k = 0; k < Ca; ++k) { // 内层循环，k 从 0 到 Ca-1 (或 Rb-1)
                    // 累加 A 的第 i 行第 k 列与 B 的第 k 行第 j 列的乘积
                    C[i][j] += A[i][k] * B[k][j];
                }
            }
        }

        // --- 输出结果矩阵 C ---
        printMatrix(C); // 调用函数输出结果矩阵
    }

    return 0; // 程序正常结束
}
```

### 2. 关键代码段解析
```cpp
// --- 计算乘积矩阵 C ---
// 创建结果矩阵 C，维度为 Ra x Cb，并初始化所有元素为 0
vector<vector<int>> C(Ra, vector<int>(Cb, 0));

// 使用三重循环计算矩阵乘积
for (int i = 0; i < Ra; ++i) {       // 1. 遍历结果矩阵 C 的每一行 (i)
    for (int j = 0; j < Cb; ++j) {   // 2. 遍历结果矩阵 C 的每一列 (j)
        // C[i][j] 初始化为 0 (在创建时已完成)
        for (int k = 0; k < Ca; ++k) { // 3. 遍历 A 的列 (k) / B 的行 (k)
            // 核心计算：累加 A 的第 i 行第 k 个元素 与 B 的第 k 行第 j 个元素的乘积
            // 这个累加过程实现了 Σ(A[i][k] * B[k][j])
            C[i][j] += A[i][k] * B[k][j];
        }
        // 当内层循环 (k) 结束后, C[i][j] 就计算完毕
    }
    // 当中层循环 (j) 结束后, C 的第 i 行就计算完毕
}
// 当外层循环 (i) 结束后, 整个矩阵 C 就计算完毕
```
这段代码是矩阵乘法的核心。理解三层循环的作用至关重要：`i` 和 `j` 定位结果矩阵 C 中的元素，`k` 则用于遍历 A 的行和 B 的列以完成点积的计算。

### 3. 代码优化
对于此题目的典型输入规模，上述标准实现已经足够高效。可能的微小优化（通常在竞赛中非必要）：
-   **循环顺序调整**：理论上调整 `i, j, k` 的循环顺序可能影响缓存命中率，如将 `k` 循环放在外层或中间层（`i,k,j` 或 `k,i,j`），但在 C++ 中，编译器优化往往能处理好，且 `i,j,k` 的顺序较为自然。
-   **并行化**：对于非常大的矩阵，可以使用多线程并行计算 C 的不同行或元素，但这超出了基础算法范畴。

## 六、模拟代码过程

以 **示例 1** 为例：
`A = {{1, 2, 3}, {4, 5, 6}}` (Ra=2, Ca=3)
`B = {{7, 8, 9, 0}, {-1, -2, -3, -4}, {5, 6, 7, 8}}` (Rb=3, Cb=4)

### 1. 执行流程
1.  读取 Ra=2, Ca=3。读取 A 的元素。
2.  读取 Rb=3, Cb=4。读取 B 的元素。
3.  检查 `Ca (3) == Rb (3)`。条件成立。
4.  创建 `C(2, 4)` 并初始化为 `{{0, 0, 0, 0}, {0, 0, 0, 0}}`。
5.  进入三重循环：
    -   `i = 0`:
        -   `j = 0`:
            -   `k = 0`: `C[0][0] = 0 + A[0][0]*B[0][0] = 0 + 1*7 = 7`
            -   `k = 1`: `C[0][0] = 7 + A[0][1]*B[1][0] = 7 + 2*(-1) = 5`
            -   `k = 2`: `C[0][0] = 5 + A[0][2]*B[2][0] = 5 + 3*5 = 20` (C[0][0] 计算完毕)
        -   `j = 1`:
            -   `k = 0`: `C[0][1] = 0 + A[0][0]*B[0][1] = 0 + 1*8 = 8`
            -   `k = 1`: `C[0][1] = 8 + A[0][1]*B[1][1] = 8 + 2*(-2) = 4`
            -   `k = 2`: `C[0][1] = 4 + A[0][2]*B[2][1] = 4 + 3*6 = 22` (C[0][1] 计算完毕)
        -   `j = 2`: ... 计算得到 `C[0][2] = 24`
        -   `j = 3`: ... 计算得到 `C[0][3] = 16`
    -   `i = 1`:
        -   `j = 0`: ... 计算得到 `C[1][0] = 53`
        -   `j = 1`: ... 计算得到 `C[1][1] = 58`
        -   `j = 2`: ... 计算得到 `C[1][2] = 63`
        -   `j = 3`: ... 计算得到 `C[1][3] = 28`
6.  三重循环结束。
7.  调用 `printMatrix(C)` 输出结果。

### 2. 图示说明 (简易流程)
```
[开始] -> [读 A(Ra, Ca)] -> [读 B(Rb, Cb)] -> [Ca == Rb?]
    |                                              | (是)
    | (否)                                         V
    V                                    [创建 C(Ra, Cb, 0)]
[输出 Error]                             |
    |                                    V
    |                      [循环 i=0..Ra-1] -> [循环 j=0..Cb-1] -> [循环 k=0..Ca-1]
    |                      ^                      ^                      |
    |                      | (i++)                | (j++)                V
    |                      |                      |          [C[i][j]+=A[i][k]*B[k][j]]
    |                      +----------------------+(k++)-----------------+
    |                                    | (j循环结束)
    |                                    | (i循环结束)
    |                                    V
    +------------------------------- [输出 C]
                                         |
                                         V
                                       [结束]
```

### 3. 调试技巧
-   **打印中间矩阵**: 在读取 A 和 B 后，可以调用 `printMatrix` 打印它们，确保读取正确。
-   **检查维度**: 在进行乘法前，手动打印 `Ca` 和 `Rb` 的值，确认是否符合预期。
-   **跟踪计算**: 在最内层循环 `k` 之后，可以临时加入 `cout << "C[" << i << "][" << j << "] = " << C[i][j] << endl;` 来观察每个元素的最终计算结果。对于更细致的跟踪，可以在 `+=` 语句前后打印值。
-   **小数据测试**: 用 1x2 和 2x1 这样的小矩阵手动计算结果，然后与程序输出对比。

## 七、复杂度分析

### 1. 时间复杂度
-   读取矩阵 A：O(Ra * Ca)
-   读取矩阵 B：O(Rb * Cb)
-   检查维度：O(1)
-   矩阵乘法（三重循环）：O(Ra * Cb * Ca) (因为 Rb == Ca)
-   输出矩阵 C：O(Ra * Cb)
-   **总体时间复杂度**：主要由矩阵乘法决定，为 **O(Ra * Ca * Cb)**。

### 2. 空间复杂度
-   存储矩阵 A：O(Ra * Ca)
-   存储矩阵 B：O(Rb * Cb)
-   存储结果矩阵 C：O(Ra * Cb)
-   **总体空间复杂度**：需要存储三个矩阵，为 **O(Ra*Ca + Rb*Cb + Ra*Cb)**。

### 3. 优化空间
-   **时间**：对于此问题规模，O(N^3) 级别的算法（N 代表矩阵大致维度）是标准的。更快的算法如 Strassen (约 O(N^2.8)) 存在，但常数因子大，实现复杂，通常在 N 非常大时才有优势。
-   **空间**：必须存储输入和输出矩阵，空间复杂度难以优化，除非有特殊性质（如稀疏矩阵）。

## 八、常见错误

### 1. 代码错误
```cpp
// 错误示例 1: 结果矩阵未初始化
vector<vector<int>> C(Ra, vector<int>(Cb)); // 没有初始化为 0
for (int i = 0; i < Ra; ++i) {
    for (int j = 0; j < Cb; ++j) {
        for (int k = 0; k < Ca; ++k) {
            C[i][j] += A[i][k] * B[k][j]; // 错误：累加到未定义的值上
        }
    }
}
// 修正： vector<vector<int>> C(Ra, vector<int>(Cb, 0));

// 错误示例 2: 循环边界错误
for (int k = 0; k < Cb; ++k) { // 错误：内层循环边界应为 Ca 或 Rb
    C[i][j] += A[i][k] * B[k][j]; // 可能导致数组越界
}
// 修正： for (int k = 0; k < Ca; ++k)

// 错误示例 3: 输出格式错误
cout << matrix[i][j]; // 缺少空格
// 修正： cout << matrix[i][j] << (j == cols - 1 ? "" : " ");
```

### 2. 思路错误
-   **忘记检查维度兼容性**：直接进行乘法计算，如果 `Ca != Rb` 会导致逻辑错误或运行时错误（如果实现依赖于 `Ca==Rb`）。
-   **结果矩阵维度错误**：将 C 的维度误设为 `Ra x Ca` 或 `Rb x Cb` 等。正确维度是 `Ra x Cb`。
-   **混淆行列**：在计算 `C[i][j]` 时，错误地使用了 A 的列或 B 的行进行外层循环。

### 3. 调试建议
-   **单元测试**：针对 `readMatrix`, `printMatrix` 和乘法逻辑本身编写简单的测试用例。
-   **边界条件优先**：测试 1x1, 1xN, Nx1 以及 `Ca != Rb` 的情况。
-   **对照检查**：使用在线矩阵计算器或手动计算小例子来验证程序结果。

## 九、扩展思考

### 1. 题目变形
-   **矩阵快速幂**：计算一个方阵 A 的 N 次幂 (A^N)。可以通过类似快速幂的算法，将 O(N*M^3) 优化到 O(logN * M^3)，其中 M 是矩阵维度。
-   **稀疏矩阵乘法**：如果矩阵中大部分元素是 0，使用特殊的数据结构（如三元组、十字链表）存储非零元素，可以大大降低计算和存储开销。
-   **矩阵链乘**：给定一系列矩阵，找到最佳的乘法顺序（加括号方式），使得总的计算量最小。这是一个动态规划问题。

### 2. 面试相关
-   **复杂度分析**：面试官几乎必问时间空间复杂度。
-   **优化讨论**：可能会问在大数据量下如何优化（并行计算、分布式计算、Strassen 算法概念）。
-   **代码风格**：关注代码的可读性、健壮性（如边界检查）。
-   **变种问题**：可能会引申到上述的矩阵快速幂或稀疏矩阵问题。

### 3. 实战技巧
-   **封装函数**：将矩阵读取、打印、乘法操作封装成独立的函数，提高代码复用性和可读性。
-   **模板化**：如果需要处理不同数据类型（如 `double`），可以将函数模板化。
-   **类封装**：可以设计一个 `Matrix` 类来封装矩阵数据和操作。

## 十、相关题目

### 1. 类似题目
1.  **矩阵加法/减法** (PTA/LeetCode)：比乘法简单，只需对应元素相加/减，前提是两个矩阵维度相同。
2.  **矩阵转置** (PTA/LeetCode)：将矩阵的行和列互换。 `A[i][j]` 变为 `A_transpose[j][i]`。
3.  **LeetCode 73. Set Matrix Zeroes**: 如果矩阵中一个元素为0，将其所在行和列的所有元素设为0。考察空间优化。
4.  **LeetCode 54. Spiral Matrix**: 按螺旋顺序遍历矩阵元素。

### 2. 推荐练习
-   **基础巩固题**：实现矩阵加法、减法、转置。
-   **提高进阶题**：LeetCode 上的中等矩阵题目，如旋转图像 (LeetCode 48)、搜索二维矩阵 (LeetCode 74, 240)。
-   **综合应用题**：结合图论（用邻接矩阵表示图）、动态规划（矩阵链乘）等。
