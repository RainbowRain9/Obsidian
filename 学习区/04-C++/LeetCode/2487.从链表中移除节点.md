# 2487.从链表中移除节点

## 一、前置知识
- 链表的基本操作
- 链表的反转
- 单调栈思想

## 二、题目分析

### 1. 题目描述
- 题目链接：[2487.从链表中移除节点](https://leetcode.cn/problems/remove-nodes-from-linked-list/description/)
- 本地链接：[2487-remove-nodes-from-linked-list.cpp](../Algorithm/LeetCode/All/2487-remove-nodes-from-linked-list.cpp)
- 难度级别：Medium
- 相关标签：链表、单调栈、递归

### 2. 题目要求
- 输入：一个链表的头节点head
- 输出：修改后的链表头节点
- 要求：移除每个右侧有更大数值的节点
- 限制：
  - 节点数目在[1, 10^5]内
  - 节点值在[1, 10^5]内

### 3. 关键概念
- 右侧更大值：对于任意节点，如果其右侧存在值更大的节点，则当前节点需要被移除
- 链表修改：需要在遍历过程中修改链表结构
- 保持相对顺序：移除节点后，其他节点的相对顺序不变

## 三、示例分析

### 1. 基本示例
```
输入：head = [5,2,13,3,8]
输出：[13,8]
解释：
- 5需要移除，因为右侧有13
- 2需要移除，因为右侧有13
- 13保留，右侧最大值是8
- 3需要移除，因为右侧有8
- 8保留，右侧没有更大的值
```

### 2. 特殊情况
```
输入：head = [1,1,1,1]
输出：[1,1,1,1]
解释：所有节点值相等，不需要移除任何节点
```

## 四、解题思路

### 1. 问题分析
- 核心问题是判断节点右侧是否存在更大值
- 直接遍历判断比较困难，因为需要看后面所有节点
- 可以考虑反转链表，从后向前处理

### 2. 算法设计
1. 反转链表，使得原来的"右侧"变为"左侧"
2. 遍历反转后的链表，保持递减性质
3. 再次反转链表，恢复原有顺序

### 3. 解题步骤
1. 第一次反转链表
   - 使用经典的反转链表算法
   - 记录新的头节点
2. 遍历并移除节点
   - 比较当前节点和下一节点的值
   - 如果当前值更大，移除下一节点
   - 否则移动到下一节点
3. 第二次反转链表
   - 恢复链表原有顺序
   - 返回最终结果

## 五、代码实现

### 1. 完整代码
```cpp
class Solution {
public:
    // 反转链表的辅助函数
    ListNode* reverseList(ListNode* head) {
        ListNode *pre = nullptr, *cur = head;
        while (cur) {
            ListNode *nxt = cur->next;  // 保存下一个节点
            cur->next = pre;            // 反转指针
            pre = cur;                  // 移动pre
            cur = nxt;                  // 移动cur
        }
        return pre;
    }

    ListNode* removeNodes(ListNode* head) {
        // 第一次反转
        head = reverseList(head);
        
        // 遍历并移除节点
        ListNode* cur = head;
        while (cur->next) {
            if (cur->val > cur->next->val) {
                // 当前节点值更大，移除下一个节点
                cur->next = cur->next->next;
            } else {
                // 当前节点值不大于下一节点，移动到下一个位置
                cur = cur->next;
            }
        }
        
        // 第二次反转，恢复顺序
        return reverseList(head);
    }
};
```

### 2. 关键代码段解析
```cpp
// 反转链表的核心操作
ListNode *nxt = cur->next;  // 保存下一节点，防止链表断开
cur->next = pre;            // 改变指针方向
pre = cur;                  // 更新前驱节点
cur = nxt;                  // 移动到下一节点

// 移除节点的判断
if (cur->val > cur->next->val) {
    cur->next = cur->next->next;  // 跳过下一节点
} else {
    cur = cur->next;              // 保留下一节点
}
```

## 六、模拟代码过程

### 1. 执行流程
以输入[5,2,13,3,8]为例：
```
原始链表：5 -> 2 -> 13 -> 3 -> 8

第一次反转后：8 -> 3 -> 13 -> 2 -> 5

移除节点过程：
1. 比较8和3：8>3，移除3
   8 -> 13 -> 2 -> 5
2. 比较8和13：8<13，保留，移动指针
3. 比较13和2：13>2，移除2
   8 -> 13 -> 5
4. 比较13和5：13>5，移除5
   8 -> 13

第二次反转后：13 -> 8
```

### 2. 图示说明
```
原始：5 -> 2 -> 13 -> 3 -> 8
反转：8 -> 3 -> 13 -> 2 -> 5
处理：8 -> 13
结果：13 -> 8
```

## 七、复杂度分析

### 1. 时间复杂度
- 反转链表：O(n)
- 遍历处理：O(n)
- 再次反转：O(n)
- 总体：O(n)

### 2. 空间复杂度
- 只使用常数额外空间
- 空间复杂度：O(1)

## 八、常见错误

### 1. 代码错误
```cpp
// 错误：忘记保存next指针
cur->next = pre;
pre = cur;
cur = cur->next;  // cur->next已经改变，会导致链表断开

// 正确：应该提前保存next
ListNode* nxt = cur->next;
cur->next = pre;
pre = cur;
cur = nxt;
```

### 2. 思路错误
- 试图直接从前向后处理
- 没有考虑到节点值相等的情况
- 忘记恢复链表原有顺序

## 九、扩展思考

### 1. 题目变形
- 如果要求保留右侧等值节点呢？
- 如果要求移除右侧小于等于的节点呢？
- 如果是双向链表如何处理？

### 2. 其他解法
- 可以使用递归方式解决
- 可以使用单调栈思想
- 可以使用数组辅助处理

## 十、相关题目

### 1. 类似题目
1. [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)
2. [402. 移掉K位数字](https://leetcode.cn/problems/remove-k-digits/)
3. [316. 去除重复字母](https://leetcode.cn/problems/remove-duplicate-letters/)

### 2. 推荐练习
- 链表反转相关题目
- 单调栈应用题目
- 链表节点删除题目
