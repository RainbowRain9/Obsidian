# 24.两两交换链表中的节点

## 一、前置知识
- 链表的基本概念和操作
- 指针的使用
- 虚拟头节点技巧
- 链表节点交换操作

## 二、题目分析

### 1. 题目描述
- 题目链接：[两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)
- 本地链接：[24-swap-nodes-in-pairs.cpp](../Algorithm/LeetCode/All/24-swap-nodes-in-pairs.cpp)
- 难度级别：中等
- 相关标签：链表、递归

### 2. 题目要求
- 输入：一个单链表
- 要求：两两交换相邻节点
- 限制：不能修改节点的值，只能修改节点的指向
- 返回：交换后的链表头节点

### 3. 关键概念
- 链表节点交换
- 指针操作
- 边界情况处理
- 虚拟头节点使用

## 三、示例分析

### 1. 基本示例
```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
图解：
1->2->3->4
变为
2->1->4->3
解释：
1和2交换，3和4交换
```

### 2. 特殊情况
```
输入：head = []
输出：[]
分析：空链表直接返回
```

### 3. 边界测试
```
输入：head = [1]
输出：[1]
说明：单个节点无需交换
```

## 四、解题思路

### 1. 问题分析
- 本质是链表节点的两两交换
- 需要同时操作多个相邻节点
- 要注意保持链表的连续性
- 需要处理链表长度的奇偶性

### 2. 算法设计
- 使用虚拟头节点简化操作
- 使用多个指针记录相关节点
- 逐对进行节点交换
- 更新指针位置

### 3. 解题步骤
1. 创建虚拟头节点
   - 简化头节点的处理
   - 统一操作流程
2. 遍历链表进行交换
   - 确保有两个节点可交换
   - 完成节点交换
   - 移动指针到下一对

## 五、代码实现

### 1. 完整代码
```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // 处理空链表或单节点链表
        if (!head || !head->next) {
            return head;
        }

        // 创建虚拟头节点
        ListNode dummy(0);
        dummy.next = head;
        ListNode* p = &dummy;

        // 遍历链表进行交换
        while (p->next && p->next->next) {
            // 保存需要交换的节点和后续节点
            ListNode* p1 = p->next;
            ListNode* p2 = p1->next;
            ListNode* p3 = p2->next;

            // 执行交换操作
            p1->next = p3;    // 第一个节点指向第三个节点
            p2->next = p1;    // 第二个节点指向第一个节点
            p->next = p2;     // 前驱节点指向第二个节点

            // 移动指针
            p = p1;
        }

        return dummy.next;
    }
};
```

### 2. 关键代码段解析
```cpp
// 节点交换的核心操作
ListNode* p1 = p->next;      // 第一个待交换节点
ListNode* p2 = p1->next;     // 第二个待交换节点
ListNode* p3 = p2->next;     // 后续节点

p1->next = p3;               // 重建节点连接
p2->next = p1;
p->next = p2;
```

### 3. 代码优化
```cpp
// 优化前：使用多个临时变量
ListNode* p1 = p->next;
ListNode* p2 = p1->next;
ListNode* p3 = p2->next;

// 优化后：直接操作
ListNode* temp = p->next->next;
p->next->next = temp->next;
temp->next = p->next;
p->next = temp;
```

## 六、模拟代码过程

### 1. 执行流程
以输入 [1,2,3,4] 为例：
```
初始状态：dummy->1->2->3->4
第一次交换后：dummy->2->1->3->4
第二次交换后：dummy->2->1->4->3
```

### 2. 图示说明
```
dummy -> 1 -> 2 -> 3 -> 4
   p    p1   p2   p3
步骤1：p2->next = p1
步骤2：p1->next = p3
步骤3：p->next = p2
结果：dummy -> 2 -> 1 -> 3 -> 4
```

### 3. 调试技巧
- 关注指针的移动过程
- 检查节点连接的正确性
- 注意边界条件的处理

## 七、复杂度分析

### 1. 时间复杂度
- 最好情况：O(n)
- 最坏情况：O(n)
- 平均情况：O(n)
其中n为链表长度

### 2. 空间复杂度
- 辅助空间：O(1)
- 只使用常数个额外变量

### 3. 优化空间
- 已经达到最优时间复杂度
- 空间复杂度已经是常数级

## 八、常见错误

### 1. 代码错误
```cpp
// 错误：没有保存后续节点
p1->next = p2->next;
p2->next = p1;
// 可能导致节点丢失

// 正确：先保存后续节点
ListNode* p3 = p2->next;
p1->next = p3;
p2->next = p1;
```

### 2. 思路错误
- 忘记使用虚拟头节点
- 指针移动顺序错误
- 没有考虑边界情况

### 3. 调试建议
- 画图辅助理解
- 使用小规模测试用例
- 检查指针连接

## 九、扩展思考

### 1. 题目变形
- K个一组翻转链表
- 奇偶位置节点交换
- 区间内节点反转

### 2. 面试相关
- 链表操作的要点
- 指针使用的技巧
- 代码的健壮性

### 3. 实战技巧
- 使用虚拟头节点
- 画图辅助思考
- 步骤拆分实现

## 十、相关题目

### 1. 类似题目
1. [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)
2. [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

### 2. 推荐练习
- 链表的基本操作
- 指针的使用技巧
- 节点交换相关题目
