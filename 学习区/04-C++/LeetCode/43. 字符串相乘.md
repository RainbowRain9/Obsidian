# 43. 字符串相乘


好的，我们来详细讲解一下 LeetCode 第 43 题：字符串相乘。

# 43. 字符串相乘

## 一、前置知识

*   **C++ 基础:**
    *   `std::string`: 字符串操作，包括访问字符、获取长度等。
    *   `std::vector<int>`: 动态数组，用于存储中间计算结果。
    *   `std::reverse`: 翻转容器（如 `vector` 或 `string`）中的元素。
    *   `std::to_string`: 将数字转换为字符串。
    *   字符与整数转换: `char` 类型的数字 '0' 到 '9' 减去 '0' 得到对应的 `int` 值。
*   **基本算法:**
    *   模拟: 模拟手工进行竖式乘法的过程。
*   **数学概念:**
    *   竖式乘法: 理解小学学过的多位数乘法的计算步骤，特别是逐位相乘和进位处理。
    *   进制: 理解十进制数的表示方式，每一位代表的值。

## 二、题目分析

### 1. 题目描述

*   **题目链接：** [https://leetcode.cn/problems/multiply-strings/description/](https://leetcode.cn/problems/multiply-strings/description/)
*   **本地链接：** [43-multiply-strings.cpp](../Algorithm/LeetCode/All/43-multiply-strings.cpp)
*   **难度级别:** Medium
*   **相关标签:** 数学（Math）、字符串（String）、模拟（Simulation）

### 2. 题目要求

*   **输入:** 两个以字符串形式表示的非负整数 `num1` 和 `num2`。
*   **输出:** `num1` 和 `num2` 的乘积，同样以字符串形式表示。
*   **限制:**
    *   不能使用任何内置的 BigInteger 库。
    *   不能直接将输入字符串转换为整数类型进行计算（因为可能超出整数类型的表示范围）。
    *   `1 <= num1.length, num2.length <= 200`。
    *   `num1` 和 `num2` 只包含数字 `0-9`。
    *   `num1` 和 `num2` 都不包含任何前导零，除非是数字 `0` 本身。

### 3. 关键概念

*   **大数乘法:** 输入的数字可能非常大，超出了标准整数类型（如 `int`, `long long`）的表示范围，因此需要使用字符串来处理。
*   **模拟竖式乘法:** 核心思想是模拟我们手动计算乘法的过程。`num1` 的第 `i` 位乘以 `num2` 的第 `j` 位的结果，会影响到最终结果的第 `i+j` 位（以及可能的更高位，通过进位）。
*   **进位处理:** 在累加过程中，每一位的结果可能大于 9，需要将十位及以上的部分作为进位加到下一位。
*   **结果位数:** 两个长度分别为 `n` 和 `m` 的数相乘，结果的长度最多为 `n + m`。

## 三、示例分析

### 1. 基本示例

```
输入：num1 = "2", num2 = "3"
输出："6"
图解：
   2
 x 3
 ---
   6
解释：简单的一位数乘法。
```

```
输入：num1 = "123", num2 = "456"
输出："56088"
图解：(模拟竖式乘法)
      1 2 3
    x 4 5 6
    -------
      7 3 8  (123 * 6)
    6 1 5    (123 * 5, 左移一位)
  4 9 2      (123 * 4, 左移两位)
  ---------
  5 6 0 8 8  (按位相加并处理进位)
解释：
1. 123 * 6 = 738
2. 123 * 5 = 615, 对应到结果是 6150
3. 123 * 4 = 492, 对应到结果是 49200
4. 将 738, 6150, 49200 相加得到 56088
```

### 2. 特殊情况

```
输入：num1 = "99", num2 = "0"
输出："0"
分析：任何数乘以 0 都得 0。代码需要处理这种情况。
```

### 3. 边界测试

```
输入：num1 = "1", num2 = "1"
输出："1"
说明：单位数乘法。
```

```
输入：num1 = "9", num2 = "9"
输出："81"
说明：乘法产生进位。
```

## 四、解题思路

### 1. 问题分析

*   **问题的本质:** 核心是处理无法用标准数据类型表示的大数乘法。
*   **可能的解决方案:**
    *   模拟竖式乘法：这是最直观且符合题目限制的方法。
    *   快速傅里叶变换 (FFT)：理论上可以优化大数乘法，但对于本题的长度限制 (200)，模拟法足够高效且更容易实现。
*   **方案的优劣比较:** 模拟法实现相对简单，复杂度 O(n*m) 可接受。FFT 复杂度更优 O(N log N)（N为结果位数），但实现复杂，不适合本题。

### 2. 算法设计

*   **核心算法选择:** 模拟竖式乘法。
*   **数据结构设计:**
    *   使用 `std::vector<int>` 来存储中间结果。将向量的索引视为数字的位数（例如，`result[0]` 存储个位，`result[1]` 存储十位），这样便于处理进位和累加。
    *   为了方便计算，可以将输入的字符串 `num1` 和 `num2` 翻转，使得个位在前（索引 0），或者在计算时调整索引。代码中采用了先翻转存入 `vector` 的方式。
*   **优化思路:**
    *   先计算所有位的乘积之和，存入结果向量 `result`，最后统一处理进位。这样可以避免在乘法过程中频繁处理进位逻辑。
    *   预先分配足够大的结果向量 (`n + m` 位)。

### 3. 解题步骤

1.  **处理特殊情况:** 如果 `num1` 或 `num2` 是 "0"，直接返回 "0"。
2.  **初始化:** 获取 `num1` 和 `num2` 的长度 `n` 和 `m`。创建一个大小为 `n + m` 的 `vector<int>` `result` 并初始化为 0，用于存储结果（低位在前）。
3.  **字符串转向量 (可选但方便):** 将 `num1` 和 `num2` 翻转并转换为 `vector<int>` `v1` 和 `v2`，使得个位在索引 0。`v1[i]` 代表 `num1` 从右往左数第 `i` 位（0-based）的数字。
4.  **计算乘积和:**
    *   使用嵌套循环遍历 `v1` 和 `v2`。
    *   `v1[i]` 乘以 `v2[j]` 的结果应该累加到 `result` 的第 `i + j` 位上。即 `result[i + j] += v1[i] * v2[j]`。
    *   此时 `result` 中存储的是每一位的初步和，可能包含大于 9 的值。
5.  **处理进位:**
    *   遍历 `result` 向量 (从低位 `k=0` 到高位)。
    *   维护一个进位变量 `carry`，初始为 0。
    *   对于 `result[k]`，计算 `current_val = result[k] + carry`。
    *   更新 `result[k] = current_val % 10` （当前位只保留个位）。
    *   更新 `carry = current_val / 10` （计算新的进位给下一位）。
6.  **寻找最高有效位:** 从 `result` 的末尾（理论最高位 `n + m - 1`）向前查找第一个非零位。记下其索引 `start_index`。这是为了去除结果中可能存在的前导零（在 `result` 向量中表现为后缀零）。
7.  **结果转字符串:**
    *   创建一个空字符串 `ans`。
    *   从 `start_index` 开始逆序遍历 `result` 直到索引 0。
    *   将每个 `result[k]` 转换为字符并追加到 `ans`。
8.  **返回结果:** 返回字符串 `ans`。

## 五、代码实现

### 1. 完整代码

```cpp
/*
 * @Author: RainbowRain9
 * @Date: 2025-04-11 22:40:24
 * @LastEditTime: 2025-04-11 22:51:08
 * @FilePath: \C++\Algorithm\LeetCode\All\43-multiply-strings.cpp
 * @Description: LeetCode 43 字符串相乘 详细讲解
 */
/*
 * @lc app=leetcode.cn id=43 lang=cpp
 * @lcpr version=30104
 *
 * [43] 字符串相乘
 */

#include <bits/stdc++.h> // 包含了常用的头文件
#include <string>
#include <vector>
#include <algorithm> // reverse

using namespace std;

// @lc code=start
class Solution {
public:
    /**
     * @brief 计算两个以字符串表示的非负整数的乘积
     * @param num1 第一个非负整数的字符串表示
     * @param num2 第二个非负整数的字符串表示
     * @return 乘积的字符串表示
     */
    string multiply(string num1, string num2)
    {
        // 处理特殊情况：任何一个数为 "0"，结果都是 "0"
        if (num1 == "0" || num2 == "0") {
            return "0";
        }

        int n = num1.size(); // num1 的长度
        int m = num2.size(); // num2 的长度
        // 结果向量，低位在前（索引0是个位），最大长度为 n + m，初始化为0
        vector<int> result(n + m, 0);

        // 1. 将字符串转为 vector<int>，低位在前，方便计算
        vector<int> v1(n), v2(m);
        for(int i=0; i<n; ++i) v1[i] = num1[n-1-i] - '0'; // num1 的个位在 v1[0]
        for(int i=0; i<m; ++i) v2[i] = num2[m-1-i] - '0'; // num2 的个位在 v2[0]

        // 2. 计算乘积并累加到 result，暂不处理进位
        // 模拟竖式乘法的核心步骤
        for (int i = 0; i < n; ++i) { // 遍历 v1 (num1) 的每一位
            for (int j = 0; j < m; ++j) { // 遍历 v2 (num2) 的每一位
                // v1[i] (num1的第i位) * v2[j] (num2的第j位) 的结果
                // 应该加到 result 的第 i+j 位上 (0-based index)
                result[i + j] += v1[i] * v2[j];
            }
        }

        // 3. 处理进位
        int carry = 0; // 进位初始化为 0
        // 从低位到高位遍历 result 向量处理进位
        for (int k = 0; k < n + m; ++k) {
            int current_val = result[k] + carry; // 当前位的原始值加上来自低位的进位
            result[k] = current_val % 10;       // 当前位只保留个位数
            carry = current_val / 10;           // 计算新的进位，传递给更高位
        }
        // 循环结束后，如果最高位还有进位carry，它已经被加到 result[n+m-1] 或隐式地存在（虽然vector大小固定）
        // 但由于 result 大小是 n+m，所有有效数字和进位都已在其中处理

        // 4. 寻找结果的最高有效位 (去除前导零)
        int start_index = n + m - 1; // 从理论上的最高位开始
        // result 是低位在前，所以前导零在向量末尾
        // 跳过末尾的零，找到第一个非零数字的索引
        while (start_index > 0 && result[start_index] == 0) {
            start_index--;
        }
        // 现在 start_index 指向结果的最高有效位

        // 5. 将结果 vector 转换回字符串
        string ans = "";
        // 从最高有效位 start_index 开始，逆序遍历到个位 0
        for (int k = start_index; k >= 0; --k) {
            ans += to_string(result[k]); // 将数字转为字符追加到结果字符串
        }

        return ans; // 返回最终的字符串结果
    }
};
// @lc code=end

// main 函数用于本地测试，提交 LeetCode 时不需要
int main()
{
    Solution solution;
    string num1 = "123";
    string num2 = "456";
    cout << "Input: num1 = \"" << num1 << "\", num2 = \"" << num2 << "\"" << endl;
    string result = solution.multiply(num1, num2);
    cout << "Output: \"" << result << "\"" << endl; // Expected: "56088"

    num1 = "2";
    num2 = "3";
    cout << "Input: num1 = \"" << num1 << "\", num2 = \"" << num2 << "\"" << endl;
    result = solution.multiply(num1, num2);
    cout << "Output: \"" << result << "\"" << endl; // Expected: "6"

     num1 = "99";
    num2 = "0";
    cout << "Input: num1 = \"" << num1 << "\", num2 = \"" << num2 << "\"" << endl;
    result = solution.multiply(num1, num2);
    cout << "Output: \"" << result << "\"" << endl; // Expected: "0"

    return 0;
}
```

### 2. 关键代码段解析

```cpp
// 2. 计算乘积并累加到 result，暂不处理进位
for (int i = 0; i < n; ++i) { // 遍历 v1 (num1) 的每一位
    for (int j = 0; j < m; ++j) { // 遍历 v2 (num2) 的每一位
        // v1[i] 是 num1 从右往左第 i 位 (0-based) 的数字
        // v2[j] 是 num2 从右往左第 j 位 (0-based) 的数字
        // 它们的乘积影响的是结果中从右往左第 i+j 位 (0-based)
        // 例如，个位(i=0) * 个位(j=0) -> 结果的个位(i+j=0)
        // 个位(i=0) * 十位(j=1) -> 结果的十位(i+j=1)
        // 十位(i=1) * 个位(j=0) -> 结果的十位(i+j=1)
        result[i + j] += v1[i] * v2[j];
    }
}
// 这个循环结束后，result[k] 存储了所有 v1[i]*v2[j] (其中 i+j=k) 的和
```

```cpp
// 3. 处理进位
int carry = 0; // 进位
for (int k = 0; k < n + m; ++k) { // 从个位开始处理
    int current_val = result[k] + carry; // 当前位的原始值加上低位传来的进位
    result[k] = current_val % 10;       // 更新当前位为 %10 的余数（即个位数）
    carry = current_val / 10;           // 计算新的进位，给下一位（k+1）使用
}
// 这个循环确保了 result 中的每个元素都是 0-9 之间的数字
```

```cpp
// 4. 寻找结果的最高有效位
int start_index = n + m - 1; // 理论最高位索引
// 因为 result 是低位在前，所以前导零是向量末尾的 0
while (start_index > 0 && result[start_index] == 0) {
    start_index--;
}
// 如果结果是 "0" (例如 "0" * "123")，在步骤1已处理。
// 如果结果非零，start_index 会停在最高位的非零数字上。
// start_index=0 的情况是允许的（例如 2*3=6, n=1, m=1, n+m=2, result=[6, 0], start_index=0）
```

```cpp
// 5. 将结果 vector 转换回字符串
string ans = "";
// 从最高有效位 start_index 往低位 0 遍历
for (int k = start_index; k >= 0; --k) {
    ans += to_string(result[k]); // 将数字转为字符追加
}
// 这样构造的字符串 ans 就是最终结果，高位在前
```

### 3. 代码优化

*   **空间优化:** 可以不显式创建 `v1` 和 `v2`，直接在循环中访问 `num1[n-1-i]` 和 `num2[m-1-j]`，但这会牺牲一些可读性。
*   **合并循环:** 理论上可以将进位处理合并到乘法循环中，但这会使逻辑更复杂。当前分开处理更清晰。
*   **原地修改:** 对于极端的空间限制，可以尝试在输入字符串上进行原地修改，但这非常困难且容易出错。
*   **总结:** 当前代码在可读性和效率之间取得了较好的平衡，是解决此类问题的标准方法之一。

## 六、模拟代码过程 (以 "123" * "456" 为例)

### 1. 执行流程

*   **输入:** `num1 = "123"`, `num2 = "456"`
*   **初始化:** `n = 3`, `m = 3`. `result` = `vector<int>(6, 0)` = `{0, 0, 0, 0, 0, 0}`.
*   **字符串转向量:**
    *   `v1 = {3, 2, 1}` (来自 "123" 翻转)
    *   `v2 = {6, 5, 4}` (来自 "456" 翻转)
*   **计算乘积和 (result[i+j] += v1[i]*v2[j]):**
    *   `i=0` (v1[0]=3):
        *   `j=0` (v2[0]=6): `result[0] += 3*6 = 18`. `result`={18, 0, 0, 0, 0, 0}
        *   `j=1` (v2[1]=5): `result[1] += 3*5 = 15`. `result`={18, 15, 0, 0, 0, 0}
        *   `j=2` (v2[2]=4): `result[2] += 3*4 = 12`. `result`={18, 15, 12, 0, 0, 0}
    *   `i=1` (v1[1]=2):
        *   `j=0` (v2[0]=6): `result[1] += 2*6 = 12`. `result`={18, 27, 12, 0, 0, 0}
        *   `j=1` (v2[1]=5): `result[2] += 2*5 = 10`. `result`={18, 27, 22, 0, 0, 0}
        *   `j=2` (v2[2]=4): `result[3] += 2*4 = 8`.  `result`={18, 27, 22, 8, 0, 0}
    *   `i=2` (v1[2]=1):
        *   `j=0` (v2[0]=6): `result[2] += 1*6 = 6`.  `result`={18, 27, 28, 8, 0, 0}
        *   `j=1` (v2[1]=5): `result[3] += 1*5 = 5`.  `result`={18, 27, 28, 13, 0, 0}
        *   `j=2` (v2[2]=4): `result[4] += 1*4 = 4`.  `result`={18, 27, 28, 13, 4, 0}
    *   **乘积和结束:** `result` = `{18, 27, 28, 13, 4, 0}`
*   **处理进位:** `carry = 0`
    *   `k=0`: `val=18+0=18`. `result[0]=8`, `carry=1`. `result`={8, 27, 28, 13, 4, 0}
    *   `k=1`: `val=27+1=28`. `result[1]=8`, `carry=2`. `result`={8, 8, 28, 13, 4, 0}
    *   `k=2`: `val=28+2=30`. `result[2]=0`, `carry=3`. `result`={8, 8, 0, 13, 4, 0}
    *   `k=3`: `val=13+3=16`. `result[3]=6`, `carry=1`. `result`={8, 8, 0, 6, 4, 0}
    *   `k=4`: `val=4+1=5`.  `result[4]=5`, `carry=0`. `result`={8, 8, 0, 6, 5, 0}
    *   `k=5`: `val=0+0=0`.   `result[5]=0`, `carry=0`. `result`={8, 8, 0, 6, 5, 0}
    *   **进位处理结束:** `result` = `{8, 8, 0, 6, 5, 0}`
*   **寻找最高有效位:** `start_index = 5`. `result[5]=0`, `start_index--` -> 4. `result[4]=5 != 0`. 停止。`start_index = 4`.
*   **结果转字符串:** `ans = ""`
    *   `k=4`: `ans += "5"`. `ans`="5"
    *   `k=3`: `ans += "6"`. `ans`="56"
    *   `k=2`: `ans += "0"`. `ans`="560"
    *   `k=1`: `ans += "8"`. `ans`="5608"
    *   `k=0`: `ans += "8"`. `ans`="56088"
*   **返回:** "56088"

### 2. 图示说明 (result 向量状态)

```
[初始化]       -> [0, 0, 0, 0, 0, 0]
[乘积累加后]   -> [18, 27, 28, 13, 4, 0]  (低位在前)
[处理进位后]   -> [8, 8, 0, 6, 5, 0]     (低位在前)
[找到start_index=4]
[逆序转字符串] -> "5" + "6" + "0" + "8" + "8" = "56088"
```

### 3. 调试技巧

*   **打印中间状态:** 在关键步骤后打印 `result` 向量的值，观察计算过程是否符合预期。
*   **小数据测试:** 先用简单的例子（如 "2" * "3", "12" * "3"）手动计算，再用代码验证。
*   **边界检查:** 确保 `vector` 索引没有越界，特别是在处理 `result[i+j]` 时。
*   **进位逻辑:** 仔细检查进位处理循环，确保 `carry` 的计算和传递正确。
*   **前导零处理:** 检查 `start_index` 的查找逻辑是否能正确处理所有情况，包括结果本身就是多位数（如 "99" * "99"）。

## 七、复杂度分析

### 1. 时间复杂度

*   **字符串转向量:** O(n + m)
*   **计算乘积和:** O(n * m) - 两层嵌套循环。
*   **处理进位:** O(n + m) - 遍历 `result` 向量一次。
*   **寻找最高有效位:** O(n + m) - 最坏情况下遍历 `result` 向量一次。
*   **结果转字符串:** O(n + m) - 遍历 `result` 的有效部分一次。
*   **总体:** O(n * m)，因为乘法步骤是主导。

### 2. 空间复杂度

*   **`v1`, `v2`:** O(n + m) - 存储转换后的数字向量。
*   **`result`:** O(n + m) - 存储结果向量。
*   **`ans`:** O(n + m) - 存储最终的字符串结果。
*   **总体:** O(n + m) - 主要由存储中间结果和最终结果的向量/字符串决定。

### 3. 优化空间

*   **时间:** 对于本题限制 (<= 200)，O(n*m) 已经足够快。对于更大的数，可以考虑 Karatsuba 算法（约 O(n^1.58)）或 FFT（O(N log N)，N=n+m）。
*   **空间:** 如前所述，可以略微优化掉 `v1`, `v2` 的显式存储，但总体空间复杂度仍为 O(n+m)。

## 八、常见错误

### 1. 代码错误

```cpp
// 错误代码示例 1: 字符转数字错误
v1[i] = num1[n-1-i]; // 错误：直接将 char 赋值给 int，得到的是 ASCII 值
// 修正方法
v1[i] = num1[n-1-i] - '0'; // 正确：减去 '0' 的 ASCII 值得到数字

// 错误代码示例 2: 进位处理遗漏最后进位
// 如果循环结束后 carry > 0，没有处理
// 修正方法: 代码中通过确保 result 向量足够长 (n+m) 并在循环中处理到了 n+m-1 位，
// 隐式地包含了最高可能的进位。另一种方法是在循环后检查 carry > 0 并追加。

// 错误代码示例 3: 结果拼接顺序错误
for (int k = 0; k <= start_index; ++k) { // 错误：从低位开始拼接
    ans += to_string(result[k]);
}
// 修正方法
for (int k = start_index; k >= 0; --k) { // 正确：从高位 start_index 开始逆序拼接
    ans += to_string(result[k]);
}
```

### 2. 思路错误

*   **索引混乱:** 没有正确理解 `result[i+j]` 的含义，导致乘积结果累加到错误的位数。
*   **进位时机:** 过早或过晚处理进位，导致计算错误。先累加再统一进位是比较清晰的方式。
*   **忽略 "0" 情况:** 没有单独处理输入为 "0" 的情况，可能导致结果为 "" 或其他错误。
*   **前导零处理不当:** 没有正确找到 `start_index`，导致输出结果包含前导零 (如 "056088")，或者错误地去除了非前导零。

### 3. 调试建议

*   **分步验证:** 确保字符串转向量正确，再验证乘积和累加正确，然后验证进位处理，最后验证结果转换。
*   **测试用例:**
    *   包含 0 的情况: "0" * "123", "123" * "0", "0" * "0"
    *   单位数: "1" * "1", "2" * "3", "9" * "9"
    *   多位数: "12" * "34", "123" * "456"
    *   长度差异大: "1" * "999", "999" * "1"
    *   包含大量 9: "99" * "99"

## 九、扩展思考

### 1. 题目变形

*   **字符串相加 (LeetCode 415):** 思路类似，模拟竖式加法，处理进位。复杂度 O(max(n, m))。
*   **字符串相减:** 需要处理借位和结果的正负号。
*   **大数除法/取模:** 更复杂，通常涉及模拟长除法。
*   **处理负数:** 在乘法前判断符号，对绝对值进行计算，最后根据符号规则添加负号。

### 2. 面试相关

*   **清晰解释:** 能够清晰地解释模拟竖式乘法的过程，特别是 `result[i+j]` 的逻辑和进位处理。
*   **复杂度分析:** 准确给出时间和空间复杂度并解释原因。
*   **代码质量:** 写出清晰、结构良好、有注释的代码。
*   **边界处理:** 讨论如何处理特殊情况（如 "0"）和边界条件。

### 3. 实战技巧

*   **`vector<int>` 模拟:** 使用 `vector<int>` 存储低位在前的数字是处理大数运算的常用技巧。
*   **分步处理:** 将复杂的计算过程分解为清晰的步骤（如先累加后进位）有助于降低错误率。
*   **代码模板:** 可以将此实现作为一个大数乘法的模板，在需要时进行修改。

## 十、相关题目

### 1. 类似题目

1.  [LeetCode 415. Add Strings](https://leetcode.cn/problems/add-strings/) - 字符串相加，思路更简单，只需处理加法进位。
2.  [LeetCode 2. Add Two Numbers](https://leetcode.cn/problems/add-two-numbers/) - 链表表示的数字相加，核心思想类似，数据结构不同。
3.  [LeetCode 66. Plus One](https://leetcode.cn/problems/plus-one/) - 数组表示的数字加一，是处理进位的简化版。
4.  [LeetCode 67. Add Binary](https://leetcode.cn/problems/add-binary/) - 二进制字符串相加，原理相同，进制不同。

### 2. 推荐练习

*   **基础:** LeetCode 66, 67, 415
*   **进阶:** LeetCode 2, 本题 (43)
*   **综合:** 尝试实现大数减法、除法。
