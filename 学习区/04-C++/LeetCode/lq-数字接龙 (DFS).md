# 1. 数字接龙 (DFS)

## 一、前置知识

*   **数据结构:**
    *   `int[][]`: 二维数组，用于存储 N×N 棋盘上每个格子的数字。
    *   `bool[][]`: 二维布尔数组，用于标记棋盘上的格子是否已经被访问过 (`st`)。
    *   `bool[][][][]`: 四维布尔数组，用于标记路径段是否存在，辅助检查对角线移动是否交叉 (`edge`)。
    *   `std::string`: 字符串，用于存储最终找到的路径（由方向编号 '0'-'7' 组成）。
    *   `int[]`: 一维数组，存储 8 个方向的坐标偏移量 (`dx`, `dy`)。
*   **算法知识:**
    *   深度优先搜索 (DFS): 核心搜索策略，沿着一个方向深入探索，直到无法继续或找到目标，然后回溯。
    *   回溯法: DFS 的一部分，当发现当前路径不可行或已探索完时，撤销之前的选择（状态恢复），尝试其他可能性。
*   **相关数学概念:**
    *   模运算 (`% k`): 用于判断路径上下一步的数字是否满足 `0, 1, ..., k-1, 0, ...` 的循环序列要求。

## 二、题目分析

### 1. 题目描述

*   题目链接：(非 LeetCode 题，可能是蓝桥杯或其他竞赛题)
*   本地链接：`Algorithm/Lanqiao/DFS-数字接龙.cpp`
*   难度级别：中等偏难 (涉及 DFS、回溯、复杂剪枝条件)
*   相关标签：深度优先搜索 (DFS), 回溯, 棋盘问题, 路径查找

在一个 N×N 的棋盘上，每个格子有一个 [0, K-1] 的整数。需要找到一条从左上角 (0,0) 到右下角 (N-1, N-1) 的路径，满足以下条件：
1.  每一步可以从当前格子向 8 个相邻方向（上、下、左、右、四个对角线）移动。
2.  路径上的数字必须构成一个循环递增序列：当前格数字 `a`，下一步数字 `b`，必须满足 `b == (a + 1) % k`。
3.  路径必须经过棋盘上 **所有** N*N 个格子，且每个格子 **恰好一次**。
4.  路径不能自交叉。特别地，对角线移动不能跨越路径中已存在的另一条对角线。
5.  如果存在多条满足条件的路径，输出 **字典序最小** 的那条路径。路径用 0-7 的数字序列表示方向。

### 2. 题目要求

*   **输入格式:**
    *   第一行：两个整数 N 和 K (1 ≤ N ≤ 10, 1 ≤ K ≤ 10)。
    *   接下来 N 行：每行 N 个整数，表示棋盘 `g[i][j]` (0 ≤ `g[i][j]` < K)。
*   **输出要求:**
    *   一个由 '0' 到 '7' 组成的字符串，表示字典序最小的路径。
    *   如果不存在满足条件的路径，输出 `-1`。
*   **时间/空间限制:** 通常竞赛题限制在 1-2 秒，空间限制 256MB 左右。N=10 意味着 N*N=100，搜索空间很大，需要高效剪枝。

### 3. 关键概念

*   **数字接龙序列:** `g[next_x][next_y] == (g[current_x][current_y] + 1) % k`。
*   **访问所有格子恰好一次:** 这是哈密顿路径的定义。通过 `st[][]` 数组标记访问，并在找到终点时检查路径长度是否为 `n*n - 1` (因为路径是从第二个格子开始记录方向的，总共 n*n 个格子，需要 n*n-1 步)。
*   **不交叉 (对角线):** 代码中使用 `edge[a][b][x][y]` 记录从 `(a, b)` 到 `(x, y)` 的路径段。当尝试添加对角线移动 `(a, b)` -> `(x, y)` (其中 `i % 2 == 1`) 时，需要检查是否存在反向的对角线路径段 `(a, y)` -> `(x, b)` 或 `(x, b)` -> `(a, y)`。如果存在，则表示两条对角线交叉，该移动非法。
*   **字典序最小:** DFS 搜索时，按照方向编号 0 到 7 的顺序尝试移动。由于 DFS 找到的第一个完整解就是沿着字典序最小的方向序列探索得到的，因此直接返回第一个找到的解即可。

## 三、示例分析

### 1. 基本示例

```
输入：
3 3
0 2 0
1 1 1
2 0 2
输出：41255214
图解：
(0,0)=0 --4(↓)--> (1,0)=1 --1(↗)--> (0,1)=2 --2(→)--> (0,2)=0
   |                ^                |                v
(1,0)=1 <--(unknown)<- (2,0)=2 <--5(↙)<-- (1,1)=1 --5(↙)--> (2,0)=2
   |                |                ^                |
(2,0)=2 --(?)--> (2,1)=0 --1(↗)--> (1,2)=1 --4(↓)--> (2,2)=2

(路径追溯)
Start: (0,0)=0
Dir 4 (↓): (1,0)=1. Path: "4"
Dir 1 (↗): (0,1)=2. Path: "41"
Dir 2 (→): (0,2)=0. Path: "412"
Dir 5 (↙): (1,1)=1. Path: "4125"
Dir 5 (↙): (2,0)=2. Path: "41255"
Dir 2 (→): (2,1)=0. Path: "412552"
Dir 1 (↗): (1,2)=1. Path: "4125521"
Dir 4 (↓): (2,2)=2. Path: "41255214". End.
解释：
- 路径序列：0->1->2->0->1->2->0->1->2，满足模 3 递增。
- 访问格子：(0,0),(1,0),(0,1),(0,2),(1,1),(2,0),(2,1),(1,2),(2,2)，共 9 个格子，无重复。
- 路径长度：8 (等于 3*3 - 1)。
- 交叉：根据代码逻辑，此路径没有发生交叉。
- 字典序：这是按照 0-7 方向优先搜索找到的第一个解。
```

### 2. 特殊情况

*   **无解:** 如果棋盘构造使得无法从 (0,0) 到 (N-1, N-1) 走完所有格子，或数字序列无法满足，则 `dfs(0, 0)` 返回 `false`，输出 `-1`。例如，起点 `g[0][0]` 就无法移动到任何满足 `(g[0][0]+1)%k` 的邻居。
*   **N=1:** 输入 `1 k` 和 `g[0][0]`，路径为空，直接在终点，路径长度 0 == 1*1-1。应输出空字符串 `""`。 (代码 `dfs` 会直接判断 `a==n-1 && b==n-1`，返回 `path.size() == 0`，为 `true`。)

### 3. 边界测试

*   **K=1:** 数字序列只能是 `0, 0, 0, ...`。
*   **棋盘边缘:** 移动时需要正确处理边界，不能越界。
*   **路径长度:** 必须精确等于 `n*n-1`。

## 四、解题思路

### 1. 问题分析

*   问题的本质是在一个带约束条件的图（棋盘）中寻找一条特定的哈密顿路径。
*   约束条件包括：起点终点固定、必须访问所有节点、节点访问顺序（数字序列）、边的限制（移动方向、不交叉）、优化目标（字典序最小）。
*   由于状态空间巨大，需要使用深度优先搜索结合强剪枝和回溯。

### 2. 算法设计

*   **核心算法:** 带回溯的深度优先搜索 (DFS)。
*   **数据结构:**
    *   `g[N][N]`: 存储棋盘。
    *   `st[N][N]`: 标记格子访问状态。
    *   `edge[N][N][N][N]`: 标记路径段，用于交叉检查。
    *   `path`: 字符串，记录当前路径的方向序列。
    *   `dx[], dy[]`: 方向向量。
*   **优化思路:**
    *   **可行性剪枝:** 检查越界、已访问、数字序列。
    *   **交叉剪枝:** 检查对角线移动是否交叉。
    *   **字典序:** 按 0-7 顺序遍历方向，找到第一个解即为最优解。

### 3. 解题步骤

1.  **初始化:**
    *   读取 N, K 和棋盘 `g`。
    *   初始化 `st` 数组为 `false`。
    *   初始化 `edge` 数组为 `false`。
    *   初始化 `path` 字符串为空。
2.  **调用 DFS:** 从起点 `dfs(0, 0)` 开始搜索。
3.  **DFS 函数 `dfs(a, b)`:**
    *   **基本情况 (Base Case):**
        *   如果当前位置 `(a, b)` 是终点 `(n-1, n-1)`：
            *   检查路径长度 `path.size()` 是否等于 `n * n - 1`。
            *   如果是，说明找到了一条完整的路径，返回 `true`。
            *   否则，这条路径无效（未访问所有格子），继续执行（理论上应该直接返回 false，但由于后续没有可走的路，也会自然返回 false）。
    *   **标记:** 设置 `st[a][b] = true`，表示当前格子已访问。
    *   **探索邻居:**
        *   循环遍历 8 个方向 `i` 从 0 到 7：
            *   计算下一个可能的坐标 `(x, y) = (a + dx[i], b + dy[i])`。
            *   **剪枝检查 (Pruning):**
                *   检查 `(x, y)` 是否越界 (`x < 0 || x >= n || y < 0 || y >= n`)。
                *   检查 `(x, y)` 是否已被访问 (`st[x][y]`)。
                *   检查数字是否满足接龙要求 (`g[x][y] != (g[a][b] + 1) % k`)。
                *   **交叉检查:** 如果是对角线移动 (`i % 2 == 1`)，检查 `edge[a][y][x][b]` 或 `edge[x][b][a][y]` 是否为 `true`。
                *   如果以上任一检查失败，`continue` 到下一个方向。
            *   **前进:**
                *   标记路径段 `edge[a][b][x][y] = true`。
                *   将方向 `i` 添加到路径 `path += (i + '0')`。
                *   递归调用 `dfs(x, y)`。
                *   **找到解:** 如果递归调用返回 `true`，说明已经找到字典序最小的解，直接返回 `true`。
                *   **回溯 (Backtrack):** 如果递归调用返回 `false`：
                    *   撤销路径段标记 `edge[a][b][x][y] = false`。
                    *   从路径中移除最后一个方向 `path.pop_back()`。
    *   **回溯:** 如果所有 8 个方向都尝试完毕，没有找到通往终点的有效路径：
        *   撤销当前格子的访问标记 `st[a][b] = false`。
        *   返回 `false`。
4.  **输出结果:**
    *   在 `main` 函数中，如果 `dfs(0, 0)` 返回 `true`，输出 `path`。
    *   否则，输出 `-1`。

## 五、代码实现

### 1. 完整代码

```cpp
/*
 * @Author: RainbowRain9
 * @Date: 2025-04-11 13:18:21
 * @LastEditTime: 2025-04-11 14:07:18
 * @FilePath: \C++\Algorithm\Lanqiao\DFS-数字接龙.cpp
 * @Description: 使用DFS解决数字接龙问题，寻找字典序最小的路径
 */

#include <bits/stdc++.h> // 引入标准库头文件
using namespace std;

const int N = 11; // 定义棋盘的最大大小常量
int n, k; // n: 棋盘大小, k: 数字循环范围
int g[N][N]; // 存储棋盘数字
// 8个方向的坐标偏移量 (0:上, 1:右上, 2:右, 3:右下, 4:下, 5:左下, 6:左, 7:左上)
int dx[8] = { -1, -1, 0, 1, 1, 1, 0, -1 };
int dy[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };
string path; // 存储找到的路径方向序列
bool st[N][N]; // 标记格子是否被访问过
// 标记从(a,b)到(x,y)的路径段是否存在，用于交叉检查
bool edge[N][N][N][N];

/**
 * @brief 深度优先搜索函数
 * @param a 当前格子的行坐标
 * @param b 当前格子的列坐标
 * @return bool 是否找到一条从(a,b)到达终点并满足所有条件的路径
 */
bool dfs(int a, int b)
{
    // 到达终点 (n-1, n-1)
    if (a == n - 1 && b == n - 1)
        // 检查是否访问了所有格子 (路径长度为 n*n - 1)
        return path.size() == n * n - 1;

    st[a][b] = true; // 标记当前格子已访问

    // 遍历 8 个方向 (按 0-7 顺序保证字典序最小)
    for (int i = 0; i < 8; i++) {
        int x = a + dx[i]; // 计算下一个格子的行坐标
        int y = b + dy[i]; // 计算下一个格子的列坐标

        // --- 剪枝和合法性检查 ---
        // 1. 检查是否越界
        if (x < 0 || x >= n || y < 0 || y >= n)
            continue;
        // 2. 检查是否已访问
        if (st[x][y])
            continue;
        // 3. 检查数字是否满足循环序列
        if (g[x][y] != (g[a][b] + 1) % k)
            continue;
        // 4. 检查对角线移动是否交叉 (i % 2 == 1 表示对角线方向)
        // 检查是否存在反向对角线 (a,y)->(x,b) 或 (x,b)->(a,y)
        if (i % 2 && (edge[a][y][x][b] || edge[x][b][a][y]))
            continue;

        // --- 前进 ---
        edge[a][b][x][y] = true; // 标记路径段 (a,b) -> (x,y)
        path += i + '0'; // 将方向编号加入路径字符串
        if (dfs(x, y)) // 递归搜索下一个格子
            return true; // 如果找到解，直接返回 true

        // --- 回溯 ---
        path.pop_back(); // 移除路径中的最后一个方向
        edge[a][b][x][y] = false; // 取消路径段标记
    }

    // --- 回溯 ---
    st[a][b] = false; // 取消当前格子的访问标记
    return false; // 如果所有方向都无法到达终点，返回 false
}

int main()
{
    cin >> n >> k; // 输入棋盘大小和数字循环范围
    for (int i = 0; i < n; i++) // 读取棋盘上的数字
        for (int j = 0; j < n; j++)
            cin >> g[i][j];

    // 从起点(0,0)开始搜索路径
    if (!dfs(0, 0))
        cout << -1 << endl; // 如果没有找到路径，输出-1
    else
        cout << path << endl; // 输出找到的字典序最小的路径

    return 0;
}
```

### 2. 关键代码段解析

```cpp
// 检查数字是否满足循环序列
if (g[x][y] != (g[a][b] + 1) % k)
    continue;
```
确保下一步的数字是当前数字加 1 后模 K 的结果。

```cpp
// 检查对角线移动是否交叉
if (i % 2 && (edge[a][y][x][b] || edge[x][b][a][y]))
    continue;
```
这是防止路径交叉的关键。当要进行一次对角线移动（从 `(a, b)` 到 `(x, y)`）时，它会检查是否已经存在一条连接 `(a, y)` 和 `(x, b)` 的路径段（无论哪个方向）。如果存在，说明这两条对角线会交叉，此次移动无效。

```cpp
// 回溯操作
path.pop_back();
edge[a][b][x][y] = false;
// ... 在循环结束后
st[a][b] = false;
```
回溯是 DFS 的核心部分。当一条路径探索失败后，需要撤销所做的更改，恢复到之前的状态，以便尝试其他路径。这包括：从 `path` 中移除最后添加的方向，取消 `edge` 标记，以及在函数末尾（或无法继续前进时）取消 `st` 标记。

### 3. 代码优化

*   **空间优化:** `edge[N][N][N][N]` 使用了 O(N^4) 的空间。对于 N=10，这是 10000 个布尔值，还可以接受。如果 N 更大，可能需要考虑优化。例如，用 `std::set` 或 `std::unordered_set` 存储存在的对角线边（将边的两个端点坐标组合成一个唯一的 key），可以将空间降至 O(N^2)，但会增加查找和插入的时间开销。
*   **时间优化:** 本质上是哈密顿路径问题，NP-Hard。除了上述剪枝，很难有量级的优化。对于特定数据可能有启发式方法，但通用性不强。

## 六、模拟代码过程(一定要有)

### 1. 执行流程

以示例输入为例：
1.  `main`: 读入 `n=3`, `k=3`, 棋盘 `g`。
2.  调用 `dfs(0, 0)`。
3.  `dfs(0, 0)`:
    *   `st[0][0] = true`。
    *   尝试方向 0, 1, 2, 3...
    *   方向 4 (↓): `x=1, y=0`。检查：未越界，`!st[1][0]`, `g[1][0]==(g[0][0]+1)%3` (1 == (0+1)%3)，非对角线。通过。
    *   `edge[0][0][1][0] = true`, `path = "4"`.
    *   调用 `dfs(1, 0)`.
4.  `dfs(1, 0)`:
    *   `st[1][0] = true`.
    *   尝试方向 0, 1...
    *   方向 1 (↗): `x=0, y=1`. 检查：未越界，`!st[0][1]`, `g[0][1]==(g[1][0]+1)%3` (2 == (1+1)%3)，对角线 (`i=1`)，检查交叉 `!edge[1][1][0][0] && !edge[0][0][1][1]`。通过。
    *   `edge[1][0][0][1] = true`, `path = "41"`.
    *   调用 `dfs(0, 1)`.
5.  `dfs(0, 1)`:
    *   `st[0][1] = true`.
    *   尝试方向 0, 1, 2...
    *   方向 2 (→): `x=0, y=2`. 检查：未越界，`!st[0][2]`, `g[0][2]==(g[0][1]+1)%3` (0 == (2+1)%3)，非对角线。通过。
    *   `edge[0][1][0][2] = true`, `path = "412"`.
    *   调用 `dfs(0, 2)`.
6.  ... (按照示例路径继续) ...
7.  `dfs(1, 2)`:
    *   `st[1][2] = true`.
    *   尝试方向 4 (↓): `x=2, y=2`. 检查：未越界，`!st[2][2]`, `g[2][2]==(g[1][2]+1)%3` (2 == (1+1)%3)，非对角线。通过。
    *   `edge[1][2][2][2] = true`, `path = "41255214"`.
    *   调用 `dfs(2, 2)`.
8.  `dfs(2, 2)`:
    *   `a=2 == n-1`, `b=2 == n-1`.
    *   检查 `path.size() == 8`, `n*n-1 = 3*3-1 = 8`. 相等。
    *   返回 `true`.
9.  `dfs(1, 2)` 收到 `true`，返回 `true`.
10. ... 逐层返回 `true` ...
11. `dfs(0, 0)` 收到 `true`.
12. `main`: 输出 `path` "41255214"。

### 2. 图示说明

```mermaid
graph TD
    A[dfs(0,0)] -- 4 --> B(dfs(1,0));
    B -- 1 --> C(dfs(0,1));
    C -- 2 --> D(dfs(0,2));
    D -- 5 --> E(dfs(1,1));
    E -- 5 --> F(dfs(2,0));
    F -- 2 --> G(dfs(2,1));
    G -- 1 --> H(dfs(1,2));
    H -- 4 --> I(dfs(2,2));
    I -- BaseCase: true --> H;
    H -- return true --> G;
    G -- return true --> F;
    F -- return true --> E;
    E -- return true --> D;
    D -- return true --> C;
    C -- return true --> B;
    B -- return true --> A;
    A -- return true --> M(main);
    M --> O[Output path];

    style I fill:#f9f,stroke:#333,stroke-width:2px
```
*(这是一个简化的流程图，展示了成功找到路径时的调用栈和返回过程)*

### 3. 调试技巧

*   **打印状态:** 在 `dfs` 函数入口打印 `a`, `b`, `path`，观察搜索过程。
*   **单步跟踪:** 使用调试器在关键检查点（越界、访问、数字、交叉）和递归调用前后设置断点。
*   **小规模测试:** 先用 N=2 或 N=3 的简单棋盘测试，手动推演结果，验证代码逻辑。
*   **可视化:** 在纸上画出棋盘，手动模拟 DFS 的过程，特别是回溯和交叉检查。
*   **检查回溯:** 确保 `st`, `edge`, `path` 在回溯时都正确恢复。

## 七、复杂度分析

### 1. 时间复杂度

*   **最坏情况:** 搜索空间树的节点数最多可达 O(8^(N*N))。每个节点进行常数次检查和操作。虽然有剪枝，但最坏情况下仍是指数级的。难以给出精确的多项式界。
*   **实际情况:** 由于剪枝的存在（特别是必须访问所有格子和数字序列限制），实际运行时间远小于理论上界，但对于 N=10 仍然可能非常耗时。

### 2. 空间复杂度

*   **递归栈深度:** 最多 O(N*N)，对应路径的最大长度。
*   **辅助空间:**
    *   `g[N][N]`: O(N^2)
    *   `st[N][N]`: O(N^2)
    *   `edge[N][N][N][N]`: O(N^4)
    *   `path`: O(N^2)
*   **总体空间:** 主要由 `edge` 数组决定，为 O(N^4)。

### 3. 优化空间

*   **时间:** 可能的优化方向包括更强的剪枝（例如，预估剩余路径是否可能到达终点，但这很难设计），或者针对特定结构的优化。对于通用解法，DFS+回溯+剪枝已是标准方法。
*   **空间:** 如前所述，可以将 `edge` 数组优化到 O(N^2)，但可能牺牲一点时间效率。
*   **权衡:** 在空间允许的情况下，O(N^4) 的 `edge` 数组提供了 O(1) 的交叉检查，可能是时间和空间的一个较好平衡点。

## 八、常见错误

### 1. 代码错误

```cpp
// 错误代码示例: 回溯不完整
void dfs_error(int a, int b) {
    // ...
    st[a][b] = true; // 标记访问
    for (int i = 0; i < 8; i++) {
        // ... 检查 ...
        edge[a][b][x][y] = true;
        path += i + '0';
        if (dfs_error(x, y)) return true;
        path.pop_back();
        // 错误：忘记 edge[a][b][x][y] = false;
    }
    // 错误：忘记 st[a][b] = false;
    return false;
}
// 错误原因: 没有完全撤销状态更改，导致后续搜索基于错误的状态。
// 修正方法: 在回溯时恢复所有修改过的状态 (path, edge, st)。
```

### 2. 思路错误

*   **终点判断:** 仅判断 `a == n - 1 && b == n - 1` 就返回 `true`，而未检查 `path.size() == n * n - 1`。
*   **交叉检查遗漏或逻辑错误:** 未检查交叉，或检查条件写错。
*   **字典序:** 遍历方向未使用 0-7 的顺序，或错误地认为需要找到所有解再排序（DFS 的性质保证第一个解即为字典序最小）。

### 3. 调试建议

*   **构造边界用例:** N=1, K=1, 无法联通的棋盘，必定交叉的棋盘。
*   **验证数字序列:** 构造 K 值较小的用例，更容易检查数字循环。
*   **性能瓶颈:** 如果超时，分析哪个剪枝条件不够强，或是否存在冗余计算。

## 九、扩展思考

### 1. 题目变形

*   **起点/终点任意:** 需要修改 DFS 的起始调用和终止条件。
*   **不要求访问所有格子:** 只需找到一条从起点到终点的合法路径，去掉 `path.size()` 检查。
*   **允许重复访问格子 (但不能重复边):** 去掉 `st[x][y]` 检查，但需要避免直接来回走。
*   **寻找路径数量/最长路径:** 需要修改 DFS 返回值和逻辑，不能找到第一个解就返回。

### 2. 面试相关

*   DFS 和回溯是面试常考点。
*   可能会问复杂度分析、如何优化空间（`edge` 数组）。
*   解释交叉检查的逻辑和必要性。
*   讨论不同剪枝策略的效果。

### 3. 实战技巧

*   熟记 DFS/回溯模板代码。
*   对于棋盘问题，方向数组 `dx, dy` 是常用技巧。
*   多维数组（如 `edge`）用于状态表示。
*   注意递归边界条件和回溯的完整性。

## 十、相关题目

### 1. 类似题目

1.  [LeetCode 79. 单词搜索](https://leetcode.cn/problems/word-search/): 在二维网格中搜索单词路径，典型的 DFS 应用。
2.  [LeetCode 980. 不同路径 III](https://leetcode.cn/problems/unique-paths-iii/): 寻找访问所有非障碍格子一次的路径数量，涉及哈密顿路径和状态记录。
3.  [蓝桥杯等竞赛中的棋盘/迷宫路径问题](<搜索相关资源>): 常常涉及 DFS/BFS 和各种约束条件。

### 2. 推荐练习

*   **基础巩固:** LeetCode "回溯算法" 标签下的简单/中等题目。
*   **提高进阶:** 涉及状态压缩 DP 的棋盘问题（如果 N 较小），哈密顿路径/回路问题。
*   **综合应用:** 需要结合剪枝、启发式搜索或特定数据结构优化的复杂搜索问题。
