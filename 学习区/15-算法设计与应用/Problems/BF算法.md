---
命名: __BF算法
课程:
  - "[[第3章 蛮力法.canvas|第3章 蛮力法]]"
状态: 完成
执行人: 蔡蔡鸿宇
时间安排: Invalid date
待解决问题: 待解决:[ 0 ]
created: 2025-04-07T15:45
updated: 2025-04-07T15:46
---

# BF算法解析
## 1. 基本概念
### 1.1 算法定义
**BF算法**（Brute-Force，暴力匹配算法）是最基础的字符串匹配算法：
- **功能本质**：在主串S中定位模式串T首次出现位置
- **匹配方式**：逐个字符比较的暴力穷举方法
- **算法别称**：朴素字符串匹配算法[^3]

## 2. 算法实现
### 2.1 标准版本
```c
int BF(char S[], char T[]) {
    int i = 0, j = 0;
    while (S[i] != '\0' && T[j] != '\0') {
        if (S[i] == T[j]) { i++; j++; } 
        else { i = i - j + 1; j = 0; }
    }
    return T[j] == '\0' ? i - j : -1;
}
```

### 2.2 优化版本（记录起始位置）
```c
int BF_Optimized(char S[], char T[]) {
    int i = 0, j = 0, start = 0;
    while (S[i] != '\0' && T[j] != '\0') {
        if (S[i] == T[j]) { i++; j++; }
        else { start++; i = start; j = 0; }
    }
    return T[j] == '\0' ? start : -1;
}
```

## 3. 执行过程分析
### 3.1 示例演示
**输入**：
S = "ababcabcacbab"
T = "abcac"
**匹配流程**：
```
第1趟：S[0-1]="ab"匹配，S[2]≠T[2] → i=1,j=0
第2趟：S[1]≠T[0] → i=2,j=0
...
第6趟：S[5-9]="abcac"完全匹配 → 返回位置5
```

### 3.2 关键特点
1. **回溯机制**：主串指针i每次失败后回退到`i-j+1`
2. **重复比较**：每次失败后模式串从头开始匹配
3. **简单直接**：无预处理开销，适合短模式串

## 4. 时间复杂度
### 4.1 不同场景分析
| 情况 | 时间复杂度 | 触发条件 |
|------|------------|----------|
| 最好 | O(m) | 首字符不匹配或首次匹配成功 |
| 最坏 | O(n×m) | 每次都在模式末尾失配（如S="aaaab",T="aaab"） |
| 平均 | O(n+m) | 随机字符串匹配 |

### 4.2 效率对比
```python
# BF算法与改进算法比较
n, m = 1000, 10
print(f"BF算法：{n*m}次比较 vs KMP算法：{n+m}次比较")
```

## 5. 优化方向
### 5.1 主要缺陷
1. **无效回溯**：主串指针i的频繁回退导致冗余比较
2. **信息浪费**：已匹配的前缀信息未被再利用

### 5.2 改进算法
1. **KMP算法**：通过部分匹配表避免回溯
   ```c
   void GetNext(char T[], int next[]) {
       int j=0, k=-1;
       next[0] = -1;
       while(j < strlen(T)-1) {
           if(k==-1 || T[j]==T[k]) next[++j] = ++k;
           else k = next[k];
       }
   }
   ```
2. **BM算法**：结合坏字符和好后缀规则跳转
[^3]: Brute-Force算法通过逐个字符比较实现字符串匹配，是最基础的匹配策略