---
命名: __2.3 定点乘法
课程:
  - "[[第2章  运算方法与运算器]]"
状态: 完成
创建时间: Invalid date
执行人: 蔡蔡鸿宇
时间安排: Invalid date
待解决问题: 待解决:[ 0 ]
created: 2025-03-29T21:52
updated: 2025-04-08T16:40
---
> [!important]

> [!important]

# 2.3 定点乘法运算

## 2.3.1 机器实现方法

- **完全软件实现**  
    通过编程利用加法器和移位器完成乘法运算，无专用硬件。  
    **特征**：灵活性高，速度慢，适合低性能场景。
- **硬件辅助电路实现**  
    在加法器基础上增加移位电路和扩展逻辑。  
    **特征**：
    
    - 使用移位加算法
    - 硬件复杂度中等  
        **示例**：
    
    ```C++
    // 移位加算法伪代码
    int multiply(int a, int b) {
        int result = 0;
        for (int i = 0; i < n; i++) {
            if (b & 1) result += a << i;
            b >>= 1;
        }
        return result;
    }
    ```
    
- **专用乘除法器实现**  
    独立硬件模块直接完成乘法运算。**特征**：
    - 并行计算，速度最快
    - 硬件复杂度高

|   |   |   |   |
|---|---|---|---|
|**方法**|速度|硬件复杂度|适用场景|
|完全软件实现|慢|低|低成本系统|
|硬件辅助电路|中|中|通用处理器|
|专用乘除法器|快|高|高性能计算|

---

## 2.3.2 原码一位乘法运算

### 运算规则

- **符号处理**：积的符号位为被乘数与乘数符号位的异或：  
    $S = X_f \oplus Y_f$
- **数值计算**：绝对值相乘，结果取原码形式：  
    $[X \cdot Y]_{原} = (X_f \oplus Y_f) + (|X| \cdot |Y|)$

### 递推公式

1. 初始部分积 $z_0 = 0$
2. 递推关系：  
    $z_{i} = 2^{-1}(y_{n-i+1} \cdot |X| + z_{i-1})$
    - $y_{n-i+1}$ 为乘数当前位
    - $2^{-1}$ 表示右移操作

**流程**：

1. 从乘数最低位开始逐位判断
2. 若当前位为1，则加被乘数绝对值
3. 部分积右移一位，乘数右移一位

### 示例

- **题目**：计算 $X = -0.1110$ 和 $Y = 0.1101$ 的原码乘积
- **步骤**：

|   |   |   |
|---|---|---|
|**部分积**|**乘数**|**操作**|
|`00.0000`|`1101`|初始状态|
|`00.1110`|`1101`|加被乘数（乘数末位1）|
|`00.0111`|`0110`|右移一位|
|`00.0011`|`1011`|右移，乘数末位0不加|
|`01.0001`|`1101`|加被乘数，右移|
|**结果**：`1.10110110`||符号位1，数值部分为绝对值乘积|

---

## 2.3.3 带符号数的并行乘法运算

### 原码阵列乘法器

- **结构**：
    
    ```Mermaid
    graph LR
      A[被乘数] --> B[与门阵列]
      C[乘数] --> B
      B --> D[全加器阵列]
      D --> E[结果输出]
    ```
    
- **特征**：
    - 并行计算所有位积
    - 延迟低，适合高速场景

**公式**：

$P = \sum_{i=0}^{n-1} \sum_{j=0}^{n-1} (a_i \cdot b_j) \cdot 2^{i+j}$

### 补码阵列乘法器

- **间接法**：
    1. 将补码转换为绝对值
    2. 使用原码阵列乘法器计算
    3. 结果再转换为补码

**关键电路**：

- **求补器**：将补码转换为绝对值  
    $[-Y]_{补} = \overline{Y} + 1$

### 示例

- **题目**：用补码阵列乘法器计算 $(-15) \times (-13)$
- **步骤**：
    1. 输入补码：`[X]补 = 10001`, `[Y]补 = 10011`
    2. 求绝对值：`|X| = 1111`, `|Y| = 1101`
    3. 原码乘积：`1111 × 1101 = 11000011`
    4. 符号位：`0`（负数×负数）**结果**：`0110000011`（补码形式）