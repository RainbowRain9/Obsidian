---
命名: __4.4 典型指令
课程:
  - "[[第4章 指令系统]]"
状态: 完成
执行人: 蔡蔡鸿宇
时间安排: Invalid date
待解决问题: 待解决:[ 0 ]
---

# 4.4 典型指令

本节主要介绍计算机指令系统中的典型指令类型以及RISC指令系统的概念、发展与特性。指令是软件与硬件之间的重要接口，理解指令类型及其特性对于深入理解计算机组成原理至关重要。

## 4.4.1 指令的分类

一个功能完善的指令系统通常包含多种类型的指令，用于执行不同的基本操作。这些指令可以根据其功能进行划分。

### 数据传送类指令

- **定义**：用于在计算机内部的不同位置之间移动数据。

- **功能**：实现寄存器与寄存器、寄存器与存储单元、存储单元与存储单元之间的数据传送。

- **类型**：包括取数指令（load）、存数指令（store）、传送（mov）指令、成组传送指令、字节交换指令、清累加器指令、堆栈操作指令等。

- **示例**：

  - 取数指令 (Load): 将存储器中的数据加载到寄存器中。
  - 存数指令 (Store): 将寄存器中的数据存储到存储器中。
  - 传送指令 (MOV): 通用的数据复制操作。例如，Intel 8086 的 `mov al, 7` 指令将立即数 7 传送到 AL 寄存器。

  ```
  LOAD R1, MEM_ADDR  // 从内存地址 MEM_ADDR 取数到寄存器 R1
  STORE R1, MEM_ADDR // 将寄存器 R1 的内容存到内存地址 MEM_ADDR
  MOV R2, R1         // 将寄存器 R1 的内容传送到寄存器 R2
  ```

### 算术运算指令

- **定义**：用于对定点数或浮点数执行算术运算。

- **功能**：执行加、减、乘、除等基本算术操作。

- **特征**：指令的多少取决于机器硬件的功能，简单的CPU可能没有乘除法指令，高档CPU支持浮点运算，并行机支持向量运算指令。

- **类型**：二进制定点加减乘除、浮点加减乘除、十进制加减运算指令等。

- **示例**：

  ```
  ADD R1, R2, R3   // R1 = R2 + R3 (三地址指令示例)
  SUB R1, R2       // R1 = R1 - R2 (二地址指令示例)
  MUL R1, R2       // R1 = R1 * R2
  DIV R1, R2       // R1 = R1 / R2
  ```

  Intel 8086 的乘法指令 `mul opr` 约定被乘数隐含使用 AX 或 AL 寄存器。

### 逻辑运算指令

- **定义**：用于执行逻辑操作和位操作。

- **功能**：

  - 执行与、或、非、异或等逻辑运算功能，以及位操作。
  - 主要用于无符号数的位操作、代码转换、判断及运算。
  - 这些操作在各个比特之间没有进位、借位关系。

- **类型**：逻辑加、逻辑乘、按位加（逻辑异或）、位测试、位置位、位清除、位取反等。

- **示例**：

  ```
  AND R1, R2, R3 // R1 = R2 AND R3
  OR R1, R2, R3  // R1 = R2 OR R3
  NOT R1, R2     // R1 = NOT R2
  XOR R1, R2, R3 // R1 = R2 XOR R3
  TEST R1, MASK  // 测试 R1 中某些位是否符合 MASK
  ```

### 移位操作指令

- **定义**：用于对寄存器或内存单元的内容进行移位操作.
- **功能**：实现左移、右移或循环移位.
- **特征**：包括算术移位（符号位不移位）和逻辑移位（所有位均移位）.
- **类型**：左移、右移、算术移位、逻辑移位、单向移位、循环移位.
- **示例**：
  - 算术左移：`ASL R1, 2` (R1 内容左移2位，低位补0)
  - 逻辑右移：`LSR R1, 3` (R1 内容逻辑右移3位，高位补0)
  - 循环右移：`ROR R1, 1` (R1 内容循环右移1位)

### 程序控制指令

- **定义**：用于控制程序的执行顺序。
- **功能**：改变指令的执行流程。
- **类型**：
  - 转移指令：**条件转移**（如根据进位、零、负、溢出标志决定是否转移）和**无条件转移**指令。
  - 循环指令。
  - 子程序调用（转子程序）指令和返回主程序指令。
  - 中断调用与中断返回指令。
- **示例**：
  - 无条件转移：`JMP TARGET_ADDR` (跳转到 TARGET_ADDR 执行下一条指令)
  - 条件转移：`JZ LABEL` (如果零标志 ZF 为1，则跳转到 LABEL)
  - 子程序调用：`CALL SUB_PROG` (调用子程序 SUB_PROG)
  - 子程序返回：`RET` (返回调用点)
  - 常用的条件码包括 CF (进位标志)、ZF (零标志)、SF (符号标志)、OF (溢出标志)。

### 输入输出指令

- **定义**：用于实现CPU与外部设备之间的数据交换。

- **功能**：在**I/O独立编址方式**下，实现CPU寄存器与外部设备接口之间的信息交换。例如，启动外设、检查外设状态。在I/O与存储器统一编址方式下，通过访存指令实现数据交换。

- **类型**：输入指令、输出指令。

- **示例** (I/O独立编址方式)：

  ```
  IN AL, PORT_ADDR  // 从端口 PORT_ADDR 读取数据到 AL 寄存器
  OUT PORT_ADDR, AL // 将 AL 寄存器的数据输出到端口 PORT_ADDR
  ```

### 字符串处理指令

- **定义**：用于对成批数据（如字符串）进行操作。
- **功能**：高效处理连续存放的数据序列。
- **类型**：串传送、串转换、串替换等。
- **示例**：
  - 串传送：`MOVS` (批量移动内存中的数据串)

### 特权指令

- **定义**：具有特殊权限的指令。
- **功能**：只用于操作系统或其他系统软件，在多用户、多任务系统中用于系统资源的分配和管理。普通用户程序无法执行特权指令.
- **类型**：存储管理指令、停机指令、系统状态控制指令等。
- **示例**：
  - 修改系统状态寄存器的指令。
  - 执行 I/O 操作的指令 (在某些架构中).
  - 设置中断向量的指令.

### 其他指令

- **定义**：除上述分类外的一些其他特殊指令。
- **类型**：状态寄存器置位/复位指令、暂停指令、空操作指令（NOP）、自陷（TRAP）指令、系统控制用的特殊指令。
- **示例**：
  - `NOP` (空操作，不执行任何操作，仅消耗一个指令周期).
  - `HLT` (停机指令).
  - `TRAP` (自陷指令，产生一个软中断，常用于操作系统调用).

## 4.4.2 RISC指令系统：指令系统的发展

指令系统的设计思想随着计算机技术的发展而演变。

### 指令系统的发展历程

- **50年代**：指令系统包含最基本的定点加减、逻辑运算、数据传送、转移等指令，数目较少，十几至几十条。计算机结构简单，硬件功能较弱。
- **60年代后期**：增加乘除、浮点、十进制运算、字符串处理等指令，指令数目增多至一二百条，寻址方式多样化。机器性能提升，硬件成本下降，软件成本上升。
- **70年代末期**：指令系统多达几百条。同一系列计算机的指令系统和机器结构日益复杂。
- **传统设计思想**：认为性能越高计算机，其指令系统应提供越多指令种类和越复杂功能。这种设计思想导致了**复杂指令系统计算机 (CISC)** 的出现。

### CISC的缺点与RISC的提出

- CISC的缺点：
  - 庞大的指令系统难以保证正确性，不易调试维护.
  - 造成硬件资源浪费.
  - 统计表明，CISC 中许多复杂指令在实际使用中大多数任务根本用不到。通常只有约20%的指令占程序中出现频率的80%。
  - 硬件设计费时费力、成本增加.
  - 设计复杂、高效而可靠的指令系统越来越难.
  - 指令功能虽强，但操作繁杂，执行速度低、可靠性差.
- **RISC的提出**：1975年，IBM公司的John Cocke提出了**精简指令系统计算机 (RISC)** 的设计思想。RISC 是 **Reduced Instruction Set Computer** 的缩写.

### RISC的设计原则

- **精简指令种类**：选取使用频率最高的简单指令，去掉可通过简单指令组合实现的复杂指令。
- **提高指令译码速度**：指令长度固定，简化指令格式，减少寻址方式种类。
- **减少访存次数**：
  - 增加CPU内寄存器数目。
  - 尽量使用 R-R 操作指令：**只有load和store两种指令可以访问存储器**，其余指令的操作都在寄存器之间进行。
- **提高指令执行效率**：
  - 一般采用硬布线控制方式，不采用或少采用微程序控制方式。
  - 大部分指令在一个机器周期内完成。复杂指令可化为简单指令序列实现。
  - 采用多级指令流水线结构，提高处理机在同一时间内可执行的指令数。

### RISC与CISC的比较

比较计算机执行程序的时间 $P$。设程序编译后机器指令数为 $I$，每条指令执行所需平均机器周期数 $C$，每个机器周期执行时间为 $T$。

$$P = I \times C \times T$$

| 比较项                   | RISC      | CISC  | 说明                                                         |
| ------------------------ | --------- | ----- | ------------------------------------------------------------ |
| **机器指令数 (I)**       | 1.2 ~ 1.4 | 1     | RISC指令种类少，一条CISC指令的功能可能需要多条RISC指令组合实现，所以I相对较大 |
| **平均机器周期数 (C)**   | 1.3 ~ 1.7 | 4 ~ 6 | RISC指令简单，执行周期少；CISC指令复杂，执行周期多           |
| **机器周期执行时间 (T)** | < 1       | 1     | RISC控制简单，时钟周期可以更快                               |

尽管RISC的指令数量 $I$ 相对较多，但其平均周期数 $C$ 较少，周期时间 $T$ 更短。通过优化 $C$ 和 $T$，RISC 可以在总体执行时间 $P$ 上表现更好。

这是一个简化的流水线执行流程示意图，表示RISC指令执行常在一个周期内完成，并利用流水线提高效率：

```
graph LR
    Fetch --> Decode;
    Decode --> Execute;
    Execute --> WriteBack;
```

（此Mermaid图仅示意指令执行阶段，非源文档直接提供，但符合RISC指令执行快的设计理念）

### RISC处理机实例：SPARC

SPARC是一种典型的RISC处理机。在SPARC指令系统中，许多复杂或功能特定的指令没有被包含，但可以通过组合已有的简单指令来替代实现。

- **约定**：当指令中地址字段为寄存器 R0 的编号时，以**立即数 0** 作为操作数 (而不是 R0 的内容)。

下表展示了SPARC中一些指令功能及其替代实现方法：

| 指令 | 功能             | 替代指令 | 实现方法 (约定R0=0)                                          |
| ---- | ---------------- | -------- | ------------------------------------------------------------ |
| MOVE | 寄存器间传送数据 | ADD      | `ADD Rs, R0 -> Rd` (Rd = Rs + 0)                             |
| INC  | 寄存器内容加1    | ADD      | `ADD Rs, 1 -> Rd` (Rd = Rs + 1)                              |
| DEC  | 寄存器内容减1    | ADD      | `ADD Rs, -1 -> Rd` (Rd = Rs -1)                              |
| NEG  | 取相反数         | SUB      | `SUB R0, Rs -> Rd` (Rd = 0 - Rs)                             |
| NOT  | 取反码           | XOR      | `XOR Rs, ffff -> Rd` (假设ffff是全1，即-1的补码表示，执行按位取反) |
| CLR  | 清除寄存器       | ADD      | `ADD R0, R0 -> Rd` (Rd = 0 + 0)                              |

这些例子体现了RISC精简指令种类，通过基本指令组合实现复杂功能的思想。

