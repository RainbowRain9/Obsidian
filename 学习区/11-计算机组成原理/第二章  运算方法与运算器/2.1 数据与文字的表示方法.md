---
命名: __2.1 数据与文字的表示方法
课程:
  - "[[第二章  运算方法与运算器]]"
状态: 完成
创建时间: Invalid date
执行人: 蔡蔡鸿宇
时间安排: Invalid date
待解决问题: 待解决:[ 0 ]
created: 2025-03-29T21:52
updated: 2025-03-29T21:52
---
> [!important]

# 2.1.1 数据分类

1. **数值数据**
    - **定点格式**
        - 数值范围有限，处理简单
        - 纯小数：小数点固定在符号位与数值位之间（如 `x₀.x₁x₂…xₙ`）
        - 纯整数：小数点固定在最低位右侧（如 `x₀x₁x₂…xₙ`）
    - **浮点格式**
        - 数值范围大，处理复杂
        - 组成：尾数（m）、阶（e）、基数（R）
        - 机器浮点数格式：
            
            |   |   |   |   |
            |---|---|---|---|
            |阶符|阶码|尾符|尾数|
            |1位|m位|1位|n位|
            
2. **符号数据**
    - ASCII码
    - 汉字编码

---

# 2.1.2 数据表示方式的选择因素

- 数值类型
- 数值范围
- 数值精度
- 硬件代价

---

# 2.1.3 定点数的表示方法

### 表示范围

- **纯小数**：$0 \leq |x| \leq 1 - 2^{-n}$
- **纯整数**：$0 \leq |x| \leq 2^n - 1$

### 优缺点

- **优点**：表示简单，运算方便
- **缺点**：数值范围有限，需比例因子或幂运算扩展

---

# 2.1.4 浮点数的表示方法

### 组成要素

- **尾数（m）**：定点小数或整数，决定精度
- **阶（e）**：整数，决定数值范围
- **基数（R）**：通常为2、8或16

### 规格化条件

- 尾数绝对值满足：$\frac{1}{2} \leq |m| < 1$
- IEEE 754标准规格化形式：$x = (-1)^S \times (1.M) \times 2^{E-bias}$
    - **32位浮点数**：$bias=127$
    - **特殊值**：
        - `NaN`（非数）：阶全1且尾数非0
        - 无穷大：阶全1且尾数0
        - 机器零：阶和尾数全0

---

# 2.1.5 十进制数串的表示方法

1. **字符串形式**
    - 每个字节存放一个十进制位（兼容ASCII）
    - 示例：`+123` → `1 2 3 C`
2. **压缩十进制数串**
    - 每个字节存放两个十进制位（BCD编码）
    - 符号位用 `C`（正）或 `D`（负）表示
    - 示例：`12` → `0 1 2 D`

---

# 2.1.6 数的机器码表示

## **原码**

### 定义

- **数学表示**  
      
    - 定点整数（n位）：$[x]{\text{原}} = \begin{cases} x & 0 \leq x < 2^{n-1} \\ 2^{n-1} - x & -2^{n-1} < x \leq 0 \end{cases}$  
          
        
    - 定点小数：$[x]{\text{原}} = \begin{cases} x & 0 \leq x < 1 \\ 1 - x & -1 < x \leq 0 \end{cases}$  
          
        
    - 符号位为最高位，0表示正数，1表示负数，数值位为真值的绝对值。

### 零的表示

- **非唯一性**：`+0`（例：0000）与`0`（例：1000）存在两种表示形式。

### 特点

- **优点**：直观，与真值转换方便。
- **缺点**：加减运算需判断符号位和绝对值大小，硬件设计复杂。

---

## **补码**

### 定义

- **数学表示**  
      
    
- 定点整数（n位）：$[x]{\text{补}} = \begin{cases} x & 0 \leq x < 2^{n-1} \\ 2^{n} + x & -2^{n-1} \leq x < 0 \end{cases}$
- _定点小数：_$[x]{\text{补}} = \begin{cases} x & 0 \leq x < 1 \\ 2 + x & -1 \leq x < 0 \end{cases}$  
      
    
- 负数补码=反码末位+1，符号位参与运算。

### 零的表示

- **唯一性**：无论`+0`或`0`，补码均为0000。

### 特点

- **运算简化**：将减法转换为加法，统一符号位与数值位处理。
- 负数补码是正数补码，按位取反，末尾加1。
- **数值范围扩展**：n位补码可表示$-2^{n-1}$至$2^{n-1}-1$，比原码多一个负数（如8位补码范围-128~127）。

---

## **反码**

### 定义

- **数学表示**  
      
    
- 定点整数（n位）：$[x]{\text{反}} = \begin{cases} x & 0 \leq x < 2^{n-1} \\ (2^{n} - 1) + x & -2^{n-1} < x \leq 0 \end{cases}$  
      
    
- 定点小数：$[x]{\text{反}} = \begin{cases} x & 0 \leq x < 1 \\ 2 - 2^{-(n-1)} - |x| & -1 < x \leq 0 \end{cases}$  
      
    
- 负数反码=原码符号位不变，数值位按位取反。

### 零的表示

- **非唯一性**：`+0`为0000，`0`为1111。

### 特点

- **过渡作用**：主要用于原码与补码的转换。

---

## **移码**

### 定义

- **数学表示**
    - $[x]_{\text{移}} = 2^{n} + x \quad (-2^{n} \leq x < 2^{n})$  
        其中$n$为数值位位数，符号位取反（例：原码符号位0→1，1→0）。

### 零的表示

- **唯一性**：$[0]_{\\text{移}} = 1000$（以4位移码为例）。

### 特点

- **比较优化**：符号位与原码相反，便于浮点数阶码的大小比较（如全0表示最小负数）。

---

## **总结对比**

|   |   |   |   |   |
|---|---|---|---|---|
|编码类型|符号位处理|零的表示|数值范围（n位整数）|主要应用场景|
|原码|符号位+绝对值|两种形式|$-2^{n-1}+1$ ~ $2^{n-1}-1$|真值转换|
|补码|符号位参与运算，负数=反码+1|唯一|$-2^{n-1}$ ~ $2^{n-1}-1$|通用算术运算|
|反码|符号位不变，数值位取反|两种形式|$-2^{n-1}+1$ ~ $2^{n-1}-1$|过渡到补码|
|移码|符号位取反，整体偏移$2^{n}$|唯一|$-2^{n}$ ~ $2^{n}-1$|浮点数阶码表示|

---

## **关键运算示例**

1. **补码减法转加法**（模运算思想）
    
    $A - B = A + (-B)_{\text{补}} \mod 2^n$
    
    例如：计算$7-5$，$-5$的补码为`11111011`，直接相加后高位截断得`00000010`（即2）。
    
2. **移码比较**
    
    移码通过符号位取反，使全0对应最小负数（如4位移码中，`0000`表示-8），便于硬件快速比较阶码大小。
    
    根据原图信息及计算机组成原理知识，补充反码与移码后的完整编码对照表如下：
    
    |   |   |   |   |   |   |
    |---|---|---|---|---|---|
    |真值x|真值x|[x]原|[x]反|[x]补|[x]移|
    |+127|+01111111|01111111|01111111|01111111|11111111|
    |-127|-01111111|11111111|10000000|10000001|00000001|
    |+1|+00000001|00000001|00000001|00000001|10000001|
    |-1|-00000001|10000001|11111110|11111111|01111111|
    |+0|+00000000|00000000|00000000|00000000|10000000|
    |-0|-00000000|10000000|11111111|00000000|10000000|
    
    ---
    
    ### 📌 编码规则详解
    
    1. **反码计算规则**
        - 正数反码 = 原码（符号位0，数值位不变）
        - 负数反码 = **原码符号位不变，数值位按位取反**
        - 特例：±0 的反码不同（`00000000`和`11111111`）
    2. **移码计算规则**
        - 移码 = **真值 + 偏移量**（n位编码时，偏移量通常为2n-1）
        - 8位移码偏移量为128，即：`[x]移 = x + 128`
        - 特性：移码0点统一为`10000000`，便于浮点数阶码比较
    
    ---
    
    ### 🧩 特殊值处理对比
    
    |   |   |   |   |
    |---|---|---|---|
    |编码类型|±0 表示|数值范围（8位）|主要应用场景|
    |原码|00000000/10000000|-127 ~ +127|早期数学运算|
    |反码|00000000/11111111|-127 ~ +127|逻辑运算（现较少用）|
    |补码|00000000|-128 ~ +127|现代计算机算术运算|
    |移码|10000000|-128 ~ +127（偏移后）|浮点数阶码存储|
    
    ---
    
    ### 📖 例题延伸（基于原图例题2.9）
    
    **机器字长16位定点原码整数范围**：
    
    |   |   |   |
    |---|---|---|
    ||最大正数|最小负数|
    |原码范围|+32767 (2¹⁵-1)|-32767|
    |补码范围|+32767|-32768（特殊）|
    |移码范围|-32768~+32767|统一偏移处理|
    
    > 注：移码在浮点数标准（如IEEE754）中用于指数存储，消除符号位比较问题
    
    ---
    
    ### 💡 移码核心优势
    
    `[11111111]移` > `[00000001]移` 的直观比较，完美解决了补码中负数比较需要转换符号位的问题，这是浮点数采用移码存储指数部分的核心原因。
    

---

# 2.1.7 浮点数的规格化

### 规格化规则

- **条件**：尾数绝对值满足 `1/2 ≤ |m| < 1`
- **IEEE 754标准**：
    - 尾数隐含前导1（如 `1.M`）
    - 阶码采用移码表示（bias=127）

### 特殊值处理

- **溢出类型**：
    - 上溢：结果绝对值超过最大可表示值
    - 下溢：结果绝对值小于最小可表示值

---