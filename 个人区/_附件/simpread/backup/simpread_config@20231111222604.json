{"version":"2.2.0","option":{"annote":{"autosave":true,"color":1,"effect":"normal","event":"click","exp_mode":"page","exp_name":"html","export":false,"hypothes":false,"keyboard":"Q Q","link":"[{{an_text}}]({{an_int_uri}})","off":false,"order":"auto","savelocal":false,"shortcuts":"M M","style":0,"trigger":true},"auto_mode":"read","automated":[{"action":[{"id":1663756989374,"value":"html"}],"bgColor":"#195bf7","color":"#fff","icon":"<i class=\"fas fa-project-diagram\"></i>","id":1663756989374,"name":"","target":"unreader","type":"auto"},{"action":[{"disable":false,"id":1663846286442,"value":"html"}],"bgColor":"#195bf7","color":"#fff","icon":"<i class=\"fas fa-project-diagram\"></i>","id":1663846286442,"name":"","target":"annote","type":"auto"}],"blacklist":["google.com","youtube.com","simp.red","simpread.herokuapp.com","simpread-test.herokuapp.com","simpread.ksria.cn","https://www.oschina.net/"],"br_exit":false,"create":"","darkmode":"auto","esc":true,"export":{"custom":[],"html":{"layout":"normal","proxy":false,"toc":false},"markdeep":{"custom":false,"template":""},"markdown":{"backlink":"","custom":false,"ext_uri":"","format":"","int_uri":"","single":false,"single_tmp":"","tag":"","tag_sep":"","template":""},"title":{"custom":true,"template":"{{id}}{{un_title}}{{mode}}"},"webhooks":[]},"lazyload":["baidu.com","weibo.com","youtube.com"],"manual":{"mode":"read","select":true,"shortcuts":"S S","site":"confirm"},"menu":{"blacklist":false,"exclusion":false,"focus":true,"lazyload":false,"link":false,"list":true,"manual":true,"option":true,"read":true,"unrdist":true,"whitelist":false},"notice":true,"origins":[],"plugins":["1VQ19jCD8Z","DH9l5jblPH","HD9GmoatXd","PcmPCT9rgM","UEzvAXNSe5","VQOZdNET2d","tMGXrU1v0U","tbjTx33iAA","y8Mai5IBwN"],"preload":true,"remote":{"export":{"attach":"none","epub":true,"kindle":true,"mail":false,"pdf":true,"plain":true},"parse":true,"port":7026,"rss":false,"sync":true},"save_at":"jianguo","secret":true,"shortcuts":"enable","sync":"2023年11月11日 22:26:04","uninstall":true,"unreader":{"autoiframe":false,"bottom":true,"exports":{"html":false,"markdown":false,"pdf":false},"mode":"annote","offline":true,"openmode":"evergreen","sametheme":false,"savelocal":false,"savetype":"ofhtml","search":true,"shortcuts":"D D","show":"senior","sidebar":true,"theme":"default"},"update":"2023年11月11日 22:26:04","urlscheme":true,"version":"2017-04-03"},"focus":{"auto":false,"bgcolor":"rgba( 235, 235, 235, 0.9 )","controlbar":true,"highlight":true,"mask":true,"opacity":90,"shortcuts":"A S","version":"2016-12-29"},"read":{"actionbar":{},"auto":true,"cleanup":true,"controlbar":true,"custom":{"art":{"color":"","fontFamily":"","fontSize":"","fontWeight":"","letterSpacing":"","lineHeight":"","textIndent":"","wordSpacing":""},"code":{"fontFamily":"","fontSize":""},"css":"","desc":{"color":"","fontFamily":"","fontSize":""},"pre":{"textShadow":""},"title":{"color":"","fontFamily":"","fontSize":""}},"exclusion":["v2ex.com","issue.github.com","readme.github.com","question.zhihu.com","douban.com","nationalgeographic.com.cn","tech.163.com","docs.microsoft.com","msdn.microsoft.com","baijia.baidu.com","code.oschina.net","http://www.ifanr.com","http://www.ifanr.com/news","http://www.ifanr.com/app","http://www.ifanr.com/minapp","http://www.ifanr.com/dasheng","http://www.ifanr.com/data","https://www.ifanr.com/app","http://www.ifanr.com/weizhizao","http://www.thepaper.cn","http://www.pingwest.com","http://tech2ipo.com","https://www.waerfa.com/social","github.com"],"fap":true,"fap_layout":"list","fontfamily":"default","fontsize":"","highlight":true,"layout":"","lazyimg":true,"progress":false,"pure":true,"shortcuts":"A A","theme":"github","toc":true,"toc_hide":true,"version":"2017-03-16","whitelist":["https://sspai.com/post/*"]},"websites":{"custom":[],"local":[],"person":[]},"statistics":{"read":23,"service":{"html":37}},"user":{"avatar":"","contact":"","email":"","name":"","rule":2,"uid":"67ty7b1l-m6zz-qriw-0s6d-lntm551nudm2"},"notice":{"latest":0,"read":[],"unsee":0},"unrdist":[{"url":"https://mp.weixin.qq.com/s?__biz=MzI4NjIwOTg3Nw==&mid=2650157142&idx=1&sn=d1b46faec8cba9ab2b3dd4dace859a8b&chksm=f3e2f26cc4957b7a26eb1fef6569ba1d7850d957f41978ef4be2dbde44531d06859b267922ad&mpshare=1&scene=1&srcid=1111EFnDv5mgYAbyQbe1ygBA&sharer_shareinfo=ccd6f19fcfdf4f9688da4cc51ceae73f&sharer_shareinfo_first=ccd6f19fcfdf4f9688da4cc51ceae73f#rd","title":"obsidian 插件之 dataview 入门","favicon":"//res.wx.qq.com/a/wx_fed/assets/res/NTI4MWU5.ico","img":"http://mmbiz.qpic.cn/mmbiz_jpg/TDibWgTpJibRXWeXmAA8gicMOo32IPdT2zb8TTjTibNxFsFQdNST0KicQanTTRia5CHZln5jsjreZ70dl7qjyshD8JFg/0?wx_fmt=jpeg","desc":"给你的笔记列一个目录","annotations":[{"id":1699712709504,"color":1,"style":0,"tags":[],"note":"","type":"paragraph","html":"10 + 篇自己的笔记","text":"10 + 篇自己的笔记","annote":"<sr-annote data-id=\"1699712709504\">10 + 篇自己的笔记</sr-annote>","items":[{"str":"10 + 篇自己的笔记","root":" 这篇仍然是使用类干货，当你积累了 10 + 篇自己的笔记，或许会需要它。"}]},{"id":1699712740314,"color":1,"style":0,"tags":[],"note":"","type":"paragraph","html":"一个目录","text":"一个目录","annote":"<sr-annote data-id=\"1699712740314\">一个目录</sr-annote>","items":[{"str":"一个目录","root":"假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。"}]},{"id":1699712761738,"color":1,"style":0,"tags":[],"note":"","type":"paragraph","html":"<sr-rd-content dangerouslysetinnerhtml=\"[object Object]\" data-reactid=\".0.3\" class=\"highlighter-context\"><section powered-by=\"xiumi.us\"><section powered-by=\"xiumi.us\"><ul><li><p><strong>字的笔记</strong>的目录</p></li><li><p>生成<strong>同一个标签的笔记</strong>的目录</p></li><li><p>生成<strong>同一个作者的书目</strong>的目录</p></li></ul><p>这时候，dataview 就派上用场了。</p><p>dataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。</p><p>我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。</p><p>如果你有这种需要的话，就接着看下去吧。</p></section><section powered-by=\"xiumi.us\" data-style=\"text-align: center; padding: 0px; letter-spacing: 3px; line-height: 1.8; font-size: 18px; color: rgb(255, 255, 255); text-shadow: rgb(51, 51, 51) 1px 1px, rgb(51, 51, 51) 1px -1px, rgb(51, 51, 51) -1px 1px, rgb(51, 51, 51) -1px -1px, rgb(51, 51, 51) 0px 1.4px, rgb(51, 51, 51) 0px -1.4px, rgb(51, 51, 51) -1.4px 0px, rgb(51, 51, 51) 1.4px 0px, rgb(255, 222, 23) 2px 2px, rgb(255, 222, 23) 3px 3px, rgb(255, 222, 23) 3px 1px, rgb(255, 222, 23) 1px 3px, rgb(255, 222, 23) 1px 1px, rgb(255, 222, 23) 2px 3.4px, rgb(255, 222, 23) 2px 0.6px, rgb(255, 222, 23) 0.6px 2px, rgb(255, 222, 23) 3.4px 2px; box-sizing: border-box; max-width: 100%;\"><p><span><strong><em>安装插件</em></strong></span></p></section><section powered-by=\"xiumi.us\"><p>众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：</p><p>1. 直接在 ` 第三方插件 -&gt; 社区插件 ` 搜索安装</p><p>2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）</p><p><strong>设置</strong>：该插件不需要修改任何设置即可使用。</p><p>接下来就开始生成目录吧！</p></section><section powered-by=\"xiumi.us\" data-style=\"text-align: center; padding: 0px; letter-spacing: 3px; line-height: 1.8; font-size: 18px; color: rgb(255, 255, 255); text-shadow: rgb(51, 51, 51) 1px 1px, rgb(51, 51, 51) 1px -1px, rgb(51, 51, 51) -1px 1px, rgb(51, 51, 51) -1px -1px, rgb(51, 51, 51) 0px 1.4px, rgb(51, 51, 51) 0px -1.4px, rgb(51, 51, 51) -1.4px 0px, rgb(51, 51, 51) 1.4px 0px, rgb(255, 222, 23) 2px 2px, rgb(255, 222, 23) 3px 3px, rgb(255, 222, 23) 3px 1px, rgb(255, 222, 23) 1px 3px, rgb(255, 222, 23) 1px 1px, rgb(255, 222, 23) 2px 3.4px, rgb(255, 222, 23) 2px 0.6px, rgb(255, 222, 23) 0.6px 2px, rgb(255, 222, 23) 3.4px 2px; box-sizing: border-box; max-width: 100%;\"><p><span><strong><em>使用</em></strong></span></p></section><section powered-by=\"xiumi.us\"><p>方法千千万，我只写三种生成目录的方式：</p><ol><li><p>从名字</p></li><li><p>从标签</p></li><li><p>从作者</p></li></ol><p>如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。</p></section><section powered-by=\"xiumi.us\"><section><section powered-by=\"xiumi.us\"><section data-style=\"display: inline-block; width: 30px; height: 30px; vertical-align: top; overflow: hidden; border: 0px none rgba(118, 178, 124, 0); border-radius: 100%; background-color: rgba(255, 230, 0, 0.64); box-sizing: border-box;\"><section powered-by=\"xiumi.us\"></section></section></section><section powered-by=\"xiumi.us\"><section><section powered-by=\"xiumi.us\" data-style=\"text-align: justify; color: rgb(0, 0, 0); box-sizing: border-box;\"><p><strong>从文件名</strong></p></section></section></section></section></section><section powered-by=\"xiumi.us\"><p>场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的<strong>名称中都有 “习惯” 两个字</strong>。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。</p><p>老规矩，先贴一个语法和效果图：</p><p><img data-ratio=\"0.44453125\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/TDibWgTpJibRXWeXmAA8gicMOo32IPdT2zbbjtUeYt8xCSQ4nzz1CVPDrWgX4Na6SBnYQyg4O9MxblgdKRUrL7iaKg/640?wx_fmt=png\" data-type=\"img\" data-w=\"1280\" data-index=\"1\" src=\"https://mmbiz.qpic.cn/mmbiz_png/TDibWgTpJibRXWeXmAA8gicMOo32IPdT2zbbjtUeYt8xCSQ4nzz1CVPDrWgX4Na6SBnYQyg4O9MxblgdKRUrL7iaKg/640?wx_fmt=png\" _width=\"677px\" crossorigin=\"anonymous\" alt=\"图片\" class=\"sr-rd-content-nobeautify sr-annote\" sr-annote-bb-color=\"true\" data-id=\"1699712728512\" data-color-type=\"1\"></p><p>下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？</p><p>首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。</p><p>在首行写上 `dataview`，插件就可以识别这部分代码了。</p><p><img data-galleryid=\"\" data-ratio=\"0.4533551554828151\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/TDibWgTpJibRXWeXmAA8gicMOo32IPdT2zby59xof54KgFsdbVaV7xUjdUGDEaZfq0Msgo8fUOGA7LiboreTsMsD1g/640?wx_fmt=png\" data-type=\"png\" data-w=\"1222\" data-index=\"2\" src=\"https://mmbiz.qpic.cn/mmbiz_png/TDibWgTpJibRXWeXmAA8gicMOo32IPdT2zby59xof54KgFsdbVaV7xUjdUGDEaZfq0Msgo8fUOGA7LiboreTsMsD1g/640?wx_fmt=png\" _width=\"677px\" crossorigin=\"anonymous\" alt=\"图片\" class=\"sr-rd-content-nobeautify\"></p><p>以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？</p><section><ul><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang=\"http\">```-&nbsp;list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n</pre></section><p>这样就可以了。</p><p>- list：你创建了一个列表 / 清淡。</p><p>- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。</p><p>- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记</p><p>如果你需要排序，就写 sort，不需要，留空就可以。</p><p>你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。</p><p><img data-ratio=\"0.9420783645655877\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/TDibWgTpJibRXWeXmAA8gicMOo32IPdT2zb1ribFOgYiby7ic2r6s8R6NGcy3ZphLqTFmOp7EI0ibib5W1HLNA0Ovz8EkA/640?wx_fmt=png\" data-type=\"png\" data-w=\"1174\" data-index=\"3\" src=\"https://mmbiz.qpic.cn/mmbiz_png/TDibWgTpJibRXWeXmAA8gicMOo32IPdT2zb1ribFOgYiby7ic2r6s8R6NGcy3ZphLqTFmOp7EI0ibib5W1HLNA0Ovz8EkA/640?wx_fmt=png\" _width=\"677px\" crossorigin=\"anonymous\" alt=\"图片\" class=\"sr-rd-content-nobeautify\"></p><p>上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。</p></section><section powered-by=\"xiumi.us\"><section><section powered-by=\"xiumi.us\"><section data-style=\"display: inline-block; width: 30px; height: 30px; vertical-align: top; overflow: hidden; border: 0px none rgba(118, 178, 124, 0); border-radius: 100%; background-color: rgba(255, 230, 0, 0.64); box-sizing: border-box;\"><section powered-by=\"xiumi.us\"></section></section></section><section powered-by=\"xiumi.us\"><section><section powered-by=\"xiumi.us\" data-style=\"text-align: justify; color: rgb(0, 0, 0); box-sizing: border-box;\"><p><strong>从标签</strong></p></section></section></section></section></section><section powered-by=\"xiumi.us\"><p>场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。</p><p>你该怎么写 dataview 语句呢？</p><p>还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。</p><section><ul><li></li><li></li><li></li><li></li></ul><pre data-lang=\"javascript\">```dataview\nlist \nfrom&nbsp;#时间管理\n```\n</pre></section><p>不需要排序的话，代码就是这么简单。</p><p>你学会了吗？</p><p>如果学会了，下面我们可以加点好玩的东西。</p></section><section powered-by=\"xiumi.us\"><section><section powered-by=\"xiumi.us\"><section data-style=\"display: inline-block; width: 30px; height: 30px; vertical-align: top; overflow: hidden; border: 0px none rgba(118, 178, 124, 0); border-radius: 100%; background-color: rgba(255, 230, 0, 0.64); box-sizing: border-box;\"><section powered-by=\"xiumi.us\"></section></section></section><section powered-by=\"xiumi.us\"><section><section powered-by=\"xiumi.us\" data-style=\"text-align: justify; color: rgb(0, 0, 0); box-sizing: border-box;\"><p><strong>从作者</strong></p></section></section></section></section></section><section powered-by=\"xiumi.us\"><p>场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？</p><p>哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？</p><p>我们自己加属性！</p><p>这时候，yml 就派上用场了。</p><p><span data-style=\"caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-size: 16px;\">👉</span> <span data-style=\"background-color: rgb(255, 251, 0);\">用 YML 给笔记加点元素</span></p><p>简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。</p><p>各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。</p><p>所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。</p><p>yml 语法大概长这样：</p></section><section><ul><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang=\"http\">---\ntitle:&nbsp;标题名字\nauthor: 作者名\ntags: [标签1]\n---\n</pre></section><section powered-by=\"xiumi.us\"></section><section powered-by=\"xiumi.us\"><p><strong>yml 的规则：</strong></p><p>1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？</p><p>2、必须写在文件最上方</p><p>里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：</p></section><section><ul><li></li><li></li><li></li></ul><pre data-lang=\"javascript\">```\n作者: 鲁迅 \n```\n</pre></section><section powered-by=\"xiumi.us\"><p>我就给笔记加了 “作者” 这个属性。</p><p>然后我们就可以使用 “作者” 作为条件建立目录了。</p><p><span data-style=\"caret-color: rgb(0, 0, 0); color: rgb(0, 0, 0); font-size: 16px;\">👉</span> <span data-style=\"background-color: rgb(255, 251, 0);\">dataview 使用 yml 的元素</span></p><p>where 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：</p><section><ul><li></li><li></li><li></li><li></li><li></li></ul><pre data-lang=\"http\">```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n</pre></section><p>看下效果：</p><p><img data-ratio=\"0.6515625\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/TDibWgTpJibRXWeXmAA8gicMOo32IPdT2zbkzJLNIiamfZASvELpKL6LsLdtH6UEl5W6SDz6aZ8ibG68KcnvPszoNNw/640?wx_fmt=png\" data-type=\"png\" data-w=\"1280\" data-index=\"4\" src=\"https://mmbiz.qpic.cn/mmbiz_png/TDibWgTpJibRXWeXmAA8gicMOo32IPdT2zbkzJLNIiamfZASvELpKL6LsLdtH6UEl5W6SDz6aZ8ibG68KcnvPszoNNw/640?wx_fmt=png\" _width=\"677px\" crossorigin=\"anonymous\" alt=\"图片\" class=\"sr-rd-content-nobeautify\"></p><p>上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。</p><p>嗯哼，鲁迅合集就做好了。</p></section><section powered-by=\"xiumi.us\" data-style=\"text-align: center; padding: 0px; letter-spacing: 3px; line-height: 1.8; font-size: 18px; color: rgb(255, 255, 255); text-shadow: rgb(51, 51, 51) 1px 1px, rgb(51, 51, 51) 1px -1px, rgb(51, 51, 51) -1px 1px, rgb(51, 51, 51) -1px -1px, rgb(51, 51, 51) 0px 1.4px, rgb(51, 51, 51) 0px -1.4px, rgb(51, 51, 51) -1.4px 0px, rgb(51, 51, 51) 1.4px 0px, rgb(255, 222, 23) 2px 2px, rgb(255, 222, 23) 3px 3px, rgb(255, 222, 23) 3px 1px, rgb(255, 222, 23) 1px 3px, rgb(255, 222, 23) 1px 1px, rgb(255, 222, 23) 2px 3.4px, rgb(255, 222, 23) 2px 0.6px, rgb(255, 222, 23) 0.6px 2px, rgb(255, 222, 23) 3.4px 2px; box-sizing: border-box; max-width: 100%;\"><p><span><strong><em>扩展：创建一个书目列表吧！</em></strong></span></p></section><section powered-by=\"xiumi.us\"><p>上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。</p><p>现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。</p><p>还记得上面列表中的展示形式吗？</p><p>对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。</p><p>不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。</p><p>先贴一下代码看看吧:</p><p><img data-ratio=\"0.71875\" data-s=\"300,640\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/TDibWgTpJibRXWeXmAA8gicMOo32IPdT2zbhRicb1nabvNqBWniawAm2tdl98F1L1JDhibyBGDuTpuyhdxGZHmtjUQQA/640?wx_fmt=png\" data-type=\"png\" data-w=\"1280\" data-index=\"5\" src=\"https://mmbiz.qpic.cn/mmbiz_png/TDibWgTpJibRXWeXmAA8gicMOo32IPdT2zbhRicb1nabvNqBWniawAm2tdl98F1L1JDhibyBGDuTpuyhdxGZHmtjUQQA/640?wx_fmt=png\" _width=\"677px\" crossorigin=\"anonymous\" alt=\"图片\" class=\"sr-rd-content-nobeautify\"></p><p>上面唯一的变化就是 table 这一行：</p><section><ul><li></li></ul><pre data-lang=\"javascript\">table author,from,tags\n</pre></section><p>table 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。<br></p><p>where 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。</p><p>sort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。</p><p>怎么样，你学会了吗？</p></section></section><section powered-by=\"xiumi.us\"><section powered-by=\"xiumi.us\"><section data-style=\"color: rgb(0, 0, 0); margin: 10px 0%; box-sizing: border-box; max-width: 100%;\"><section powered-by=\"xiumi.us\"><section data-style=\"text-align: center; padding: 0px; letter-spacing: 3px; line-height: 1.8; font-size: 20px; color: rgb(255, 255, 255); text-shadow: rgb(51, 51, 51) 1px 1px, rgb(51, 51, 51) 1px -1px, rgb(51, 51, 51) -1px 1px, rgb(51, 51, 51) -1px -1px, rgb(51, 51, 51) 0px 1.4px, rgb(51, 51, 51) 0px -1.4px, rgb(51, 51, 51) -1.4px 0px, rgb(51, 51, 51) 1.4px 0px, rgb(255, 222, 23) 2px 2px, rgb(255, 222, 23) 3px 3px, rgb(255, 222, 23) 3px 1px, rgb(255, 222, 23) 1px 3px, rgb(255, 222, 23) 1px 1px, rgb(255, 222, 23) 2px 3.4px, rgb(255, 222, 23) 2px 0.6px, rgb(255, 222, 23) 0.6px 2px, rgb(255, 222, 23) 3.4px 2px; box-sizing: border-box; max-width: 100%;\"><p><strong><em>- End -</em></strong></p></section></section></section></section><section powered-by=\"xiumi.us\"><p data-style=\"color: rgb(0, 0, 0); text-align: center; white-space: normal; margin: 0px; padding: 0px; box-sizing: border-box;\"><span> 以上，dataview 常用的内容就讲完啦。task 展示类型就暂时不讲了，使用的不多。</span></p><p><span>如果你有什么不明白的，</span><span>也</span><span>可以在</span><span>留言区</span><span>告诉</span><span>我</span></p><p data-style=\"color: rgb(0, 0, 0); text-align: center; white-space: normal; margin: 0px; padding: 0px; box-sizing: border-box;\"><span data-style=\"color: rgb(255, 202, 0); box-sizing: border-box;\">谢谢你看到这里</span></p><p data-style=\"color: rgb(0, 0, 0); text-align: center; white-space: normal; margin: 0px; padding: 0px; box-sizing: border-box;\"><span>下期见！</span></p></section></section></sr-rd-content><sr-rd-footer data-reactid=\".0.5\"><sr-rd-footer-group data-reactid=\".0.5.0\"><sr-rd-footer-line data-reactid=\".0.5.0.0\"></sr-rd-footer-line><sr-rd-footer-text data-reactid=\".0.5.0.1\">全文完</sr-rd-footer-text><sr-rd-footer-line data-reactid=\".0.5.0.2\"></sr-rd-footer-line></sr-rd-footer-group><sr-rd-footer-copywrite data-reactid=\".0.5.1\"><div data-reactid=\".0.5.1.0\"><span data-reactid=\".0.5.1.0.0\">本文由 </span><a href=\"http://ksria.com/simpread\" target=\"_blank\" data-reactid=\".0.5.1.0.1\">简悦 SimpRead</a><span data-reactid=\".0.5.1.0.2\"> 优化，用以提升阅读体验</span></div><div class=\"second\" data-reactid=\".0.5.1.1\"><span data-reactid=\".0.5.1.1.0\">使用了 </span><abbr data-reactid=\".0.5.1.1.1\"><span data-reactid=\".0.5.1.1.1.0\">全新的简悦词法分析引擎</span><sup data-reactid=\".0.5.1.1.1.1\"> beta</sup></abbr><span data-reactid=\".0.5.1.1.2\">，</span><a target=\"_blank\" href=\"http://ksria.com/simpread/docs/#/词法分析引擎\" data-reactid=\".0.5.1.1.3\">点击查看</a><span data-reactid=\".0.5.1.1.4\">详细说明</span></div><div class=\"third\" data-reactid=\".0.5.1.2\"><a class=\"sr-icon good sr-top\" aria-label=\"觉得不错？请帮忙投票 😄\" data-balloon-pos=\"up\" target=\"_blank\" data-reactid=\".0.5.1.2.0\"><svg t=\"1556354786433\" viewBox=\"0 0 1024 1024\" version=\"1.1\" width=\"33\" height=\"33\"><defs><style type=\"text/css\"></style></defs><path d=\"M859.8 191.2c-80.8-84.2-212-84.2-292.8 0L512 248.2l-55-57.2c-81-84.2-212-84.2-292.8 0-91 94.6-91 248.2 0 342.8L512 896l347.8-362C950.8 439.4 950.8 285.8 859.8 191.2z\" p-id=\"6225\" fill=\"#8C8C8C\"></path></svg></a><a class=\"sr-icon bad sr-top\" aria-label=\"有待改进，请帮忙吐槽 😄\" data-balloon-pos=\"up\" target=\"_blank\" data-reactid=\".0.5.1.2.1\"><svg t=\"1556354650943\" viewBox=\"0 0 1024 1024\" version=\"1.1\" p-id=\"5899\" width=\"33\" height=\"33\"><defs><style type=\"text/css\"></style></defs><path d=\"M458 576c2-36 0-76 16-110 4-10 2-20 2-30-8-42-28-80-30-120 0-2.78 2.008-9.542 2.01-12.314-6.432 4.468-15.214 8.048-22.01 10.314-40 12-35.02 5.146-69.02 27.146l-23.866 14.456c32.686-35.878 77.056-49.562 113.05-77.428 0.388-30.876 1.716-61.354 6.274-91.68C371.22 106.992 243.57 108.536 164.246 191.14c-90.994 94.688-90.994 248.202 0 342.89l305.698 318.192c-0.17-21.312-0.886-42.352-3.944-62.222C454 718 458 648 458 576z\" p-id=\"5900\" fill=\"#8C8C8C\"></path><path d=\"M644 602c-22-52-66-88-126-100-1.7 0-3.758-1.086-5.872-2.638-0.046 0.214-0.082 0.426-0.128 0.638-22 96-46 188-42 284 0 24.454 7.966 50.234 7.666 76.262L512 896l208-216.5C690.306 658.542 660.856 637.242 644 602z\" p-id=\"5901\" fill=\"#8C8C8C\"></path><path d=\"M859.748 191.14c-80.852-84.188-211.978-84.188-292.816 0L528 230.806c0.15 26.35 0.426 52.404-6 77.194-4 20-38 38-32 62 6.006 26.426 16.332 51.41 21.464 77.118C542.028 464.168 569.542 485.792 594 512c45.602 53.532 75.494 114.918 130.566 162.742l135.182-140.71C950.75 439.342 950.75 285.828 859.748 191.14z\" p-id=\"5902\" fill=\"#8C8C8C\"></path></svg></a></div></sr-rd-footer-copywrite></sr-rd-footer><sr-rd-crlbar class=\"\" style=\"z-index:2;\" data-reactid=\".0.6\"><fap style=\"display:-webkit-box;-webkit-box-align:center;-webkit-box-orient:vertical;-webkit-box-direction:reverse;position:fixed;bottom:45px;right:24px;width:auto;height:auto;\" data-reactid=\".0.6.0\"><a style=\"display:block;position:relative;margin:0 0 15px;padding:0;width:56px;height:56px;line-height:56px;color:#fff;background-color:rgba(244, 67, 54, 1);border-radius:50%;cursor:pointer;box-shadow:0 2px 2px 0 rgba(0,0,0,0.14), 0 1px 5px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.2);z-index:2;transform:rotate(0deg);\" class=\"md-waves-effect md-waves-circle md-waves-float\" data-reactid=\".0.6.0.0\" aria-label=\"关闭\" data-balloon-pos=\"up\"><i id=\"exit\" type=\"spec\" name=\"关闭\" color=\"rgba(244, 67, 54, 1)\" style=\"display:block;width:100%;height:100%;border:none;background-position:center;background-repeat:no-repeat;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAAdklEQVQ4y+WTuQ3AIBAEaQKK8NN/BEUArmccgGyj43MMIZo5TqtFqbUPJxYtbg2OvS44IJQKhguwdUETSiXjXr77KhGICRjihWKm8Dw3KXP4Z5VZ/Lfw7B5kyD1cy5C7uAx5iJcht6vhRTUi4OrC0Szftvi/vAFNdbZ2Dp661QAAAABJRU5ErkJggg==);\" data-reactid=\".0.6.0.0.0\"></i></a><a style=\"display:block;position:relative;margin:0 0 15px;padding:0;width:40px;height:40px;line-height:40px;color:#fff;background-color:rgba(245, 82, 70, .8);border-radius:50%;cursor:pointer;box-shadow:0 2px 2px 0 rgba(0,0,0,0.14), 0 1px 5px 0 rgba(0,0,0,0.12), 0 3px 1px -2px rgba(0,0,0,0.2);\" class=\"md-waves-effect md-waves-circle md-waves-float\" data-reactid=\".0.6.0.1\" aria-label=\"\" data-balloon-pos=\"up\"><i id=\"anchor\" type=\"anchor\" name=\"更多\" color=\"rgba(245, 82, 70, .8)\" style=\"display:block;width:100%;height:100%;border:none;background-position:center;background-repeat:no-repeat;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAQAAABKfvVzAAAANElEQVQ4T+3GMQ0AIAwAMAwSEvwLACai3HtmAHq1te8xpnCM6okAu3rigFU9MWxLr/695AI0E1VgH26hCQAAAABJRU5ErkJggg==);\" data-reactid=\".0.6.0.1.0\"></i></a><panel-bg data-reactid=\".0.6.0.2\" style=\"display: none; position: fixed; top: 0px; left: 0px; width: 100%; height: 100%; opacity: 0;\"></panel-bg><sr-annote-trigger class=\"open\" data-balloon-pos=\"up\" aria-label=\"停用标注\"><sr-i class=\"md-waves-effect\"><svg viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" width=\"22\" height=\"22\"><path d=\"M724.010667 280.021333l89.984-89.984 59.989333 59.989333-89.984 91.989333zM150.016 249.984l59.989333-59.989333 89.984 89.984-59.989333 61.994667zM470.016 86.016l84.010667 0 0 128-84.010667 0 0-128zM256 598.016l0-214.016 512 0 0 214.016-128 128 0 212.010667-256 0 0-212.010667z\" fill=\"#ffffff\"></path></svg></sr-i></sr-annote-trigger></fap></sr-rd-crlbar><toc-bg class=\"\"></toc-bg>","text":"字的笔记的目录同一个标签的笔记生成的目录同一个作者的书目生成的目录这时候，dataview 就派上用场了。dataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。如果你有这种需要的话，就接着看下去吧。安装插件众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）设置：该插件不需要修改任何设置即可使用。接下来就开始生成目录吧！使用方法千千万，我只写三种生成目录的方式：从名字从标签从作者如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。从文件名场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。老规矩，先贴一个语法和效果图：下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。在首行写上 `dataview`，插件就可以识别这部分代码了。以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n这样就可以了。- list：你创建了一个列表 / 清淡。- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记如果你需要排序，就写 sort，不需要，留空就可以。你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。从标签场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。你该怎么写 dataview 语句呢？还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。```dataview\nlist \nfrom #时间管理\n```\n不需要排序的话，代码就是这么简单。你学会了吗？如果学会了，下面我们可以加点好玩的东西。从作者场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？我们自己加属性！这时候，yml 就派上用场了。👉用 YML 给笔记加点元素简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。yml 语法大概长这样：---\ntitle: 标题名字\nauthor: 作者名\ntags: [标签1]\n---\nyml 的规则：1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？2、必须写在文件最上方里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：```\n作者: 鲁迅 \n```\n我就给笔记加了 “作者” 这个属性。然后我们就可以使用 “作者” 作为条件建立目录了。👉dataview 使用 yml 的元素where 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n看下效果：上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。嗯哼，鲁迅合集就做好了。扩展：创建一个书目列表吧！上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。还记得上面列表中的展示形式吗？对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。先贴一下代码看看吧:上面唯一的变化就是 table 这一行：table author,from,tags\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。where 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。sort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。怎么样，你学会了吗？- End -以上，dataview 常用的内容就讲完啦。task 展示类型就暂时不讲了，使用的不多。如果你有什么不明白的，也可以在留言区告诉我谢谢你看到这里下期见！","annote":"<sr-annote data-id=\"1699712761738\">字的笔记</sr-annote><sr-annote data-id=\"1699712761738\">的目录</sr-annote><sr-annote data-id=\"1699712761738\">同一个标签的笔记</sr-annote><sr-annote data-id=\"1699712761738\">生成</sr-annote><sr-annote data-id=\"1699712761738\">的目录</sr-annote><sr-annote data-id=\"1699712761738\">同一个作者的书目</sr-annote><sr-annote data-id=\"1699712761738\">生成</sr-annote><sr-annote data-id=\"1699712761738\">的目录</sr-annote><sr-annote data-id=\"1699712761738\">这时候，dataview 就派上用场了。</sr-annote><sr-annote data-id=\"1699712761738\">dataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。</sr-annote><sr-annote data-id=\"1699712761738\">我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。</sr-annote><sr-annote data-id=\"1699712761738\">如果你有这种需要的话，就接着看下去吧。</sr-annote><sr-annote data-id=\"1699712761738\">安装插件</sr-annote><sr-annote data-id=\"1699712761738\">众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：</sr-annote><sr-annote data-id=\"1699712761738\">1. 直接在 ` 第三方插件 -&gt; 社区插件 ` 搜索安装</sr-annote><sr-annote data-id=\"1699712761738\">2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）</sr-annote><sr-annote data-id=\"1699712761738\">设置</sr-annote><sr-annote data-id=\"1699712761738\">：该插件不需要修改任何设置即可使用。</sr-annote><sr-annote data-id=\"1699712761738\">接下来就开始生成目录吧！</sr-annote><sr-annote data-id=\"1699712761738\">使用</sr-annote><sr-annote data-id=\"1699712761738\">方法千千万，我只写三种生成目录的方式：</sr-annote><sr-annote data-id=\"1699712761738\">从名字</sr-annote><sr-annote data-id=\"1699712761738\">从标签</sr-annote><sr-annote data-id=\"1699712761738\">从作者</sr-annote><sr-annote data-id=\"1699712761738\">如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。</sr-annote><sr-annote data-id=\"1699712761738\">从文件名</sr-annote><sr-annote data-id=\"1699712761738\">场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的</sr-annote><sr-annote data-id=\"1699712761738\">名称中都有 “习惯” 两个字</sr-annote><sr-annote data-id=\"1699712761738\">。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。</sr-annote><sr-annote data-id=\"1699712761738\">老规矩，先贴一个语法和效果图：</sr-annote><sr-annote data-id=\"1699712761738\">下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？</sr-annote><sr-annote data-id=\"1699712761738\">首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。</sr-annote><sr-annote data-id=\"1699712761738\">在首行写上 `dataview`，插件就可以识别这部分代码了。</sr-annote><sr-annote data-id=\"1699712761738\">以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？</sr-annote><sr-annote data-id=\"1699712761738\">```-&nbsp;list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n</sr-annote><sr-annote data-id=\"1699712761738\">这样就可以了。</sr-annote><sr-annote data-id=\"1699712761738\">- list：你创建了一个列表 / 清淡。</sr-annote><sr-annote data-id=\"1699712761738\">- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。</sr-annote><sr-annote data-id=\"1699712761738\">- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记</sr-annote><sr-annote data-id=\"1699712761738\">如果你需要排序，就写 sort，不需要，留空就可以。</sr-annote><sr-annote data-id=\"1699712761738\">你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。</sr-annote><sr-annote data-id=\"1699712761738\">上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。</sr-annote><sr-annote data-id=\"1699712761738\">从标签</sr-annote><sr-annote data-id=\"1699712761738\">场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。</sr-annote><sr-annote data-id=\"1699712761738\">你该怎么写 dataview 语句呢？</sr-annote><sr-annote data-id=\"1699712761738\">还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。</sr-annote><sr-annote data-id=\"1699712761738\">```dataview\nlist \nfrom&nbsp;#时间管理\n```\n</sr-annote><sr-annote data-id=\"1699712761738\">不需要排序的话，代码就是这么简单。</sr-annote><sr-annote data-id=\"1699712761738\">你学会了吗？</sr-annote><sr-annote data-id=\"1699712761738\">如果学会了，下面我们可以加点好玩的东西。</sr-annote><sr-annote data-id=\"1699712761738\">从作者</sr-annote><sr-annote data-id=\"1699712761738\">场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？</sr-annote><sr-annote data-id=\"1699712761738\">哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？</sr-annote><sr-annote data-id=\"1699712761738\">我们自己加属性！</sr-annote><sr-annote data-id=\"1699712761738\">这时候，yml 就派上用场了。</sr-annote><sr-annote data-id=\"1699712761738\">👉</sr-annote><sr-annote data-id=\"1699712761738\">用 YML 给笔记加点元素</sr-annote><sr-annote data-id=\"1699712761738\">简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。</sr-annote><sr-annote data-id=\"1699712761738\">各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。</sr-annote><sr-annote data-id=\"1699712761738\">所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。</sr-annote><sr-annote data-id=\"1699712761738\">yml 语法大概长这样：</sr-annote><sr-annote data-id=\"1699712761738\">---\ntitle:&nbsp;标题名字\nauthor: 作者名\ntags: [标签1]\n---\n</sr-annote><sr-annote data-id=\"1699712761738\">yml 的规则：</sr-annote><sr-annote data-id=\"1699712761738\">1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？</sr-annote><sr-annote data-id=\"1699712761738\">2、必须写在文件最上方</sr-annote><sr-annote data-id=\"1699712761738\">里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：</sr-annote><sr-annote data-id=\"1699712761738\">```\n作者: 鲁迅 \n```\n</sr-annote><sr-annote data-id=\"1699712761738\">我就给笔记加了 “作者” 这个属性。</sr-annote><sr-annote data-id=\"1699712761738\">然后我们就可以使用 “作者” 作为条件建立目录了。</sr-annote><sr-annote data-id=\"1699712761738\">👉</sr-annote><sr-annote data-id=\"1699712761738\">dataview 使用 yml 的元素</sr-annote><sr-annote data-id=\"1699712761738\">where 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：</sr-annote><sr-annote data-id=\"1699712761738\">```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n</sr-annote><sr-annote data-id=\"1699712761738\">看下效果：</sr-annote><sr-annote data-id=\"1699712761738\">上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。</sr-annote><sr-annote data-id=\"1699712761738\">嗯哼，鲁迅合集就做好了。</sr-annote><sr-annote data-id=\"1699712761738\">扩展：创建一个书目列表吧！</sr-annote><sr-annote data-id=\"1699712761738\">上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。</sr-annote><sr-annote data-id=\"1699712761738\">现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。</sr-annote><sr-annote data-id=\"1699712761738\">还记得上面列表中的展示形式吗？</sr-annote><sr-annote data-id=\"1699712761738\">对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。</sr-annote><sr-annote data-id=\"1699712761738\">不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。</sr-annote><sr-annote data-id=\"1699712761738\">先贴一下代码看看吧:</sr-annote><sr-annote data-id=\"1699712761738\">上面唯一的变化就是 table 这一行：</sr-annote><sr-annote data-id=\"1699712761738\">table author,from,tags\n</sr-annote><sr-annote data-id=\"1699712761738\">table 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。</sr-annote><sr-annote data-id=\"1699712761738\">where 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。</sr-annote><sr-annote data-id=\"1699712761738\">sort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。</sr-annote><sr-annote data-id=\"1699712761738\">怎么样，你学会了吗？</sr-annote><sr-annote data-id=\"1699712761738\">- End -</sr-annote><sr-annote data-id=\"1699712761738\"> 以上，dataview 常用的内容就讲完啦。task 展示类型就暂时不讲了，使用的不多。</sr-annote><sr-annote data-id=\"1699712761738\">如果你有什么不明白的，</sr-annote><sr-annote data-id=\"1699712761738\">也</sr-annote><sr-annote data-id=\"1699712761738\">可以在</sr-annote><sr-annote data-id=\"1699712761738\">留言区</sr-annote><sr-annote data-id=\"1699712761738\">告诉</sr-annote><sr-annote data-id=\"1699712761738\">我</sr-annote><sr-annote data-id=\"1699712761738\">谢谢你看到这里</sr-annote><sr-annote data-id=\"1699712761738\">下期见！</sr-annote>","items":[{"str":"字的笔记","root":"包含同样关键字的笔记"},{"str":"的目录","root":"生成包含同样关键字的笔记的目录"},{"str":"同一个标签的笔记","root":"生成同一个标签的笔记的目录"},{"str":"生成","root":"生成同一个标签的笔记的目录"},{"str":"的目录","root":"生成同一个标签的笔记的目录"},{"str":"同一个作者的书目","root":"生成同一个作者的书目的目录"},{"str":"生成","root":"生成同一个作者的书目的目录"},{"str":"的目录","root":"生成同一个作者的书目的目录"},{"str":"这时候，dataview 就派上用场了。","root":"假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。"},{"str":"dataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。","root":"假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。"},{"str":"我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。","root":"假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。"},{"str":"如果你有这种需要的话，就接着看下去吧。","root":"假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。"},{"str":"安装插件","root":"写在前面\n\n 距离上次发布 obsidian 使用类的文章已经一个月了，这段时间大家过得怎么样？有把 obsidian 用起来吗？\n\n 这篇仍然是使用类干货，当你积累了 10 + 篇自己的笔记，或许会需要它。\n\n 写笔记也好，做什么东西也好，我认为很忌讳的一点是过度设计，废了很大的功夫想要在一切开始之前造一个完美的轮子，结果造完之后极大可能你的记笔记热情已经没有了。\n\n 所以我不建议你等待，等待任何笔记流程的设计。不是有了完美工作流之后你才能开始工作，而是做着做着就根据自己的场景和需要慢慢铺就了适合你的工作流。\n\n 这也是渐进式笔记的概念。ob 当时带着双链和关系图谱出现，本意就是让使用者渐进式的搭建自己的知识库。\n\n 渐进式的观点还能很好的改善完美主义。（刚看完《如何成为不完美主义》的一点小启发。）\n\n这也就是我为什么说等你积累到 10 篇以上，会需要这篇文章。如果你才开始记笔记，请先放下一切问题记起来。\n\n言归正传，来看看 dataview 的使用场景。\n\n使用场景\n\n假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。\n\n安装插件\n\n众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！\n\n使用\n\n方法千千万，我只写三种生成目录的方式：\n\n从名字\n\n从标签\n\n从作者\n\n如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。\n\n从文件名\n\n场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。\n\n从标签\n\n场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。\n\n从作者\n\n场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样：\n\n---\ntitle: 标题名字\nauthor: 作者名\ntags: [标签1]\n---\n\n\nyml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：\n\n```\n作者: 鲁迅 \n```\n\n\n我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。\n\n扩展：创建一个书目列表吧！\n\n上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：","root":"众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！"},{"str":"1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装","root":"众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！"},{"str":"2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）","root":"众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！"},{"str":"设置","root":"设置：该插件不需要修改任何设置即可使用。"},{"str":"：该插件不需要修改任何设置即可使用。","root":"设置：该插件不需要修改任何设置即可使用。"},{"str":"接下来就开始生成目录吧！","root":"众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！"},{"str":"使用","root":"写在前面\n\n 距离上次发布 obsidian 使用类的文章已经一个月了，这段时间大家过得怎么样？有把 obsidian 用起来吗？\n\n 这篇仍然是使用类干货，当你积累了 10 + 篇自己的笔记，或许会需要它。\n\n 写笔记也好，做什么东西也好，我认为很忌讳的一点是过度设计，废了很大的功夫想要在一切开始之前造一个完美的轮子，结果造完之后极大可能你的记笔记热情已经没有了。\n\n 所以我不建议你等待，等待任何笔记流程的设计。不是有了完美工作流之后你才能开始工作，而是做着做着就根据自己的场景和需要慢慢铺就了适合你的工作流。\n\n 这也是渐进式笔记的概念。ob 当时带着双链和关系图谱出现，本意就是让使用者渐进式的搭建自己的知识库。\n\n 渐进式的观点还能很好的改善完美主义。（刚看完《如何成为不完美主义》的一点小启发。）\n\n这也就是我为什么说等你积累到 10 篇以上，会需要这篇文章。如果你才开始记笔记，请先放下一切问题记起来。\n\n言归正传，来看看 dataview 的使用场景。\n\n使用场景\n\n假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。\n\n安装插件\n\n众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！\n\n使用\n\n方法千千万，我只写三种生成目录的方式：\n\n从名字\n\n从标签\n\n从作者\n\n如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。\n\n从文件名\n\n场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。\n\n从标签\n\n场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。\n\n从作者\n\n场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样：\n\n---\ntitle: 标题名字\nauthor: 作者名\ntags: [标签1]\n---\n\n\nyml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：\n\n```\n作者: 鲁迅 \n```\n\n\n我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。\n\n扩展：创建一个书目列表吧！\n\n上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"方法千千万，我只写三种生成目录的方式：","root":"方法千千万，我只写三种生成目录的方式：\n\n从名字\n\n从标签\n\n从作者\n\n如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。"},{"str":"从名字","root":"从名字\n\n从标签\n\n从作者"},{"str":"从标签","root":"从名字\n\n从标签\n\n从作者"},{"str":"从作者","root":"从名字\n\n从标签\n\n从作者"},{"str":"如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。","root":"方法千千万，我只写三种生成目录的方式：\n\n从名字\n\n从标签\n\n从作者\n\n如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。"},{"str":"从文件名","root":"写在前面\n\n 距离上次发布 obsidian 使用类的文章已经一个月了，这段时间大家过得怎么样？有把 obsidian 用起来吗？\n\n 这篇仍然是使用类干货，当你积累了 10 + 篇自己的笔记，或许会需要它。\n\n 写笔记也好，做什么东西也好，我认为很忌讳的一点是过度设计，废了很大的功夫想要在一切开始之前造一个完美的轮子，结果造完之后极大可能你的记笔记热情已经没有了。\n\n 所以我不建议你等待，等待任何笔记流程的设计。不是有了完美工作流之后你才能开始工作，而是做着做着就根据自己的场景和需要慢慢铺就了适合你的工作流。\n\n 这也是渐进式笔记的概念。ob 当时带着双链和关系图谱出现，本意就是让使用者渐进式的搭建自己的知识库。\n\n 渐进式的观点还能很好的改善完美主义。（刚看完《如何成为不完美主义》的一点小启发。）\n\n这也就是我为什么说等你积累到 10 篇以上，会需要这篇文章。如果你才开始记笔记，请先放下一切问题记起来。\n\n言归正传，来看看 dataview 的使用场景。\n\n使用场景\n\n假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。\n\n安装插件\n\n众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！\n\n使用\n\n方法千千万，我只写三种生成目录的方式：\n\n从名字\n\n从标签\n\n从作者\n\n如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。\n\n从文件名\n\n场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。\n\n从标签\n\n场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。\n\n从作者\n\n场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样：\n\n---\ntitle: 标题名字\nauthor: 作者名\ntags: [标签1]\n---\n\n\nyml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：\n\n```\n作者: 鲁迅 \n```\n\n\n我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。\n\n扩展：创建一个书目列表吧！\n\n上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。"},{"str":"名称中都有 “习惯” 两个字","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。"},{"str":"。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。"},{"str":"老规矩，先贴一个语法和效果图：","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"在首行写上 `dataview`，插件就可以识别这部分代码了。","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"这样就可以了。","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"- list：你创建了一个列表 / 清淡。","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"如果你需要排序，就写 sort，不需要，留空就可以。","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。","root":"场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。"},{"str":"从标签","root":"写在前面\n\n 距离上次发布 obsidian 使用类的文章已经一个月了，这段时间大家过得怎么样？有把 obsidian 用起来吗？\n\n 这篇仍然是使用类干货，当你积累了 10 + 篇自己的笔记，或许会需要它。\n\n 写笔记也好，做什么东西也好，我认为很忌讳的一点是过度设计，废了很大的功夫想要在一切开始之前造一个完美的轮子，结果造完之后极大可能你的记笔记热情已经没有了。\n\n 所以我不建议你等待，等待任何笔记流程的设计。不是有了完美工作流之后你才能开始工作，而是做着做着就根据自己的场景和需要慢慢铺就了适合你的工作流。\n\n 这也是渐进式笔记的概念。ob 当时带着双链和关系图谱出现，本意就是让使用者渐进式的搭建自己的知识库。\n\n 渐进式的观点还能很好的改善完美主义。（刚看完《如何成为不完美主义》的一点小启发。）\n\n这也就是我为什么说等你积累到 10 篇以上，会需要这篇文章。如果你才开始记笔记，请先放下一切问题记起来。\n\n言归正传，来看看 dataview 的使用场景。\n\n使用场景\n\n假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。\n\n安装插件\n\n众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！\n\n使用\n\n方法千千万，我只写三种生成目录的方式：\n\n从名字\n\n从标签\n\n从作者\n\n如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。\n\n从文件名\n\n场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。\n\n从标签\n\n场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。\n\n从作者\n\n场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样：\n\n---\ntitle: 标题名字\nauthor: 作者名\ntags: [标签1]\n---\n\n\nyml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：\n\n```\n作者: 鲁迅 \n```\n\n\n我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。\n\n扩展：创建一个书目列表吧！\n\n上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。","root":"场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。"},{"str":"你该怎么写 dataview 语句呢？","root":"场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。"},{"str":"还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。","root":"场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。"},{"str":"```dataview\nlist \nfrom #时间管理\n```\n","root":"场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。"},{"str":"不需要排序的话，代码就是这么简单。","root":"场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。"},{"str":"你学会了吗？","root":"场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。"},{"str":"如果学会了，下面我们可以加点好玩的东西。","root":"场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。"},{"str":"从作者","root":"写在前面\n\n 距离上次发布 obsidian 使用类的文章已经一个月了，这段时间大家过得怎么样？有把 obsidian 用起来吗？\n\n 这篇仍然是使用类干货，当你积累了 10 + 篇自己的笔记，或许会需要它。\n\n 写笔记也好，做什么东西也好，我认为很忌讳的一点是过度设计，废了很大的功夫想要在一切开始之前造一个完美的轮子，结果造完之后极大可能你的记笔记热情已经没有了。\n\n 所以我不建议你等待，等待任何笔记流程的设计。不是有了完美工作流之后你才能开始工作，而是做着做着就根据自己的场景和需要慢慢铺就了适合你的工作流。\n\n 这也是渐进式笔记的概念。ob 当时带着双链和关系图谱出现，本意就是让使用者渐进式的搭建自己的知识库。\n\n 渐进式的观点还能很好的改善完美主义。（刚看完《如何成为不完美主义》的一点小启发。）\n\n这也就是我为什么说等你积累到 10 篇以上，会需要这篇文章。如果你才开始记笔记，请先放下一切问题记起来。\n\n言归正传，来看看 dataview 的使用场景。\n\n使用场景\n\n假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。\n\n安装插件\n\n众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！\n\n使用\n\n方法千千万，我只写三种生成目录的方式：\n\n从名字\n\n从标签\n\n从作者\n\n如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。\n\n从文件名\n\n场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。\n\n从标签\n\n场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。\n\n从作者\n\n场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样：\n\n---\ntitle: 标题名字\nauthor: 作者名\ntags: [标签1]\n---\n\n\nyml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：\n\n```\n作者: 鲁迅 \n```\n\n\n我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。\n\n扩展：创建一个书目列表吧！\n\n上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？","root":"场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样："},{"str":"哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？","root":"场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样："},{"str":"我们自己加属性！","root":"场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样："},{"str":"这时候，yml 就派上用场了。","root":"场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样："},{"str":"👉","root":"👉 用 YML 给笔记加点元素"},{"str":"用 YML 给笔记加点元素","root":"👉 用 YML 给笔记加点元素"},{"str":"简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。","root":"场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样："},{"str":"各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。","root":"场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样："},{"str":"所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。","root":"场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样："},{"str":"yml 语法大概长这样：","root":"场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样："},{"str":"---\ntitle: 标题名字\nauthor: 作者名\ntags: [标签1]\n---\n","root":"写在前面\n\n 距离上次发布 obsidian 使用类的文章已经一个月了，这段时间大家过得怎么样？有把 obsidian 用起来吗？\n\n 这篇仍然是使用类干货，当你积累了 10 + 篇自己的笔记，或许会需要它。\n\n 写笔记也好，做什么东西也好，我认为很忌讳的一点是过度设计，废了很大的功夫想要在一切开始之前造一个完美的轮子，结果造完之后极大可能你的记笔记热情已经没有了。\n\n 所以我不建议你等待，等待任何笔记流程的设计。不是有了完美工作流之后你才能开始工作，而是做着做着就根据自己的场景和需要慢慢铺就了适合你的工作流。\n\n 这也是渐进式笔记的概念。ob 当时带着双链和关系图谱出现，本意就是让使用者渐进式的搭建自己的知识库。\n\n 渐进式的观点还能很好的改善完美主义。（刚看完《如何成为不完美主义》的一点小启发。）\n\n这也就是我为什么说等你积累到 10 篇以上，会需要这篇文章。如果你才开始记笔记，请先放下一切问题记起来。\n\n言归正传，来看看 dataview 的使用场景。\n\n使用场景\n\n假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。\n\n安装插件\n\n众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！\n\n使用\n\n方法千千万，我只写三种生成目录的方式：\n\n从名字\n\n从标签\n\n从作者\n\n如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。\n\n从文件名\n\n场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。\n\n从标签\n\n场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。\n\n从作者\n\n场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样：\n\n---\ntitle: 标题名字\nauthor: 作者名\ntags: [标签1]\n---\n\n\nyml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：\n\n```\n作者: 鲁迅 \n```\n\n\n我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。\n\n扩展：创建一个书目列表吧！\n\n上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"yml 的规则：","root":"yml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样："},{"str":"1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？","root":"yml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样："},{"str":"2、必须写在文件最上方","root":"yml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样："},{"str":"里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：","root":"yml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样："},{"str":"```\n作者: 鲁迅 \n```\n","root":"写在前面\n\n 距离上次发布 obsidian 使用类的文章已经一个月了，这段时间大家过得怎么样？有把 obsidian 用起来吗？\n\n 这篇仍然是使用类干货，当你积累了 10 + 篇自己的笔记，或许会需要它。\n\n 写笔记也好，做什么东西也好，我认为很忌讳的一点是过度设计，废了很大的功夫想要在一切开始之前造一个完美的轮子，结果造完之后极大可能你的记笔记热情已经没有了。\n\n 所以我不建议你等待，等待任何笔记流程的设计。不是有了完美工作流之后你才能开始工作，而是做着做着就根据自己的场景和需要慢慢铺就了适合你的工作流。\n\n 这也是渐进式笔记的概念。ob 当时带着双链和关系图谱出现，本意就是让使用者渐进式的搭建自己的知识库。\n\n 渐进式的观点还能很好的改善完美主义。（刚看完《如何成为不完美主义》的一点小启发。）\n\n这也就是我为什么说等你积累到 10 篇以上，会需要这篇文章。如果你才开始记笔记，请先放下一切问题记起来。\n\n言归正传，来看看 dataview 的使用场景。\n\n使用场景\n\n假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。\n\n安装插件\n\n众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！\n\n使用\n\n方法千千万，我只写三种生成目录的方式：\n\n从名字\n\n从标签\n\n从作者\n\n如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。\n\n从文件名\n\n场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。\n\n从标签\n\n场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。\n\n从作者\n\n场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样：\n\n---\ntitle: 标题名字\nauthor: 作者名\ntags: [标签1]\n---\n\n\nyml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：\n\n```\n作者: 鲁迅 \n```\n\n\n我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。\n\n扩展：创建一个书目列表吧！\n\n上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"我就给笔记加了 “作者” 这个属性。","root":"我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。"},{"str":"然后我们就可以使用 “作者” 作为条件建立目录了。","root":"我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。"},{"str":"👉","root":"👉 dataview 使用 yml 的元素"},{"str":"dataview 使用 yml 的元素","root":"👉 dataview 使用 yml 的元素"},{"str":"where 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：","root":"我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。"},{"str":"```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n","root":"我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。"},{"str":"看下效果：","root":"我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。"},{"str":"上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。","root":"我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。"},{"str":"嗯哼，鲁迅合集就做好了。","root":"我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。"},{"str":"扩展：创建一个书目列表吧！","root":"写在前面\n\n 距离上次发布 obsidian 使用类的文章已经一个月了，这段时间大家过得怎么样？有把 obsidian 用起来吗？\n\n 这篇仍然是使用类干货，当你积累了 10 + 篇自己的笔记，或许会需要它。\n\n 写笔记也好，做什么东西也好，我认为很忌讳的一点是过度设计，废了很大的功夫想要在一切开始之前造一个完美的轮子，结果造完之后极大可能你的记笔记热情已经没有了。\n\n 所以我不建议你等待，等待任何笔记流程的设计。不是有了完美工作流之后你才能开始工作，而是做着做着就根据自己的场景和需要慢慢铺就了适合你的工作流。\n\n 这也是渐进式笔记的概念。ob 当时带着双链和关系图谱出现，本意就是让使用者渐进式的搭建自己的知识库。\n\n 渐进式的观点还能很好的改善完美主义。（刚看完《如何成为不完美主义》的一点小启发。）\n\n这也就是我为什么说等你积累到 10 篇以上，会需要这篇文章。如果你才开始记笔记，请先放下一切问题记起来。\n\n言归正传，来看看 dataview 的使用场景。\n\n使用场景\n\n假设你现在积累了一众笔记，这些笔记之间除了双链还有一些关联，现在你想要一个目录，可以一目了然的聚合这些笔记。\n\n以下是一些场景：\n\n生成包含同样关键字的笔记的目录\n\n生成同一个标签的笔记的目录\n\n生成同一个作者的书目的目录\n\n这时候，dataview 就派上用场了。\n\ndataview 可以生成 MOC，或者你也可以跟我一样，不去管 MOC 是什么，就把它当作一个目录。\n\n我们知道，目录是一篇文章的概览。dataview 其实生成了你的多篇文章目录。\n\n如果你有这种需要的话，就接着看下去吧。\n\n安装插件\n\n众所周知（如果你不知道，现在可以知道了），ob 插件有两种安装方式：\n\n1. 直接在 ` 第三方插件 -> 社区插件 ` 搜索安装\n\n2. 下载到插件文件，一般是一个插件文件夹，然后放在库目录下的 `.obsidian/plugins` 目录下。（至于从哪里下载，可以从 github 或者有些群会下载下来共享）\n\n设置：该插件不需要修改任何设置即可使用。\n\n接下来就开始生成目录吧！\n\n使用\n\n方法千千万，我只写三种生成目录的方式：\n\n从名字\n\n从标签\n\n从作者\n\n如果有更多的需求，说明你是个高阶使用者，请去查看更高阶的文章，或者去看插件作者的官网。\n\n从文件名\n\n场景：假设，现在你有多篇关于【习惯】的笔记，并且这些笔记的名称中都有 “习惯” 两个字。记录了好几个习惯养成的方法，今天你忽然意识到，关于习惯的方法论已经看了好几个了，想把它们列出来放到一起看看能不能产生什么化学效果。\n\n老规矩，先贴一个语法和效果图：\n\n下面讲讲规则，别害怕看 “代码”，总共就 5 行，大部分还是不用改的，比如我上面的代码，其实你只用替换双引号里面的内容哟，是不是简单多了？\n\n首先，dv 语法要写到代码块里，如果有了解过 markdown 的小伙伴，应该对代码块不陌生。上下三个上撇，就是一个代码块。\n\n在首行写上 `dataview`，插件就可以识别这部分代码了。\n\n以上解释希望你看懂了。下面我举一个例子，还以开头的假设场景为例，你要怎么写呢？\n\n```- list：你创建了一个列表/清单。\nlist \nfrom \"\"\nwhere contains(file.name,\"习惯\")\n```\n\n\n这样就可以了。\n\n- list：你创建了一个列表 / 清淡。\n\n- from 留空就是不筛选文件夹和标签，从所有笔记文件去找。\n\n- where 条件：匹配（contains）了文件名（file.name）中包含 “习惯” 两个字的笔记\n\n如果你需要排序，就写 sort，不需要，留空就可以。\n\n你应该发现了 `file.name` 和 `file.ctime` 的写法，没错，这是 dataview 内置的。下面是 dataview 官网中描述的支持的元数据，都可以供搜索和排序语法使用。在后面将要说到的创建 table，还可以作为列显示。\n\n上面的从文件名创建列表你看懂了的话，用从标签创建列表练习一下吧～其实上面有包含哦，但我们还是练习以下，以防有人没看懂。\n\n从标签\n\n场景：假设，你有几篇笔记，打了同一个标签，比如 `# 时间管理 `。现在你想要把时间管理标签下的笔记形成一个目录。\n\n你该怎么写 dataview 语句呢？\n\n还记得上面的 4 个关键设置字段吗？`from` 是检索范围，既可以从文件夹，又可以从标签。\n\n```dataview\nlist \nfrom #时间管理\n```\n\n\n不需要排序的话，代码就是这么简单。\n\n你学会了吗？\n\n如果学会了，下面我们可以加点好玩的东西。\n\n从作者\n\n场景：假设，你最近读了同一个作者的几部作品（论文、书书籍、视频、电影都是一样的），形成了几篇笔记。笔记多了以后，你就想弄一个该作者的专题。这时候，有什么办法能做到呢？\n\n哎，dataview 的支持元数据里可没有作者这个属性啊，怎么办呢？\n\n我们自己加属性！\n\n这时候，yml 就派上用场了。\n\n👉 用 YML 给笔记加点元素\n\n简单的说 yml 是一种标记语言。顺便说一下 markdown 也是一种标记语言。朴素的理解就是以某种规则写的一种文本。\n\n各位，用工具的时候，我们可以不求甚解，拿过来学会怎么用就可以了，甚至，你只用知道怎么在自己的需求中用就可以了。\n\n所以不需要特别去了解 yml。我们来看看 yml 怎么为我们所用吧。\n\nyml 语法大概长这样：\n\n---\ntitle: 标题名字\nauthor: 作者名\ntags: [标签1]\n---\n\n\nyml 的规则：\n\n1、只要写在 6 个横杠符号之间，yml 就可以被识别。够简单吧？\n\n2、必须写在文件最上方\n\n里面的 `title`、`author` 我们叫它 key，也就是你给这个字段起的名字，所有的 key 都是自己定义，没有必要的规则，就像你给表格起列名一样。yml 的 key 也支持中文名哦。例如这样：\n\n```\n作者: 鲁迅 \n```\n\n\n我就给笔记加了 “作者” 这个属性。\n\n然后我们就可以使用 “作者” 作为条件建立目录了。\n\n👉 dataview 使用 yml 的元素\n\nwhere 和 sort 就可以直接使用你在 yml 中设置的 key 了。看看下面的写法：\n\n```dataview\nlist \nfrom \"\"\nwhere contains(作者,\"鲁迅\")\n```\n\n\n看下效果：\n\n上面依次是：包含作者为 “鲁迅” 的原笔记、聚合作者为 “鲁迅” 的目录编辑模式、聚合作者为 “鲁迅” 的目录预览模式。\n\n嗯哼，鲁迅合集就做好了。\n\n扩展：创建一个书目列表吧！\n\n上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。","root":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。","root":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"还记得上面列表中的展示形式吗？","root":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。","root":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。","root":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"先贴一下代码看看吧:","root":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"上面唯一的变化就是 table 这一行：","root":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"table author,from,tags\n","root":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"table 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。","root":"table 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n"},{"str":"where 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。","root":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"sort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。","root":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"怎么样，你学会了吗？","root":"上面你已经学会了限制检索范围、模糊搜索文件名来创建列表，学会了从标签创建列表，还学会了用 yml 定义的 key 当作字段做条件，基本的检索语法你已经学会啦。\n\n现在我们想在展示形式上有所改变，比如书目列表。我不想只展示作品的名字，我还想展示作者、阅读日期、标签。\n\n还记得上面列表中的展示形式吗？\n\n对，就是 dataview 语法的第一行那个 `list`，现在我们来变一下，写个 `table` 吧。\n\n不过我们的语法有一点小小的改动。既然是 table，那么列名就必不可少。\n\n先贴一下代码看看吧:\n\n上面唯一的变化就是 table 这一行：\n\ntable author,from,tags\n\n\ntable 后面这三个字段就是我为表格设计的列。而 author 是我为笔记中的作者元素，from 是书籍来源，tags 是标签。这三个元素都写在来 yml，如今被 dataview 识别，就可以展现我想要的列表。\n\n\nwhere 条件里，我写的匹配字段是 `type`，这也是我 yml 里面的元素，表示输入内容，自定义了三个值：book、page、video。\n\nsort 这句，用 author 字段排序，后面跟了一个 `desc`，表示倒叙。\n\n怎么样，你学会了吗？"},{"str":"- End -","root":"- End -\n\n以上，dataview 常用的内容就讲完啦。task 展示类型就暂时不讲了，使用的不多。\n\n如果你有什么不明白的，也可以在留言区告诉我\n\n谢谢你看到这里\n\n下期见！"},{"str":"以上，dataview 常用的内容就讲完啦。task 展示类型就暂时不讲了，使用的不多。","root":"以上，dataview 常用的内容就讲完啦。task 展示类型就暂时不讲了，使用的不多。\n\n如果你有什么不明白的，也可以在留言区告诉我\n\n谢谢你看到这里\n\n下期见！"},{"str":"如果你有什么不明白的，","root":"如果你有什么不明白的，也可以在留言区告诉我"},{"str":"也","root":"如果你有什么不明白的，也可以在留言区告诉我"},{"str":"可以在","root":"如果你有什么不明白的，也可以在留言区告诉我"},{"str":"留言区","root":"如果你有什么不明白的，也可以在留言区告诉我"},{"str":"告诉","root":"如果你有什么不明白的，也可以在留言区告诉我"},{"str":"我","root":"如果你有什么不明白的，也可以在留言区告诉我"},{"str":"谢谢你看到这里","root":"以上，dataview 常用的内容就讲完啦。task 展示类型就暂时不讲了，使用的不多。\n\n如果你有什么不明白的，也可以在留言区告诉我\n\n谢谢你看到这里\n\n下期见！"},{"str":"下期见！","root":"以上，dataview 常用的内容就讲完啦。task 展示类型就暂时不讲了，使用的不多。\n\n如果你有什么不明白的，也可以在留言区告诉我\n\n谢谢你看到这里\n\n下期见！"}]}],"tags":[],"note":"","create":"2023年11月11日 22:25:12","idx":9},{"annotations":[],"create":"2023年11月10日 10:03:18","desc":"大家好，这是一个给 obsidian 新手的开箱即用库。","favicon":"https://cyddgh.github.io/favicon.ico?v=1698803551014","idx":8,"img":"","note":"","tags":[],"title":"obsidian 开箱即用库 _ 软通达","url":"https://cyddgh.github.io/post/202112031518/"},{"annotations":[],"create":"2023年11月10日 09:58:53","desc":"1. 主题Obsidian的Typora-Vue主题，直接在商店搜索Typora-Vue即可。Obsidian的Typora-Vue主题：Typora-Vu…","favicon":"https://static.zhihu.com/heifetz/favicon.ico","idx":7,"img":"https://images.unsplash.com/photo-1693868769698-6c7440636a09?crop=entropy&cs=srgb&fm=jpg&ixid=M3w0Njc1ODd8MHwxfHJhbmRvbXx8fHx8fHwxfHwxNjk5NTgxNTAyfA&ixlib=rb-4.0.3&q=85&fit=crop&w=586&max-h=540","note":"","tags":[],"title":"可以分享一下 obsidian 不太用折腾的美观配置和插件组合吗？","url":"https://www.zhihu.com/question/565195799/answer/2858416806?utm_campaign=&utm_medium=social&utm_oi=1695170834254327808&utm_psn=1697274227567157248&utm_source=com.alpha.pinbox"},{"annotations":[],"create":"2023年11月10日 09:34:51","desc":"obsidian介绍（如果已经知道甚至正在使用obsidian，本节可跳过） 如果你是一个想要尝试甚至完全实现笔记无纸化的大学生，那么obsidian是一个足够合适的电子笔记软件，作为一个数学系学生，我可以给你以下的优点供…","favicon":"https://static.zhihu.com/heifetz/favicon.ico","idx":6,"img":"https://picx.zhimg.com/v2-5f9e74c67807fd71977204a8822d572c_720w.jpg?source=172ae18b","note":"","tags":[],"title":"数学系大学生的 obsidian 配置——记录一年来的弯路与心得","url":"https://zhuanlan.zhihu.com/p/657343154?utm_campaign=&utm_medium=social&utm_oi=1695170834254327808&utm_psn=1697072626130968576&utm_source=com.alpha.pinbox"},{"annotations":[{"annote":"<sr-annote data-id=\"1664008720665\">传统的稍后读只是将不同的信息用「文件夹 + 标签」方式来展示，但这样对信息来说，颗粒度还是太大了。简悦对此的解决方案是：</sr-annote><sr-annote data-id=\"1664008720665\">稍后读与标注具有一样的地位，且都可以支持无限层级标签系统</sr-annote><sr-annote data-id=\"1664008720665\">。这样做虽然减小了信息的颗粒度问题，但并未真正解决信息的关联性问题。</sr-annote><sr-annote data-id=\"1664008720665\">随着 Zettelkasten 笔记法的流行，越来越多的使用者开始注意笔记（信息）之间的内化与相互之间的关联性，其实在 Wiki 页面就存在着这样的信息关联性，而作为信息完整度最好的稍后读工具，却天然地缺失这类方式。</sr-annote><sr-annote data-id=\"1664008720665\">因此&nbsp;2.2.0&nbsp;版简悦的稍后读借鉴了 ZK 笔记法的一些特点，专门针对信息的整合增加了如下一些新功能，对于一个稍后读产品来说这些功能都是简悦独有的功能。</sr-annote><sr-annote data-id=\"1664008720665\">双向链接</sr-annote><sr-annote data-id=\"1664008720665\">知识图谱</sr-annote><sr-annote data-id=\"1664008720665\">Mindmap</sr-annote><sr-annote data-id=\"1664008720665\"> 多种信息展示方式（布局）：</sr-annote><sr-annote data-id=\"1664008720665\">Evergreen</sr-annote><sr-annote data-id=\"1664008720665\">、</sr-annote><sr-annote data-id=\"1664008720665\">Workflowy</sr-annote><sr-annote data-id=\"1664008720665\">、</sr-annote><sr-annote data-id=\"1664008720665\">k</sr-annote>","color":1,"html":"<p>传统的稍后读只是将不同的信息用「文件夹 + 标签」方式来展示，但这样对信息来说，颗粒度还是太大了。简悦对此的解决方案是：<strong>稍后读与标注具有一样的地位，且都可以支持无限层级标签系统</strong>。这样做虽然减小了信息的颗粒度问题，但并未真正解决信息的关联性问题。</p><p>随着 Zettelkasten 笔记法的流行，越来越多的使用者开始注意笔记（信息）之间的内化与相互之间的关联性，其实在 Wiki 页面就存在着这样的信息关联性，而作为信息完整度最好的稍后读工具，却天然地缺失这类方式。</p><p>因此&nbsp;2.2.0&nbsp;版简悦的稍后读借鉴了 ZK 笔记法的一些特点，专门针对信息的整合增加了如下一些新功能，对于一个稍后读产品来说这些功能都是简悦独有的功能。</p><ul><li><a href=\"http://ksria.com/simpread/docs/#/%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5\" target=\"_blank\">双向链接</a></li><li><a href=\"http://ksria.com/simpread/docs/#/%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5?id=%E5%9B%BE%E8%B0%B1\" target=\"_blank\">知识图谱</a></li><li><a href=\"http://ksria.com/simpread/docs/#/%E7%A8%8D%E5%90%8E%E8%AF%BB?id=Mindmap\" target=\"_blank\">Mindmap</a></li><li> 多种信息展示方式（布局）：<a href=\"http://ksria.com/simpread/docs/#/%E7%A8%8D%E5%90%8E%E8%AF%BB-%E5%A4%9A%E7%A7%8D%E5%B8%83%E5%B1%80?id=Evergreen\" target=\"_blank\">Evergreen</a>、<a href=\"http://ksria.com/simpread/docs/#/%E7%A8%8D%E5%90%8E%E8%AF%BB-%E5%A4%9A%E7%A7%8D%E5%B8%83%E5%B1%80?id=Workflowy\" target=\"_blank\">Workflowy</a>、<a href=\"http://ksria.com/simpread/docs/#/%E7%A8%8D%E5%90%8E%E8%AF%BB-%E5%A4%9A%E7%A7%8D%E5%B8%83%E5%B1%80?id=Kanban\" target=\"_blank\">k</a></li></ul><h3 id=\"sr-toc-1\"></h3>","id":1664008720665,"items":[{"root":"传统的稍后读只是将不同的信息用「文件夹 + 标签」方式来展示，但这样对信息来说，颗粒度还是太大了。简悦对此的解决方案是：稍后读与标注具有一样的地位，且都可以支持无限层级标签系统。这样做虽然减小了信息的颗粒度问题，但并未真正解决信息的关联性问题。","str":"传统的稍后读只是将不同的信息用「文件夹 + 标签」方式来展示，但这样对信息来说，颗粒度还是太大了。简悦对此的解决方案是："},{"root":"传统的稍后读只是将不同的信息用「文件夹 + 标签」方式来展示，但这样对信息来说，颗粒度还是太大了。简悦对此的解决方案是：稍后读与标注具有一样的地位，且都可以支持无限层级标签系统。这样做虽然减小了信息的颗粒度问题，但并未真正解决信息的关联性问题。","str":"稍后读与标注具有一样的地位，且都可以支持无限层级标签系统"},{"root":"传统的稍后读只是将不同的信息用「文件夹 + 标签」方式来展示，但这样对信息来说，颗粒度还是太大了。简悦对此的解决方案是：稍后读与标注具有一样的地位，且都可以支持无限层级标签系统。这样做虽然减小了信息的颗粒度问题，但并未真正解决信息的关联性问题。","str":"。这样做虽然减小了信息的颗粒度问题，但并未真正解决信息的关联性问题。"},{"root":"因此 2.2.0 版简悦的稍后读借鉴了 ZK 笔记法的一些特点，专门针对信息的整合增加了如下一些新功能，对于一个稍后读产品来说这些功能都是简悦独有的功能。","str":"随着 Zettelkasten 笔记法的流行，越来越多的使用者开始注意笔记（信息）之间的内化与相互之间的关联性，其实在 Wiki 页面就存在着这样的信息关联性，而作为信息完整度最好的稍后读工具，却天然地缺失这类方式。"},{"root":"双向链接\n知识图谱\nMindmap\n多种信息展示方式（布局）：Evergreen、Workflowy、k","str":"因此 2.2.0 版简悦的稍后读借鉴了 ZK 笔记法的一些特点，专门针对信息的整合增加了如下一些新功能，对于一个稍后读产品来说这些功能都是简悦独有的功能。"},{"root":"双向链接\n知识图谱\nMindmap\n多种信息展示方式（布局）：Evergreen、Workflowy、k","str":"双向链接"},{"root":"双向链接\n知识图谱\nMindmap\n多种信息展示方式（布局）：Evergreen、Workflowy、k","str":"知识图谱"},{"root":"双向链接\n知识图谱\nMindmap\n多种信息展示方式（布局）：Evergreen、Workflowy、k","str":"Mindmap"},{"root":"多种信息展示方式（布局）：Evergreen、Workflowy、k","str":"多种信息展示方式（布局）："},{"root":"多种信息展示方式（布局）：Evergreen、Workflowy、k","str":"Evergreen"},{"root":"多种信息展示方式（布局）：Evergreen、Workflowy、k","str":"、"},{"root":"多种信息展示方式（布局）：Evergreen、Workflowy、k","str":"Workflowy"},{"root":"多种信息展示方式（布局）：Evergreen、Workflowy、k","str":"、"},{"root":"多种信息展示方式（布局）：Evergreen、Workflowy、k","str":"k"}],"note":"","style":0,"tags":[],"text":"传统的稍后读只是将不同的信息用「文件夹 + 标签」方式来展示，但这样对信息来说，颗粒度还是太大了。简悦对此的解决方案是：稍后读与标注具有一样的地位，且都可以支持无限层级标签系统。这样做虽然减小了信息的颗粒度问题，但并未真正解决信息的关联性问题。随着 Zettelkasten 笔记法的流行，越来越多的使用者开始注意笔记（信息）之间的内化与相互之间的关联性，其实在 Wiki 页面就存在着这样的信息关联性，而作为信息完整度最好的稍后读工具，却天然地缺失这类方式。因此 2.2.0 版简悦的稍后读借鉴了 ZK 笔记法的一些特点，专门针对信息的整合增加了如下一些新功能，对于一个稍后读产品来说这些功能都是简悦独有的功能。双向链接知识图谱Mindmap多种信息展示方式（布局）：Evergreen、Workflowy、k","type":"paragraph"},{"annote":"","color":5,"html":"","id":1664008727659,"items":[],"note":"","style":0,"tags":[],"text":"https://cdn.sspai.com/2021/05/27/3df7b554b18a30e156673c3511a897e2.png","type":"img"},{"annote":"<sr-annote data-id=\"1664008742365\">新的布局</sr-annote><sr-annote data-id=\"1664008742365\">布局是信息的展示方式，加入了双向链接等功能后，2.2 版本之前的布局已经无法承载这些内容。所以 2.2 版本增加了三类布局：</sr-annote><sr-annote data-id=\"1664008742365\">Evergreen</sr-annote><sr-annote data-id=\"1664008742365\">：信息的之间的关联性联系 </sr-annote><sr-annote data-id=\"1664008742365\">Workflowy</sr-annote><sr-annote data-id=\"1664008742365\">：将多种信息汇总为一个页面 </sr-annote><sr-annote data-id=\"1664008742365\">Kanban</sr-annote><sr-annote data-id=\"1664008742365\">：用 GTD 的方式管理你的稍后读</sr-annote>","color":3,"html":"<h3 id=\"sr-toc-3\">新的布局</h3><p>布局是信息的展示方式，加入了双向链接等功能后，2.2 版本之前的布局已经无法承载这些内容。所以 2.2 版本增加了三类布局：</p><ul><li><a href=\"http://ksria.com/simpread/docs/#/%E7%A8%8D%E5%90%8E%E8%AF%BB-%E5%A4%9A%E7%A7%8D%E5%B8%83%E5%B1%80?id=Evergreen\" target=\"_blank\">Evergreen</a>：信息的之间的关联性联系 </li><li><a href=\"http://ksria.com/simpread/docs/#/%E7%A8%8D%E5%90%8E%E8%AF%BB-%E5%A4%9A%E7%A7%8D%E5%B8%83%E5%B1%80?id=Workflowy\" target=\"_blank\">Workflowy</a>：将多种信息汇总为一个页面 </li><li><a href=\"http://ksria.com/simpread/docs/#/%E7%A8%8D%E5%90%8E%E8%AF%BB-%E5%A4%9A%E7%A7%8D%E5%B8%83%E5%B1%80?id=Kanban\" target=\"_blank\">Kanban</a>：用 GTD 的方式管理你的稍后读</li></ul>","id":1664008742365,"items":[{"root":"布局是信息的展示方式，加入了双向链接等功能后，2.2 版本之前的布局已经无法承载这些内容。所以 2.2 版本增加了三类布局：","str":"新的布局"},{"root":"Evergreen：信息的之间的关联性联系\nWorkflowy：将多种信息汇总为一个页面\nKanban：用 GTD 的方式管理你的稍后读","str":"布局是信息的展示方式，加入了双向链接等功能后，2.2 版本之前的布局已经无法承载这些内容。所以 2.2 版本增加了三类布局："},{"root":"Evergreen：信息的之间的关联性联系","str":"Evergreen"},{"root":"Evergreen：信息的之间的关联性联系","str":"：信息的之间的关联性联系"},{"root":"Workflowy：将多种信息汇总为一个页面","str":"Workflowy"},{"root":"Workflowy：将多种信息汇总为一个页面","str":"：将多种信息汇总为一个页面"},{"root":"Kanban：用 GTD 的方式管理你的稍后读","str":"Kanban"},{"root":"Kanban：用 GTD 的方式管理你的稍后读","str":"：用 GTD 的方式管理你的稍后读"}],"note":"","style":0,"tags":[],"text":"新的布局布局是信息的展示方式，加入了双向链接等功能后，2.2 版本之前的布局已经无法承载这些内容。所以 2.2 版本增加了三类布局：Evergreen：信息的之间的关联性联系Workflowy：将多种信息汇总为一个页面Kanban：用 GTD 的方式管理你的稍后读","type":"paragraph"}],"create":"2022年09月24日 16:38:25","desc":"我希望简悦不仅是一个工具，它更应该是你的信息获取助理，是建立在信息与笔记之间的桥梁，是建立在原始网页与生产力工具之间的桥梁。","favicon":"https://cdn-static.sspai.com/favicon/sspai.ico","idx":4,"img":"https://cdn.sspai.com/article/053250ba-a755-1fb8-25d7-d96ca0aa7b31.png","note":"","tags":[],"title":"看板、双向链接、知识图谱…… 简悦 2-2 想让你的稍后读不再不读","url":"https://sspai.com/post/67074"},{"annotations":[{"annote":"<sr-annote data-id=\"1664008601679\">我非常不喜欢安装各种 App，再加上越来越强大的电脑性能与大前端的普及，所以一个浏览器几乎可以覆盖全部的工作，因此我的工作环境被压缩为下面几个工具：</sr-annote><sr-annote data-id=\"1664008601679\">Chrome</sr-annote><sr-annote data-id=\"1664008601679\">VS Code</sr-annote><sr-annote data-id=\"1664008601679\">Github + git</sr-annote><sr-annote data-id=\"1664008601679\">iTerm + oh-my-zsh</sr-annote>","color":1,"html":"<p>我非常不喜欢安装各种 App，再加上越来越强大的电脑性能与大前端的普及，所以一个浏览器几乎可以覆盖全部的工作，因此我的工作环境被压缩为下面几个工具：</p><ul><li>Chrome</li><li>VS Code</li><li>Github + git</li><li>iTerm + oh-my-zsh</li></ul>","id":1664008601679,"items":[{"root":"Chrome\nVS Code\nGithub + git\niTerm + oh-my-zsh","str":"我非常不喜欢安装各种 App，再加上越来越强大的电脑性能与大前端的普及，所以一个浏览器几乎可以覆盖全部的工作，因此我的工作环境被压缩为下面几个工具："},{"root":"Chrome\nVS Code\nGithub + git\niTerm + oh-my-zsh","str":"Chrome"},{"root":"Chrome\nVS Code\nGithub + git\niTerm + oh-my-zsh","str":"VS Code"},{"root":"Chrome\nVS Code\nGithub + git\niTerm + oh-my-zsh","str":"Github + git"},{"root":"Chrome\nVS Code\nGithub + git\niTerm + oh-my-zsh","str":"iTerm + oh-my-zsh"}],"note":"","style":0,"tags":[],"text":"我非常不喜欢安装各种 App，再加上越来越强大的电脑性能与大前端的普及，所以一个浏览器几乎可以覆盖全部的工作，因此我的工作环境被压缩为下面几个工具：ChromeVS CodeGithub + gitiTerm + oh-my-zsh","type":"paragraph"},{"annote":"","color":2,"html":"","id":1664008612905,"items":[],"note":"","style":0,"tags":[],"text":"https://cdn.sspai.com/2022/02/21/article/2dd7acc86429078ce738ea11dc4f1794","type":"img"},{"annote":"<sr-annote data-id=\"1664008622457\">如果为了极简而极简则显然丧失了极简的目的：</sr-annote><sr-annote data-id=\"1664008622457\">高效</sr-annote><sr-annote data-id=\"1664008622457\">。</sr-annote><sr-annote data-id=\"1664008622457\">只选择 Notion 的用户，虽然可以一键登录你全部的数据，但失去了 Obsidian / Logseq 本地应用的高效性。</sr-annote><sr-annote data-id=\"1664008622457\">只选择印象笔记的用户，虽然得到了强大无比的全平台一键导入的便利性，但失去了「数据所有权」。</sr-annote><sr-annote data-id=\"1664008622457\">只选择 Typora 的用户，虽然得到了完美的所见即所得，但失去了同步的便利性。</sr-annote>","color":1,"html":"<p>如果为了极简而极简则显然丧失了极简的目的：<strong>高效</strong>。</p><ul><li>只选择 Notion 的用户，虽然可以一键登录你全部的数据，但失去了 Obsidian / Logseq 本地应用的高效性。</li><li>只选择印象笔记的用户，虽然得到了强大无比的全平台一键导入的便利性，但失去了「数据所有权」。</li><li>只选择 Typora 的用户，虽然得到了完美的所见即所得，但失去了同步的便利性。</li></ul>","id":1664008622457,"items":[{"root":"如果为了极简而极简则显然丧失了极简的目的：高效。","str":"如果为了极简而极简则显然丧失了极简的目的："},{"root":"如果为了极简而极简则显然丧失了极简的目的：高效。","str":"高效"},{"root":"如果为了极简而极简则显然丧失了极简的目的：高效。","str":"。"},{"root":"只选择 Notion 的用户，虽然可以一键登录你全部的数据，但失去了 Obsidian / Logseq 本地应用的高效性。\n只选择印象笔记的用户，虽然得到了强大无比的全平台一键导入的便利性，但失去了「数据所有权」。\n只选择 Typora 的用户，虽然得到了完美的所见即所得，但失去了同步的便利性。","str":"只选择 Notion 的用户，虽然可以一键登录你全部的数据，但失去了 Obsidian / Logseq 本地应用的高效性。"},{"root":"只选择 Notion 的用户，虽然可以一键登录你全部的数据，但失去了 Obsidian / Logseq 本地应用的高效性。\n只选择印象笔记的用户，虽然得到了强大无比的全平台一键导入的便利性，但失去了「数据所有权」。\n只选择 Typora 的用户，虽然得到了完美的所见即所得，但失去了同步的便利性。","str":"只选择印象笔记的用户，虽然得到了强大无比的全平台一键导入的便利性，但失去了「数据所有权」。"},{"root":"只选择 Notion 的用户，虽然可以一键登录你全部的数据，但失去了 Obsidian / Logseq 本地应用的高效性。\n只选择印象笔记的用户，虽然得到了强大无比的全平台一键导入的便利性，但失去了「数据所有权」。\n只选择 Typora 的用户，虽然得到了完美的所见即所得，但失去了同步的便利性。","str":"只选择 Typora 的用户，虽然得到了完美的所见即所得，但失去了同步的便利性。"}],"note":"","style":0,"tags":[],"text":"如果为了极简而极简则显然丧失了极简的目的：高效。只选择 Notion 的用户，虽然可以一键登录你全部的数据，但失去了 Obsidian / Logseq 本地应用的高效性。只选择印象笔记的用户，虽然得到了强大无比的全平台一键导入的便利性，但失去了「数据所有权」。只选择 Typora 的用户，虽然得到了完美的所见即所得，但失去了同步的便利性。","type":"paragraph"}],"create":"2022年09月24日 16:36:20","desc":"大家好，我是 Kenshin，简悦的作者，这次跟大家分享我对极简效率工作的一些理解，我接触效率相关的内容，与简悦的诞生有关：\n\n简悦始于 2016 年…… 那时因为家里的一些事情，我解散了团队，注销了公司。","favicon":"https://cdn-static.sspai.com/favicon/sspai.ico","idx":3,"img":"https://cdn.sspai.com/2022/02/21/88f0c0c3d31e13ff8e8c004893de5394.png","note":"","tags":[],"title":"放弃纠结、拥抱妥协，重器轻用就是高效","url":"https://sspai.com/post/71576"},{"annotations":[{"annote":"<sr-annote data-id=\"1664008650243\">处理简悦时，除编码以外的大多数事情非常细碎，所以一天下来的日志可能会非常零碎，为了避免这种情况，我「改造」了间歇日记，把它变成了我的工作日志。</sr-annote><sr-annote data-id=\"1664008650243\">同时我不会刻意使用番茄工作法来辅助，因为这会让我觉得有些「紧张」。</sr-annote><sr-annote data-id=\"1664008650243\">首先我会把任务（ Task ）分得越细越好，这样估算每个工作时间也就越精准。每完成一个 Task 就记录在 Notion 中，当一天下来后，就完成了每天的日志。</sr-annote><sr-annote data-id=\"1664008650243\">我会为每个 Small Project 在 Notion 建立一个如下的结构，然后使用 Paste and Sync 的方式嵌入到工作日志（间歇日记）中。</sr-annote>","color":1,"html":"<p>处理简悦时，除编码以外的大多数事情非常细碎，所以一天下来的日志可能会非常零碎，为了避免这种情况，我「改造」了间歇日记，把它变成了我的工作日志。</p><p>同时我不会刻意使用番茄工作法来辅助，因为这会让我觉得有些「紧张」。</p><p>首先我会把任务（ Task ）分得越细越好，这样估算每个工作时间也就越精准。每完成一个 Task 就记录在 Notion 中，当一天下来后，就完成了每天的日志。</p><p>我会为每个 Small Project 在 Notion 建立一个如下的结构，然后使用 Paste and Sync 的方式嵌入到工作日志（间歇日记）中。</p>","id":1664008650243,"items":[{"root":"同时我不会刻意使用番茄工作法来辅助，因为这会让我觉得有些「紧张」。","str":"处理简悦时，除编码以外的大多数事情非常细碎，所以一天下来的日志可能会非常零碎，为了避免这种情况，我「改造」了间歇日记，把它变成了我的工作日志。"},{"root":"首先我会把任务（ Task ）分得越细越好，这样估算每个工作时间也就越精准。每完成一个 Task 就记录在 Notion 中，当一天下来后，就完成了每天的日志。","str":"同时我不会刻意使用番茄工作法来辅助，因为这会让我觉得有些「紧张」。"},{"root":"我会为每个 Small Project 在 Notion 建立一个如下的结构，然后使用 Paste and Sync 的方式嵌入到工作日志（间歇日记）中。","str":"首先我会把任务（ Task ）分得越细越好，这样估算每个工作时间也就越精准。每完成一个 Task 就记录在 Notion 中，当一天下来后，就完成了每天的日志。"},{"root":"同时在日志中也可以详细描写某些 Task 为什么延迟以及原因等，用作事后复盘。","str":"我会为每个 Small Project 在 Notion 建立一个如下的结构，然后使用 Paste and Sync 的方式嵌入到工作日志（间歇日记）中。"}],"note":"","style":0,"tags":[],"text":"处理简悦时，除编码以外的大多数事情非常细碎，所以一天下来的日志可能会非常零碎，为了避免这种情况，我「改造」了间歇日记，把它变成了我的工作日志。同时我不会刻意使用番茄工作法来辅助，因为这会让我觉得有些「紧张」。首先我会把任务（ Task ）分得越细越好，这样估算每个工作时间也就越精准。每完成一个 Task 就记录在 Notion 中，当一天下来后，就完成了每天的日志。我会为每个 Small Project 在 Notion 建立一个如下的结构，然后使用 Paste and Sync 的方式嵌入到工作日志（间歇日记）中。","type":"paragraph"},{"annote":"","color":2,"html":"","id":1664008663981,"items":[],"note":"","style":0,"tags":[],"text":"https://cdn.sspai.com/2021/12/01/article/d6027cfdc15580892a6013d9af40ae95","type":"img"},{"annote":"","color":4,"html":"","id":1664008668130,"items":[],"note":"","style":0,"tags":[],"text":"https://cdn.sspai.com/2021/12/01/article/dcf998c9e173632ef816f7fae4165c9b","type":"img"}],"create":"2022年09月24日 16:34:27","desc":"我每天都要处理两类事务：简悦 & 工作，每个事务都会有不同的角色。通过这篇文章，我就来跟大家分享下使用 Notion 管理简悦的一切工作的经验。","favicon":"https://cdn-static.sspai.com/favicon/sspai.ico","idx":2,"img":"https://cdn.sspai.com/2021/12/01/316ccb44c2542cfdc492b84faf0e3085.png","note":"","tags":[],"title":"我如何使用 Notion 管理简悦的一切","url":"https://sspai.com/post/70237"},{"annotations":[{"annote":"<sr-annote data-id=\"1663757635024\">这是个信息轰炸的时代，除了必要的信息过滤手段外，每个人都应该构建属于自己的个人知识库。</sr-annote>","color":1,"html":"这是个信息轰炸的时代，除了必要的信息过滤手段外，每个人都应该构建属于自己的个人知识库。","id":1663757635024,"items":[{"root":"一、个人数据库避坑指南","str":"这是个信息轰炸的时代，除了必要的信息过滤手段外，每个人都应该构建属于自己的个人知识库。"}],"note":"","style":0,"tags":[],"text":"这是个信息轰炸的时代，除了必要的信息过滤手段外，每个人都应该构建属于自己的个人知识库。","type":"paragraph"},{"annote":"","color":5,"html":"","id":1663757593476,"items":[],"note":"","style":0,"tags":[],"text":"https://cdn.sspai.com/2021/11/17/02dcb3e22348318ab27890b2272242a6.png","type":"img"},{"annote":"<sr-annote data-id=\"1663757042487\">到的可能是一个共性问题，也就是：我们自己的笔记究竟该如何处理才最方便、最有助于个人成长？不同的软件有不同的理念，有的服务注重开放性，能够与市面上的其他服务共通，便于定制自己的</sr-annote>","color":1,"html":"到的可能是一个共性问题，也就是：我们自己的笔记究竟该如何处理才最方便、最有助于个人成长？不同的软件有不同的理念，有的服务注重开放性，能够与市面上的其他服务共通，便于定制自己的","id":1663757042487,"items":[{"root":"使用过笔记类软件的朋友都知道，这位朋友遇到的可能是一个共性问题，也就是：我们自己的笔记究竟该如何处理才最方便、最有助于个人成长？不同的软件有不同的理念，有的服务注重开放性，能够与市面上的其他服务共通，便于定制自己的知识空间；有的软件则认为自己的知识整理理念独一无二且非常优秀，因此相对封闭，便于吸引用户且留住用户。在这篇文章中，针对笔记和知识整理领域，我们来共同探讨关于个人数据整理的问题：","str":"到的可能是一个共性问题，也就是：我们自己的笔记究竟该如何处理才最方便、最有助于个人成长？不同的软件有不同的理念，有的服务注重开放性，能够与市面上的其他服务共通，便于定制自己的"}],"note":"","style":0,"tags":[],"text":"到的可能是一个共性问题，也就是：我们自己的笔记究竟该如何处理才最方便、最有助于个人成长？不同的软件有不同的理念，有的服务注重开放性，能够与市面上的其他服务共通，便于定制自己的","type":"paragraph"},{"annote":"<sr-annote data-id=\"1663757046716\">究竟什么样的个人数据存储方案才是好的？</sr-annote><sr-annote data-id=\"1663757046716\">如何构建适合自己的数据存储空间？</sr-annote><sr-annote data-id=\"1663757046716\">构建自己的个性化服务应该注意哪些内容？</sr-annote>","color":1,"html":"<ol><li>究竟什么样的个人数据存储方案才是好的？</li><li>如何构建适合自己的数据存储空间？</li><li>构建自己的个性化服务应该注意哪些内容？</li></ol><h3 id=\"sr-toc-1\"></h3>","id":1663757046716,"items":[{"root":"究竟什么样的个人数据存储方案才是好的？\n如何构建适合自己的数据存储空间？\n构建自己的个性化服务应该注意哪些内容？","str":"究竟什么样的个人数据存储方案才是好的？"},{"root":"究竟什么样的个人数据存储方案才是好的？\n如何构建适合自己的数据存储空间？\n构建自己的个性化服务应该注意哪些内容？","str":"如何构建适合自己的数据存储空间？"},{"root":"究竟什么样的个人数据存储方案才是好的？\n如何构建适合自己的数据存储空间？\n构建自己的个性化服务应该注意哪些内容？","str":"构建自己的个性化服务应该注意哪些内容？"}],"note":"","style":0,"tags":[],"text":"究竟什么样的个人数据存储方案才是好的？如何构建适合自己的数据存储空间？构建自己的个性化服务应该注意哪些内容？","type":"paragraph"},{"annote":"","color":2,"html":"","id":1663757053676,"items":[],"note":"","style":0,"tags":[],"text":"https://cdn.sspai.com/2021/11/17/d603dfc12369401e5d24eeff2c2ddb85.jpg","type":"img"}],"create":"2022年09月21日 18:43:54","desc":"这是个信息轰炸的时代，除了必要的信息过滤手段外，每个人都应该构建属于自己的个人知识库。","favicon":"https://cdn-static.sspai.com/favicon/sspai.ico","idx":1,"img":"https://cdn.sspai.com/2021/11/17/365ff29b5ab274691d99b1417912aade.png","note":"","tags":[],"title":"本地存储 + 线上获取：我的个人数据库建构路径","url":"https://sspai.com/post/69972"}],"collections":[],"plugstorge":{"1VQ19jCD8Z":{"addunread":true,"advuri":false,"annote":"o b a a","annote_props":"o b a c","assets":false,"assets_abs":false,"assets_custom":"","assets_image":"http","assets_type":"1","custom":{"markdown":{"backlink":"","custom":false,"ext_uri":"","format":"","int_uri":"","single":false,"single_tmp":"","tag":"","tag_sep":"","template":""},"title":{"custom":true,"template":"{{id}}{{un_title}}{{mode}}"}},"endpoint":"http://127.0.0.1:27123","folder":"5-项目夹","host":"http://localhost:7027","metadata":"---\nurl: {{url}}\ntitle: {{title}}\ndate: {{date}}\ntag: {{tags}}\nbanner: \"{{cover}}\"\nbanner_icon: 🔖\n---","org_title":false,"path":"","post":false,"sync":true,"template":true,"title":"{{title}}{{mode}}","token":"","unread_new":"o b u n","unread_update":"o b u u","valut":"个人库","yaml":true},"DH9l5jblPH":{"an_addshort":"o b a a","an_changshort":"o b a c","service":"-1","shortcut":"","un_addshort":"o b u n","un_changshort":"o b u u","unauto":"","unread":false,"version":"1.1.0"},"HD9GmoatXd":{"annote_tmpl":"<%\nlet colors = [ '#B4D9FB', '#ffeb3b', '#a2e9f2', '#a1e0ff', '#a8ea68', '#ffb7da' ],\n    color  = colors[ annote.color ];\nlet chls = [ 'srhl1', 'srhl2', 'srhl3', 'srhl4', 'srhl5', 'srhl6' ],\n    chl  = chls[ annote.color ];\nlet iframeURI = \"http://localhost:7026/unread/\"+unread.idx+\"#id=\"+annote.id\nlet intURL    = \"http://localhost:7026/reading/\"+unread.idx+\"#id=\"+annote.id\nif (unread.note && unread.title != unread.note) {\nvar filetitle = unread.note;\n}\nelse {\nvar filetitle = unread.title;\n}\nlet wikilinks = \"[[SR\" + unread.idx + \"@\" + filetitle + \"|📄]]\";\n-%>\n<% if (annote.note.startsWith(\"######\")) { %>\n<% \nlet note = annote.note.slice(7);\n-%>\n###### <% if (note) { %><%- note %><% } else { %>{{an_text}}<% } %>\n<% } else if (annote.note.startsWith(\"######\")) { %>\n<% \nlet note = annote.note.slice(6);\n-%>\n###### <% if (note) { %><%- note %><% } else { %>{{an_text}}<% } %>\n<% } else if (annote.note.startsWith(\"####\")) { %>\n<% \nlet note = annote.note.slice(5);\n-%>\n#### <% if (note) { %><%- note %><% } else { %>{{an_text}}<% } %>\n<% } else if (annote.note.startsWith(\"###\")) { %>\n<% \nlet note = annote.note.slice(4);\n-%>\n### <% if (note) { %><%- note %><% } else { %>{{an_text}}<% } %>\n<% } else { %>\n> [!<%= chl %>] <%- wikilinks %> <mark style=\"background-color: <%= color %>\">Highlights</mark> [🧷](<<%= iframeURI %>>) [🌐](<<%= intURL %>>) {{#|an_tag| }}  \n{{{html_format|>|{{an_html}}}}}\n<% if (annote.refs) { -%>\n{{> - 🔗|an_refs}}\n<% } -%>\n<% if (annote.note) { -%>\n<% if (annote.note.startsWith(\"todo:\") == false && annote.note.startsWith(\"done:\") == false) { -%>\n>  \n> - 📝{{an_note}}\n> ^sran-{{an_id}}\n<% } else { -%>\n<% \nlet note = annote.note.slice(6);\nif (annote.note.startsWith(\"todo:\")) {\n  var taskStatus = \" \"; }\n  else {\n  var taskStatus = \"x\";\n}\n-%>\n> ^sran-{{an_id}}\n\n- [<%= taskStatus %>] <%- note %> #web ^srtask-{{an_id}}\n<% } -%>\n<% } else { -%>\n> ^sran-{{an_id}}\n<% } -%>\n<% } -%>","custom":{"markdown":{"backlink":"","custom":false,"ext_uri":"","format":"","int_uri":"","single":false,"single_tmp":"","tag":"","tag_sep":"","template":""}},"ext_uri":"","slide":true,"tag_prefix":"#","tag_suffix":" ","title":"[[{{id}}-{{title}}@annote]]","unread_tmpl":"---\ntitle: \"{{title}}\"\nalias: \n<% if ( unread.note && unread.title != unread.note ) { %>  - \"{{note}}\"\n<% } %>  - \"{{title}}\"\ncreated-date: {{create|yyyy-mm-dd'T'HH:MM:sso}}\ntype: Simpread\n<% if (unread.img) { %>banner: \"<%- unread.img %> \"\nbanner_icon: 🔖\n<% } -%>\ntag: {{ |tag| | }}\nidx: {{idx}}\n---\n\n# {{title}}\n<%\nlet ifURI = \"http://localhost:7026/unread/\"+unread.idx\n%>\n> [!example]- [🧷内部链接](<<%= ifURI %>>) [🌐外部链接](<<%= unread.url %>>)    \n> URI:: [🧷](<<%= ifURI %>>) [🌐](<<%= unread.url %>>) \n> intURI:: [🧷内部链接](<{{int_uri}}>)\n\n%%\n> [!example]+ **Comments**  \n> ```dataview\n> TABLE \n>     WITHOUT ID\n>     link(Source, dateformat(date(Source), \"yyyy-MM-dd\")) as Date___, \n>     regexreplace(rows.Comments,\"^@@\\[\\[.+?\\]\\]\\s\",\"\") as \"Comments\"\n> FROM \"journals\"\n> WHERE  contains(cmnt, this.file.name)\n> FLATTEN cmnt as Comments\n> WHERE contains(Comments, this.file.name)\n> GROUP BY file.link as Source\n> SORT rows.file.day desc\n> ```\n>  **Description**:: {{desc}}\n%%\n\n> [!md] Metadata  \n> **标题**:: [{{title}}]({{url}})  \n> **日期**:: [[{{create|yyyy-mm-dd}}]]  \n<% if ( unread.annotations && unread.annotations.length > 0 ) { %>\n## Annotations\n\n{{annotations}}\n<% } -%>\n<% if ( unread.tags && unread.tags.includes('Highlights') ) { %>\n![[<%% tp.file.title %>_mentions#Highlight Mentions]]\n<% } -%>\n<% if ( unread.refs ) { %>\n## Reference   \n{{-|refs}}  \n<% } %>"},"PcmPCT9rgM":{},"UEzvAXNSe5":{},"VQOZdNET2d":{},"tMGXrU1v0U":{},"tbjTx33iAA":{"exist":"false"},"y8Mai5IBwN":{}},"secret":{"dropbox":{"access_token":""},"evernote":{"access_token":""},"flomo":{"access_token":""},"focusnote":{"access_token":""},"gdrive":{"access_token":"","folder_id":""},"github":{"access_token":"","path":"","repo":""},"hypothes":{"access_token":"","group_id":""},"instapaper":{"access_token":"","token_secret":""},"jianguo":{"access_token":"","password":"","username":""},"joplin":{"access_token":"","folder_id":""},"linnk":{"access_token":"","group_name":""},"notion":{"access_token":"","folder_id":"","save_image":false,"type":""},"onenote":{"access_token":"EwCAA8l6BAAUAOyDv0l6PcCVu89kmzvqZmkWABkAAQF/wrjKqDu74A9XGTG/jsxaDLqhunnB5Cpd+ZtqiRg7gpjE7tIfU4krdueOfM4fJEew3ZTb9/wdZqWRmjd62FokVspMXv2P0fsKkbny8YNng7yeBBnVAe87Wj30a34rNhvsbfZ5/H2lZk72bLOzaWOMbASim5AdTCbbQLLs1Oo8tVBugKwUvUakJmXsT2SYsMlF8qzChKcQlHQ40egoIdtsF1pPt8pSPj1UJDdeX2N/hWbyLCKzjXD00HtEurQI/u1C69goOOqBc+9WyK5LT6bF2KIR5E10WBqD6RXcSqN1qDJt1AXh7+eLIiodIqvry+ja/ZA5zM8O02N4wFyqPjQDZgAACE0w+xIfD275UAJTzQzhz4Cya4tXmlmVMD9HalkBgwO+GCdu+7iOqUpobkWoztdg0GkCk94nYOEqzP30Qg+LxmMcRESqCHi88WRkrt2TrVG2Gxvt01TFTQH/M7M33JABHo+jHO4q8iOUCDdN1H/J7N3vVUQ1hN9brf7DLqNPHr49ESWce3RtTQQj31HBoSHLNdsWPMVSH9A5pltv7EH8+52KWWVONptOdf+5J1u0Qj06tuF8KlYWOU0HtS3jQGWNOgDAC1Xn7K9ApC5PE/H8s8PUWdFd7faT79TKmmZYuXmTSl9CQpXqSnSS+k+0fODluDf7CKAp5zst+gjxniuml5SxcpoQhex8FcZszfnStx15uPlrbUlYYWt0PxHwSiSmOOKMREbEQwyY8r/JdnAHjz6az7Hmaujv1cAvYH6X1ulBSPAT+G2o0Dvl4fsGvMgXFUuWnjACGd6SkG+F9hUXy75uLdd6fvDBeTvzvucQxjoIDBTiQty7moJyNB2u4rKMWGD7qbryxJxvFU4wfUvETPAjOXdfORy27IZ5DOQfo3YA6BiZnLsrgsUczW+WiuHLIt8g9LwyK7APJLbXFJNbkQFCHusAZwRbYEMofj24qx+VYsl43I+vHgUP2DbhCI5Zl171WLjsXFQviAyaw48TOEHWbQ7yQISaQVXfNfUszPcIZ0ky8LuGkvK4B7f0W5yKBb3LyaszoYWCGScYgcrGMTqsWDBM3OXIKFJDyeYLNinvvq8/F9aNv9G8msMjbMHgqljqGN/Y8ss6BlBIw3h/lkBkP2nX0oQS/FsrcwI=","refresh_token":"M.C107_BAY.-CfzhpkW3DZ8ZDQ!yG8MYn4dahvLxKBq*d33irh2vXMVxGv2EcejVEryUFYv3EAcE7cRuycHrPFglSkgSmB76NjzEjZv!fRqfk5yadnrMmqFCTJ0Ze0296UtfdxanbGNOWHeWC1pMT5XSh*H1HIoAab59EhvC47huellaZIiw9MNaxywEc!a38swT9hGLqwSeCm25tjWusaoSJPIX5DHFlTuE14hLsPaeScZ3oP45ofXodIUs7bn*jsNxgJmdTBm5H5ZrY8osJO9R1WfsYiIE2WVNewua62G!eEWmGhQHMOu5DGZ*zURS2cbjvbaseU50kXBlCmAgGCJ0iDTZ0EcN5Uagl71R*rYOpFtPabDQRU14rrP1GBChnKQI39vNM0e2Eg$$"},"pocket":{"access_token":"","tags":""},"version":"2021-01-19","webdav":[],"weizhi":{"access_token":"","folder":"","host":"","kbGuid":"","kbServer":"","password":"","username":""},"yinxiang":{"access_token":""},"youdao":{"access_token":"","folder_id":""},"yuque":{"access_token":"","repos_id":""}}}